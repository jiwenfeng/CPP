// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.ai.proto

#ifndef PROTOBUF_server_2eai_2eproto__INCLUDED
#define PROTOBUF_server_2eai_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace server {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_server_2eai_2eproto();
void protobuf_AssignDesc_server_2eai_2eproto();
void protobuf_ShutdownFile_server_2eai_2eproto();

class ai_method;
class ai_move;
class ai_fix_move;
class ai_timer;
class ai_status;
class ai_attr;
class ai_distance;
class ai_attack;
class ai_defense;
class ai_dead;
class ai_hide;
class ai_stop;
class ai_master;
class ai_msg;
class ai_data;
class ai_info;
class ai_run;
class appeare;
class advance_appeare;
class into_appeare;
class after_story;
class kill_monster;
class touch_task;
class start_activity;
class start_time_week;
class start_time_day;
class start_time;
class get_item;
class touch_scense_object;
class find_monster;
class group_monster;
class appear_around;
class create_msg;
class suspend_create;
class create_npc_rule;
class create_npc_rules;
class appear_effect;
class create_effect_rule;
class create_effect_rules;
class dead_role;
class survive_role;
class scene_timeout;
class dead_count;
class role_attribute;
class role_postion;
class raid_success_rule;
class raid_failure_rule;
class raid_over_rules;

enum appeare_type {
  appeare_type_normal = 1,
  appeare_type_sky = 2,
  appeare_type_ground = 3,
  appeare_type_view = 4,
  appeare_type_around = 5
};
bool appeare_type_IsValid(int value);
const appeare_type appeare_type_type_MIN = appeare_type_normal;
const appeare_type appeare_type_type_MAX = appeare_type_around;
const int appeare_type_type_ARRAYSIZE = appeare_type_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* appeare_type_descriptor();
inline const ::std::string& appeare_type_Name(appeare_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    appeare_type_descriptor(), value);
}
inline bool appeare_type_Parse(
    const ::std::string& name, appeare_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<appeare_type>(
    appeare_type_descriptor(), name, value);
}
enum AI_COMPARE_RULE {
  ACR_LESS = 0,
  ACR_GREATER = 1,
  ACR_EQUAL = 2
};
bool AI_COMPARE_RULE_IsValid(int value);
const AI_COMPARE_RULE AI_COMPARE_RULE_MIN = ACR_LESS;
const AI_COMPARE_RULE AI_COMPARE_RULE_MAX = ACR_EQUAL;
const int AI_COMPARE_RULE_ARRAYSIZE = AI_COMPARE_RULE_MAX + 1;

const ::google::protobuf::EnumDescriptor* AI_COMPARE_RULE_descriptor();
inline const ::std::string& AI_COMPARE_RULE_Name(AI_COMPARE_RULE value) {
  return ::google::protobuf::internal::NameOfEnum(
    AI_COMPARE_RULE_descriptor(), value);
}
inline bool AI_COMPARE_RULE_Parse(
    const ::std::string& name, AI_COMPARE_RULE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AI_COMPARE_RULE>(
    AI_COMPARE_RULE_descriptor(), name, value);
}
enum AI_TARGET_TYPE {
  ATT_OWN = 0,
  ATT_ENEMY = 1
};
bool AI_TARGET_TYPE_IsValid(int value);
const AI_TARGET_TYPE AI_TARGET_TYPE_MIN = ATT_OWN;
const AI_TARGET_TYPE AI_TARGET_TYPE_MAX = ATT_ENEMY;
const int AI_TARGET_TYPE_ARRAYSIZE = AI_TARGET_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* AI_TARGET_TYPE_descriptor();
inline const ::std::string& AI_TARGET_TYPE_Name(AI_TARGET_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    AI_TARGET_TYPE_descriptor(), value);
}
inline bool AI_TARGET_TYPE_Parse(
    const ::std::string& name, AI_TARGET_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AI_TARGET_TYPE>(
    AI_TARGET_TYPE_descriptor(), name, value);
}
// ===================================================================

class ai_method : public ::google::protobuf::Message {
 public:
  ai_method();
  virtual ~ai_method();

  ai_method(const ai_method& from);

  inline ai_method& operator=(const ai_method& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_method& default_instance();

  void Swap(ai_method* other);

  // implements Message ----------------------------------------------

  ai_method* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_method& from);
  void MergeFrom(const ai_method& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rand = 1;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 1;
  inline ::google::protobuf::uint32 rand() const;
  inline void set_rand(::google::protobuf::uint32 value);

  // required uint32 skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // required uint32 target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);

  // required uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_method)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rand_;
  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_method* default_instance_;
};
// -------------------------------------------------------------------

class ai_move : public ::google::protobuf::Message {
 public:
  ai_move();
  virtual ~ai_move();

  ai_move(const ai_move& from);

  inline ai_move& operator=(const ai_move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_move& default_instance();

  void Swap(ai_move* other);

  // implements Message ----------------------------------------------

  ai_move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_move& from);
  void MergeFrom(const ai_move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 x = 1;
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x(int index) const;
  inline void set_x(int index, ::google::protobuf::uint32 value);
  inline void add_x(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      x() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_x();

  // repeated uint32 y = 2;
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y(int index) const;
  inline void set_y(int index, ::google::protobuf::uint32 value);
  inline void add_y(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      y() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_y();

  // required uint32 rand = 3;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 3;
  inline ::google::protobuf::uint32 rand() const;
  inline void set_rand(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_move)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > x_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > y_;
  ::google::protobuf::uint32 rand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_move* default_instance_;
};
// -------------------------------------------------------------------

class ai_fix_move : public ::google::protobuf::Message {
 public:
  ai_fix_move();
  virtual ~ai_fix_move();

  ai_fix_move(const ai_fix_move& from);

  inline ai_fix_move& operator=(const ai_fix_move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_fix_move& default_instance();

  void Swap(ai_fix_move* other);

  // implements Message ----------------------------------------------

  ai_fix_move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_fix_move& from);
  void MergeFrom(const ai_fix_move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 grid = 1;
  inline int grid_size() const;
  inline void clear_grid();
  static const int kGridFieldNumber = 1;
  inline ::google::protobuf::uint32 grid(int index) const;
  inline void set_grid(int index, ::google::protobuf::uint32 value);
  inline void add_grid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      grid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_grid();

  // repeated uint32 atk = 2;
  inline int atk_size() const;
  inline void clear_atk();
  static const int kAtkFieldNumber = 2;
  inline ::google::protobuf::uint32 atk(int index) const;
  inline void set_atk(int index, ::google::protobuf::uint32 value);
  inline void add_atk(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      atk() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_atk();

  // repeated uint32 watch = 3;
  inline int watch_size() const;
  inline void clear_watch();
  static const int kWatchFieldNumber = 3;
  inline ::google::protobuf::uint32 watch(int index) const;
  inline void set_watch(int index, ::google::protobuf::uint32 value);
  inline void add_watch(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      watch() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_watch();

  // repeated uint32 block = 4;
  inline int block_size() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 4;
  inline ::google::protobuf::uint32 block(int index) const;
  inline void set_block(int index, ::google::protobuf::uint32 value);
  inline void add_block(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      block() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_block();

  // required uint32 rand = 5;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 5;
  inline ::google::protobuf::uint32 rand() const;
  inline void set_rand(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_fix_move)
 private:
  inline void set_has_rand();
  inline void clear_has_rand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > grid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > atk_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > watch_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > block_;
  ::google::protobuf::uint32 rand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_fix_move* default_instance_;
};
// -------------------------------------------------------------------

class ai_timer : public ::google::protobuf::Message {
 public:
  ai_timer();
  virtual ~ai_timer();

  ai_timer(const ai_timer& from);

  inline ai_timer& operator=(const ai_timer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_timer& default_instance();

  void Swap(ai_timer* other);

  // implements Message ----------------------------------------------

  ai_timer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_timer& from);
  void MergeFrom(const ai_timer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timer = 1;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 1;
  inline ::google::protobuf::uint32 timer() const;
  inline void set_timer(::google::protobuf::uint32 value);

  // optional uint32 alarm = 2;
  inline bool has_alarm() const;
  inline void clear_alarm();
  static const int kAlarmFieldNumber = 2;
  inline ::google::protobuf::uint32 alarm() const;
  inline void set_alarm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_timer)
 private:
  inline void set_has_timer();
  inline void clear_has_timer();
  inline void set_has_alarm();
  inline void clear_has_alarm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timer_;
  ::google::protobuf::uint32 alarm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_timer* default_instance_;
};
// -------------------------------------------------------------------

class ai_status : public ::google::protobuf::Message {
 public:
  ai_status();
  virtual ~ai_status();

  ai_status(const ai_status& from);

  inline ai_status& operator=(const ai_status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_status& default_instance();

  void Swap(ai_status* other);

  // implements Message ----------------------------------------------

  ai_status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_status& from);
  void MergeFrom(const ai_status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 timer = 2;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 2;
  inline ::google::protobuf::uint32 timer() const;
  inline void set_timer(::google::protobuf::uint32 value);

  // optional uint32 each = 3;
  inline bool has_each() const;
  inline void clear_each();
  static const int kEachFieldNumber = 3;
  inline ::google::protobuf::uint32 each() const;
  inline void set_each(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_status)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_timer();
  inline void clear_has_timer();
  inline void set_has_each();
  inline void clear_has_each();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 timer_;
  ::google::protobuf::uint32 each_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_status* default_instance_;
};
// -------------------------------------------------------------------

class ai_attr : public ::google::protobuf::Message {
 public:
  ai_attr();
  virtual ~ai_attr();

  ai_attr(const ai_attr& from);

  inline ai_attr& operator=(const ai_attr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_attr& default_instance();

  void Swap(ai_attr* other);

  // implements Message ----------------------------------------------

  ai_attr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_attr& from);
  void MergeFrom(const ai_attr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attr = 1;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 1;
  inline ::google::protobuf::uint32 attr() const;
  inline void set_attr(::google::protobuf::uint32 value);

  // optional uint32 less = 2;
  inline bool has_less() const;
  inline void clear_less();
  static const int kLessFieldNumber = 2;
  inline ::google::protobuf::uint32 less() const;
  inline void set_less(::google::protobuf::uint32 value);

  // optional uint32 greater = 3;
  inline bool has_greater() const;
  inline void clear_greater();
  static const int kGreaterFieldNumber = 3;
  inline ::google::protobuf::uint32 greater() const;
  inline void set_greater(::google::protobuf::uint32 value);

  // optional uint32 equal = 4;
  inline bool has_equal() const;
  inline void clear_equal();
  static const int kEqualFieldNumber = 4;
  inline ::google::protobuf::uint32 equal() const;
  inline void set_equal(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_attr)
 private:
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_less();
  inline void clear_has_less();
  inline void set_has_greater();
  inline void clear_has_greater();
  inline void set_has_equal();
  inline void clear_has_equal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 attr_;
  ::google::protobuf::uint32 less_;
  ::google::protobuf::uint32 greater_;
  ::google::protobuf::uint32 equal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_attr* default_instance_;
};
// -------------------------------------------------------------------

class ai_distance : public ::google::protobuf::Message {
 public:
  ai_distance();
  virtual ~ai_distance();

  ai_distance(const ai_distance& from);

  inline ai_distance& operator=(const ai_distance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_distance& default_instance();

  void Swap(ai_distance* other);

  // implements Message ----------------------------------------------

  ai_distance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_distance& from);
  void MergeFrom(const ai_distance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 distance = 1;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 1;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);

  // required uint32 limit = 2;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);

  // optional uint32 less = 3;
  inline bool has_less() const;
  inline void clear_less();
  static const int kLessFieldNumber = 3;
  inline ::google::protobuf::uint32 less() const;
  inline void set_less(::google::protobuf::uint32 value);

  // optional uint32 greater = 4;
  inline bool has_greater() const;
  inline void clear_greater();
  static const int kGreaterFieldNumber = 4;
  inline ::google::protobuf::uint32 greater() const;
  inline void set_greater(::google::protobuf::uint32 value);

  // optional uint32 equal = 5;
  inline bool has_equal() const;
  inline void clear_equal();
  static const int kEqualFieldNumber = 5;
  inline ::google::protobuf::uint32 equal() const;
  inline void set_equal(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_distance)
 private:
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_less();
  inline void clear_has_less();
  inline void set_has_greater();
  inline void clear_has_greater();
  inline void set_has_equal();
  inline void clear_has_equal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 distance_;
  ::google::protobuf::uint32 limit_;
  ::google::protobuf::uint32 less_;
  ::google::protobuf::uint32 greater_;
  ::google::protobuf::uint32 equal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_distance* default_instance_;
};
// -------------------------------------------------------------------

class ai_attack : public ::google::protobuf::Message {
 public:
  ai_attack();
  virtual ~ai_attack();

  ai_attack(const ai_attack& from);

  inline ai_attack& operator=(const ai_attack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_attack& default_instance();

  void Swap(ai_attack* other);

  // implements Message ----------------------------------------------

  ai_attack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_attack& from);
  void MergeFrom(const ai_attack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 attack = 1;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 1;
  inline ::google::protobuf::uint32 attack() const;
  inline void set_attack(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_attack)
 private:
  inline void set_has_attack();
  inline void clear_has_attack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 attack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_attack* default_instance_;
};
// -------------------------------------------------------------------

class ai_defense : public ::google::protobuf::Message {
 public:
  ai_defense();
  virtual ~ai_defense();

  ai_defense(const ai_defense& from);

  inline ai_defense& operator=(const ai_defense& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_defense& default_instance();

  void Swap(ai_defense* other);

  // implements Message ----------------------------------------------

  ai_defense* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_defense& from);
  void MergeFrom(const ai_defense& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 defense = 1;
  inline bool has_defense() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 1;
  inline ::google::protobuf::uint32 defense() const;
  inline void set_defense(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_defense)
 private:
  inline void set_has_defense();
  inline void clear_has_defense();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 defense_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_defense* default_instance_;
};
// -------------------------------------------------------------------

class ai_dead : public ::google::protobuf::Message {
 public:
  ai_dead();
  virtual ~ai_dead();

  ai_dead(const ai_dead& from);

  inline ai_dead& operator=(const ai_dead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_dead& default_instance();

  void Swap(ai_dead* other);

  // implements Message ----------------------------------------------

  ai_dead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_dead& from);
  void MergeFrom(const ai_dead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool dead = 1;
  inline bool has_dead() const;
  inline void clear_dead();
  static const int kDeadFieldNumber = 1;
  inline bool dead() const;
  inline void set_dead(bool value);

  // @@protoc_insertion_point(class_scope:server.ai_dead)
 private:
  inline void set_has_dead();
  inline void clear_has_dead();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool dead_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_dead* default_instance_;
};
// -------------------------------------------------------------------

class ai_hide : public ::google::protobuf::Message {
 public:
  ai_hide();
  virtual ~ai_hide();

  ai_hide(const ai_hide& from);

  inline ai_hide& operator=(const ai_hide& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_hide& default_instance();

  void Swap(ai_hide* other);

  // implements Message ----------------------------------------------

  ai_hide* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_hide& from);
  void MergeFrom(const ai_hide& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 rand = 2;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 2;
  inline ::google::protobuf::uint32 rand() const;
  inline void set_rand(::google::protobuf::uint32 value);

  // required uint32 pet = 3;
  inline bool has_pet() const;
  inline void clear_pet();
  static const int kPetFieldNumber = 3;
  inline ::google::protobuf::uint32 pet() const;
  inline void set_pet(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_hide)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_rand();
  inline void clear_has_rand();
  inline void set_has_pet();
  inline void clear_has_pet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 rand_;
  ::google::protobuf::uint32 pet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_hide* default_instance_;
};
// -------------------------------------------------------------------

class ai_stop : public ::google::protobuf::Message {
 public:
  ai_stop();
  virtual ~ai_stop();

  ai_stop(const ai_stop& from);

  inline ai_stop& operator=(const ai_stop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_stop& default_instance();

  void Swap(ai_stop* other);

  // implements Message ----------------------------------------------

  ai_stop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_stop& from);
  void MergeFrom(const ai_stop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 rand = 2;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 2;
  inline ::google::protobuf::uint32 rand() const;
  inline void set_rand(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_stop)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_rand();
  inline void clear_has_rand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 rand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_stop* default_instance_;
};
// -------------------------------------------------------------------

class ai_master : public ::google::protobuf::Message {
 public:
  ai_master();
  virtual ~ai_master();

  ai_master(const ai_master& from);

  inline ai_master& operator=(const ai_master& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_master& default_instance();

  void Swap(ai_master* other);

  // implements Message ----------------------------------------------

  ai_master* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_master& from);
  void MergeFrom(const ai_master& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 rand = 3;
  inline bool has_rand() const;
  inline void clear_rand();
  static const int kRandFieldNumber = 3;
  inline ::google::protobuf::uint32 rand() const;
  inline void set_rand(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.ai_master)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_rand();
  inline void clear_has_rand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 rand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_master* default_instance_;
};
// -------------------------------------------------------------------

class ai_msg : public ::google::protobuf::Message {
 public:
  ai_msg();
  virtual ~ai_msg();

  ai_msg(const ai_msg& from);

  inline ai_msg& operator=(const ai_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_msg& default_instance();

  void Swap(ai_msg* other);

  // implements Message ----------------------------------------------

  ai_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_msg& from);
  void MergeFrom(const ai_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // required uint32 show = 2;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 2;
  inline ::google::protobuf::uint32 show() const;
  inline void set_show(::google::protobuf::uint32 value);

  // required uint32 delay = 3;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 3;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // optional bool send = 4;
  inline bool has_send() const;
  inline void clear_send();
  static const int kSendFieldNumber = 4;
  inline bool send() const;
  inline void set_send(bool value);

  // @@protoc_insertion_point(class_scope:server.ai_msg)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_send();
  inline void clear_has_send();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::google::protobuf::uint32 show_;
  ::google::protobuf::uint32 delay_;
  bool send_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_msg* default_instance_;
};
// -------------------------------------------------------------------

class ai_data : public ::google::protobuf::Message {
 public:
  ai_data();
  virtual ~ai_data();

  ai_data(const ai_data& from);

  inline ai_data& operator=(const ai_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_data& default_instance();

  void Swap(ai_data* other);

  // implements Message ----------------------------------------------

  ai_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_data& from);
  void MergeFrom(const ai_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.ai_timer timer = 1;
  inline int timer_size() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 1;
  inline const ::server::ai_timer& timer(int index) const;
  inline ::server::ai_timer* mutable_timer(int index);
  inline ::server::ai_timer* add_timer();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_timer >&
      timer() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_timer >*
      mutable_timer();

  // repeated .server.ai_status status = 2;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::server::ai_status& status(int index) const;
  inline ::server::ai_status* mutable_status(int index);
  inline ::server::ai_status* add_status();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_status >&
      status() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_status >*
      mutable_status();

  // repeated .server.ai_attr attr = 3;
  inline int attr_size() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 3;
  inline const ::server::ai_attr& attr(int index) const;
  inline ::server::ai_attr* mutable_attr(int index);
  inline ::server::ai_attr* add_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_attr >&
      attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_attr >*
      mutable_attr();

  // repeated .server.ai_distance distance = 4;
  inline int distance_size() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 4;
  inline const ::server::ai_distance& distance(int index) const;
  inline ::server::ai_distance* mutable_distance(int index);
  inline ::server::ai_distance* add_distance();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_distance >&
      distance() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_distance >*
      mutable_distance();

  // repeated .server.ai_attack attack = 5;
  inline int attack_size() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 5;
  inline const ::server::ai_attack& attack(int index) const;
  inline ::server::ai_attack* mutable_attack(int index);
  inline ::server::ai_attack* add_attack();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_attack >&
      attack() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_attack >*
      mutable_attack();

  // repeated .server.ai_defense defense = 6;
  inline int defense_size() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 6;
  inline const ::server::ai_defense& defense(int index) const;
  inline ::server::ai_defense* mutable_defense(int index);
  inline ::server::ai_defense* add_defense();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_defense >&
      defense() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_defense >*
      mutable_defense();

  // optional .server.ai_dead dead = 7;
  inline bool has_dead() const;
  inline void clear_dead();
  static const int kDeadFieldNumber = 7;
  inline const ::server::ai_dead& dead() const;
  inline ::server::ai_dead* mutable_dead();
  inline ::server::ai_dead* release_dead();
  inline void set_allocated_dead(::server::ai_dead* dead);

  // repeated .server.ai_method method = 8;
  inline int method_size() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 8;
  inline const ::server::ai_method& method(int index) const;
  inline ::server::ai_method* mutable_method(int index);
  inline ::server::ai_method* add_method();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_method >&
      method() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_method >*
      mutable_method();

  // repeated .server.ai_move move = 9;
  inline int move_size() const;
  inline void clear_move();
  static const int kMoveFieldNumber = 9;
  inline const ::server::ai_move& move(int index) const;
  inline ::server::ai_move* mutable_move(int index);
  inline ::server::ai_move* add_move();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_move >&
      move() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_move >*
      mutable_move();

  // repeated .server.ai_fix_move fix_move = 10;
  inline int fix_move_size() const;
  inline void clear_fix_move();
  static const int kFixMoveFieldNumber = 10;
  inline const ::server::ai_fix_move& fix_move(int index) const;
  inline ::server::ai_fix_move* mutable_fix_move(int index);
  inline ::server::ai_fix_move* add_fix_move();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_fix_move >&
      fix_move() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_fix_move >*
      mutable_fix_move();

  // repeated .server.ai_move force_move = 11;
  inline int force_move_size() const;
  inline void clear_force_move();
  static const int kForceMoveFieldNumber = 11;
  inline const ::server::ai_move& force_move(int index) const;
  inline ::server::ai_move* mutable_force_move(int index);
  inline ::server::ai_move* add_force_move();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_move >&
      force_move() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_move >*
      mutable_force_move();

  // repeated .server.ai_attack target = 12;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 12;
  inline const ::server::ai_attack& target(int index) const;
  inline ::server::ai_attack* mutable_target(int index);
  inline ::server::ai_attack* add_target();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_attack >&
      target() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_attack >*
      mutable_target();

  // optional .server.ai_msg msg = 13;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 13;
  inline const ::server::ai_msg& msg() const;
  inline ::server::ai_msg* mutable_msg();
  inline ::server::ai_msg* release_msg();
  inline void set_allocated_msg(::server::ai_msg* msg);

  // optional .server.ai_stop stop = 14;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 14;
  inline const ::server::ai_stop& stop() const;
  inline ::server::ai_stop* mutable_stop();
  inline ::server::ai_stop* release_stop();
  inline void set_allocated_stop(::server::ai_stop* stop);

  // optional .server.ai_hide hide = 15;
  inline bool has_hide() const;
  inline void clear_hide();
  static const int kHideFieldNumber = 15;
  inline const ::server::ai_hide& hide() const;
  inline ::server::ai_hide* mutable_hide();
  inline ::server::ai_hide* release_hide();
  inline void set_allocated_hide(::server::ai_hide* hide);

  // optional .server.ai_master master = 16;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 16;
  inline const ::server::ai_master& master() const;
  inline ::server::ai_master* mutable_master();
  inline ::server::ai_master* release_master();
  inline void set_allocated_master(::server::ai_master* master);

  // @@protoc_insertion_point(class_scope:server.ai_data)
 private:
  inline void set_has_dead();
  inline void clear_has_dead();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_hide();
  inline void clear_has_hide();
  inline void set_has_master();
  inline void clear_has_master();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::ai_timer > timer_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_status > status_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_attr > attr_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_distance > distance_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_attack > attack_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_defense > defense_;
  ::server::ai_dead* dead_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_method > method_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_move > move_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_fix_move > fix_move_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_move > force_move_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_attack > target_;
  ::server::ai_msg* msg_;
  ::server::ai_stop* stop_;
  ::server::ai_hide* hide_;
  ::server::ai_master* master_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_data* default_instance_;
};
// -------------------------------------------------------------------

class ai_info : public ::google::protobuf::Message {
 public:
  ai_info();
  virtual ~ai_info();

  ai_info(const ai_info& from);

  inline ai_info& operator=(const ai_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_info& default_instance();

  void Swap(ai_info* other);

  // implements Message ----------------------------------------------

  ai_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_info& from);
  void MergeFrom(const ai_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.ai_data ai = 1;
  inline int ai_size() const;
  inline void clear_ai();
  static const int kAiFieldNumber = 1;
  inline const ::server::ai_data& ai(int index) const;
  inline ::server::ai_data* mutable_ai(int index);
  inline ::server::ai_data* add_ai();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_data >&
      ai() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_data >*
      mutable_ai();

  // @@protoc_insertion_point(class_scope:server.ai_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::ai_data > ai_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_info* default_instance_;
};
// -------------------------------------------------------------------

class ai_run : public ::google::protobuf::Message {
 public:
  ai_run();
  virtual ~ai_run();

  ai_run(const ai_run& from);

  inline ai_run& operator=(const ai_run& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_run& default_instance();

  void Swap(ai_run* other);

  // implements Message ----------------------------------------------

  ai_run* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ai_run& from);
  void MergeFrom(const ai_run& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .server.ai_method method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  inline const ::server::ai_method& method() const;
  inline ::server::ai_method* mutable_method();
  inline ::server::ai_method* release_method();
  inline void set_allocated_method(::server::ai_method* method);

  // optional .server.ai_move move = 2;
  inline bool has_move() const;
  inline void clear_move();
  static const int kMoveFieldNumber = 2;
  inline const ::server::ai_move& move() const;
  inline ::server::ai_move* mutable_move();
  inline ::server::ai_move* release_move();
  inline void set_allocated_move(::server::ai_move* move);

  // optional .server.ai_fix_move fix_move = 3;
  inline bool has_fix_move() const;
  inline void clear_fix_move();
  static const int kFixMoveFieldNumber = 3;
  inline const ::server::ai_fix_move& fix_move() const;
  inline ::server::ai_fix_move* mutable_fix_move();
  inline ::server::ai_fix_move* release_fix_move();
  inline void set_allocated_fix_move(::server::ai_fix_move* fix_move);

  // optional .server.ai_attack target = 4;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline const ::server::ai_attack& target() const;
  inline ::server::ai_attack* mutable_target();
  inline ::server::ai_attack* release_target();
  inline void set_allocated_target(::server::ai_attack* target);

  // optional .server.ai_msg msg = 5;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 5;
  inline const ::server::ai_msg& msg() const;
  inline ::server::ai_msg* mutable_msg();
  inline ::server::ai_msg* release_msg();
  inline void set_allocated_msg(::server::ai_msg* msg);

  // optional .server.ai_stop stop = 6;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 6;
  inline const ::server::ai_stop& stop() const;
  inline ::server::ai_stop* mutable_stop();
  inline ::server::ai_stop* release_stop();
  inline void set_allocated_stop(::server::ai_stop* stop);

  // optional .server.ai_hide hide = 7;
  inline bool has_hide() const;
  inline void clear_hide();
  static const int kHideFieldNumber = 7;
  inline const ::server::ai_hide& hide() const;
  inline ::server::ai_hide* mutable_hide();
  inline ::server::ai_hide* release_hide();
  inline void set_allocated_hide(::server::ai_hide* hide);

  // optional .server.ai_master master = 8;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 8;
  inline const ::server::ai_master& master() const;
  inline ::server::ai_master* mutable_master();
  inline ::server::ai_master* release_master();
  inline void set_allocated_master(::server::ai_master* master);

  // @@protoc_insertion_point(class_scope:server.ai_run)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_move();
  inline void clear_has_move();
  inline void set_has_fix_move();
  inline void clear_has_fix_move();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_hide();
  inline void clear_has_hide();
  inline void set_has_master();
  inline void clear_has_master();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::server::ai_method* method_;
  ::server::ai_move* move_;
  ::server::ai_fix_move* fix_move_;
  ::server::ai_attack* target_;
  ::server::ai_msg* msg_;
  ::server::ai_stop* stop_;
  ::server::ai_hide* hide_;
  ::server::ai_master* master_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static ai_run* default_instance_;
};
// -------------------------------------------------------------------

class appeare : public ::google::protobuf::Message {
 public:
  appeare();
  virtual ~appeare();

  appeare(const appeare& from);

  inline appeare& operator=(const appeare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const appeare& default_instance();

  void Swap(appeare* other);

  // implements Message ----------------------------------------------

  appeare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const appeare& from);
  void MergeFrom(const appeare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef appeare_type type;
  static const type normal = appeare_type_normal;
  static const type sky = appeare_type_sky;
  static const type ground = appeare_type_ground;
  static const type view = appeare_type_view;
  static const type around = appeare_type_around;
  static inline bool type_IsValid(int value) {
    return appeare_type_IsValid(value);
  }
  static const type type_MIN =
    appeare_type_type_MIN;
  static const type type_MAX =
    appeare_type_type_MAX;
  static const int type_ARRAYSIZE =
    appeare_type_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  type_descriptor() {
    return appeare_type_descriptor();
  }
  static inline const ::std::string& type_Name(type value) {
    return appeare_type_Name(value);
  }
  static inline bool type_Parse(const ::std::string& name,
      type* value) {
    return appeare_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 x = 1;
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x(int index) const;
  inline void set_x(int index, ::google::protobuf::int32 value);
  inline void add_x(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      x() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_x();

  // repeated int32 y = 2;
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y(int index) const;
  inline void set_y(int index, ::google::protobuf::int32 value);
  inline void add_y(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      y() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_y();

  // repeated int32 roll = 3;
  inline int roll_size() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 3;
  inline ::google::protobuf::int32 roll(int index) const;
  inline void set_roll(int index, ::google::protobuf::int32 value);
  inline void add_roll(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      roll() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_roll();

  // repeated uint32 effect = 4;
  inline int effect_size() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 4;
  inline ::google::protobuf::uint32 effect(int index) const;
  inline void set_effect(int index, ::google::protobuf::uint32 value);
  inline void add_effect(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      effect() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_effect();

  // required .server.appeare.type t = 5;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 5;
  inline ::server::appeare_type t() const;
  inline void set_t(::server::appeare_type value);

  // @@protoc_insertion_point(class_scope:server.appeare)
 private:
  inline void set_has_t();
  inline void clear_has_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > x_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > y_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > roll_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > effect_;
  int t_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static appeare* default_instance_;
};
// -------------------------------------------------------------------

class advance_appeare : public ::google::protobuf::Message {
 public:
  advance_appeare();
  virtual ~advance_appeare();

  advance_appeare(const advance_appeare& from);

  inline advance_appeare& operator=(const advance_appeare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const advance_appeare& default_instance();

  void Swap(advance_appeare* other);

  // implements Message ----------------------------------------------

  advance_appeare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const advance_appeare& from);
  void MergeFrom(const advance_appeare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:server.advance_appeare)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static advance_appeare* default_instance_;
};
// -------------------------------------------------------------------

class into_appeare : public ::google::protobuf::Message {
 public:
  into_appeare();
  virtual ~into_appeare();

  into_appeare(const into_appeare& from);

  inline into_appeare& operator=(const into_appeare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const into_appeare& default_instance();

  void Swap(into_appeare* other);

  // implements Message ----------------------------------------------

  into_appeare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const into_appeare& from);
  void MergeFrom(const into_appeare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 distance = 3;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 3;
  inline ::google::protobuf::int32 distance() const;
  inline void set_distance(::google::protobuf::int32 value);

  // optional uint32 seconds = 4;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 4;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // optional uint32 role = 5;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 5;
  inline ::google::protobuf::uint32 role() const;
  inline void set_role(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.into_appeare)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 distance_;
  ::google::protobuf::uint32 seconds_;
  ::google::protobuf::uint32 role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static into_appeare* default_instance_;
};
// -------------------------------------------------------------------

class after_story : public ::google::protobuf::Message {
 public:
  after_story();
  virtual ~after_story();

  after_story(const after_story& from);

  inline after_story& operator=(const after_story& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const after_story& default_instance();

  void Swap(after_story* other);

  // implements Message ----------------------------------------------

  after_story* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const after_story& from);
  void MergeFrom(const after_story& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 tick = 2;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 2;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.after_story)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static after_story* default_instance_;
};
// -------------------------------------------------------------------

class kill_monster : public ::google::protobuf::Message {
 public:
  kill_monster();
  virtual ~kill_monster();

  kill_monster(const kill_monster& from);

  inline kill_monster& operator=(const kill_monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const kill_monster& default_instance();

  void Swap(kill_monster* other);

  // implements Message ----------------------------------------------

  kill_monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const kill_monster& from);
  void MergeFrom(const kill_monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 monster_id = 1;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 monster_id() const;
  inline void set_monster_id(::google::protobuf::uint32 value);

  // required uint32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // optional uint32 seconds = 3;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 3;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.kill_monster)
 private:
  inline void set_has_monster_id();
  inline void clear_has_monster_id();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 monster_id_;
  ::google::protobuf::uint32 number_;
  ::google::protobuf::uint32 seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static kill_monster* default_instance_;
};
// -------------------------------------------------------------------

class touch_task : public ::google::protobuf::Message {
 public:
  touch_task();
  virtual ~touch_task();

  touch_task(const touch_task& from);

  inline touch_task& operator=(const touch_task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const touch_task& default_instance();

  void Swap(touch_task* other);

  // implements Message ----------------------------------------------

  touch_task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const touch_task& from);
  void MergeFrom(const touch_task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.touch_task)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static touch_task* default_instance_;
};
// -------------------------------------------------------------------

class start_activity : public ::google::protobuf::Message {
 public:
  start_activity();
  virtual ~start_activity();

  start_activity(const start_activity& from);

  inline start_activity& operator=(const start_activity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_activity& default_instance();

  void Swap(start_activity* other);

  // implements Message ----------------------------------------------

  start_activity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_activity& from);
  void MergeFrom(const start_activity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::uint32 activity_id() const;
  inline void set_activity_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.start_activity)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static start_activity* default_instance_;
};
// -------------------------------------------------------------------

class start_time_week : public ::google::protobuf::Message {
 public:
  start_time_week();
  virtual ~start_time_week();

  start_time_week(const start_time_week& from);

  inline start_time_week& operator=(const start_time_week& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_time_week& default_instance();

  void Swap(start_time_week* other);

  // implements Message ----------------------------------------------

  start_time_week* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_time_week& from);
  void MergeFrom(const start_time_week& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 d = 1;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 1;
  inline ::google::protobuf::uint32 d() const;
  inline void set_d(::google::protobuf::uint32 value);

  // required .server.start_time_day t = 2;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 2;
  inline const ::server::start_time_day& t() const;
  inline ::server::start_time_day* mutable_t();
  inline ::server::start_time_day* release_t();
  inline void set_allocated_t(::server::start_time_day* t);

  // @@protoc_insertion_point(class_scope:server.start_time_week)
 private:
  inline void set_has_d();
  inline void clear_has_d();
  inline void set_has_t();
  inline void clear_has_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::server::start_time_day* t_;
  ::google::protobuf::uint32 d_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static start_time_week* default_instance_;
};
// -------------------------------------------------------------------

class start_time_day : public ::google::protobuf::Message {
 public:
  start_time_day();
  virtual ~start_time_day();

  start_time_day(const start_time_day& from);

  inline start_time_day& operator=(const start_time_day& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_time_day& default_instance();

  void Swap(start_time_day* other);

  // implements Message ----------------------------------------------

  start_time_day* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_time_day& from);
  void MergeFrom(const start_time_day& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 h = 1;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 1;
  inline ::google::protobuf::uint32 h() const;
  inline void set_h(::google::protobuf::uint32 value);

  // required uint32 m = 2;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 2;
  inline ::google::protobuf::uint32 m() const;
  inline void set_m(::google::protobuf::uint32 value);

  // required uint32 s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline ::google::protobuf::uint32 s() const;
  inline void set_s(::google::protobuf::uint32 value);

  // required uint32 c = 4;
  inline bool has_c() const;
  inline void clear_c();
  static const int kCFieldNumber = 4;
  inline ::google::protobuf::uint32 c() const;
  inline void set_c(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.start_time_day)
 private:
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_c();
  inline void clear_has_c();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 h_;
  ::google::protobuf::uint32 m_;
  ::google::protobuf::uint32 s_;
  ::google::protobuf::uint32 c_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static start_time_day* default_instance_;
};
// -------------------------------------------------------------------

class start_time : public ::google::protobuf::Message {
 public:
  start_time();
  virtual ~start_time();

  start_time(const start_time& from);

  inline start_time& operator=(const start_time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_time& default_instance();

  void Swap(start_time* other);

  // implements Message ----------------------------------------------

  start_time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_time& from);
  void MergeFrom(const start_time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.start_time)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static start_time* default_instance_;
};
// -------------------------------------------------------------------

class get_item : public ::google::protobuf::Message {
 public:
  get_item();
  virtual ~get_item();

  get_item(const get_item& from);

  inline get_item& operator=(const get_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_item& default_instance();

  void Swap(get_item* other);

  // implements Message ----------------------------------------------

  get_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_item& from);
  void MergeFrom(const get_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.get_item)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static get_item* default_instance_;
};
// -------------------------------------------------------------------

class touch_scense_object : public ::google::protobuf::Message {
 public:
  touch_scense_object();
  virtual ~touch_scense_object();

  touch_scense_object(const touch_scense_object& from);

  inline touch_scense_object& operator=(const touch_scense_object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const touch_scense_object& default_instance();

  void Swap(touch_scense_object* other);

  // implements Message ----------------------------------------------

  touch_scense_object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const touch_scense_object& from);
  void MergeFrom(const touch_scense_object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 object = 1;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 1;
  inline ::google::protobuf::uint32 object() const;
  inline void set_object(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.touch_scense_object)
 private:
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 object_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static touch_scense_object* default_instance_;
};
// -------------------------------------------------------------------

class find_monster : public ::google::protobuf::Message {
 public:
  find_monster();
  virtual ~find_monster();

  find_monster(const find_monster& from);

  inline find_monster& operator=(const find_monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const find_monster& default_instance();

  void Swap(find_monster* other);

  // implements Message ----------------------------------------------

  find_monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const find_monster& from);
  void MergeFrom(const find_monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // optional uint32 distance = 2;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 2;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);

  // optional uint32 seconds = 3;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 3;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.find_monster)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 character_id_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::uint32 seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static find_monster* default_instance_;
};
// -------------------------------------------------------------------

class group_monster : public ::google::protobuf::Message {
 public:
  group_monster();
  virtual ~group_monster();

  group_monster(const group_monster& from);

  inline group_monster& operator=(const group_monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const group_monster& default_instance();

  void Swap(group_monster* other);

  // implements Message ----------------------------------------------

  group_monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const group_monster& from);
  void MergeFrom(const group_monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 monster_id = 1;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 monster_id() const;
  inline void set_monster_id(::google::protobuf::uint32 value);

  // required uint32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // optional uint32 seconds = 3;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 3;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.group_monster)
 private:
  inline void set_has_monster_id();
  inline void clear_has_monster_id();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 monster_id_;
  ::google::protobuf::uint32 number_;
  ::google::protobuf::uint32 seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static group_monster* default_instance_;
};
// -------------------------------------------------------------------

class appear_around : public ::google::protobuf::Message {
 public:
  appear_around();
  virtual ~appear_around();

  appear_around(const appear_around& from);

  inline appear_around& operator=(const appear_around& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const appear_around& default_instance();

  void Swap(appear_around* other);

  // implements Message ----------------------------------------------

  appear_around* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const appear_around& from);
  void MergeFrom(const appear_around& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 distance = 2;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 2;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);

  // required uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.appear_around)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static appear_around* default_instance_;
};
// -------------------------------------------------------------------

class create_msg : public ::google::protobuf::Message {
 public:
  create_msg();
  virtual ~create_msg();

  create_msg(const create_msg& from);

  inline create_msg& operator=(const create_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const create_msg& default_instance();

  void Swap(create_msg* other);

  // implements Message ----------------------------------------------

  create_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const create_msg& from);
  void MergeFrom(const create_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required uint32 delay = 2;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 2;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // required uint32 show = 3;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 3;
  inline ::google::protobuf::uint32 show() const;
  inline void set_show(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.create_msg)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_show();
  inline void clear_has_show();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::google::protobuf::uint32 delay_;
  ::google::protobuf::uint32 show_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static create_msg* default_instance_;
};
// -------------------------------------------------------------------

class suspend_create : public ::google::protobuf::Message {
 public:
  suspend_create();
  virtual ~suspend_create();

  suspend_create(const suspend_create& from);

  inline suspend_create& operator=(const suspend_create& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const suspend_create& default_instance();

  void Swap(suspend_create* other);

  // implements Message ----------------------------------------------

  suspend_create* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const suspend_create& from);
  void MergeFrom(const suspend_create& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.suspend_create)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static suspend_create* default_instance_;
};
// -------------------------------------------------------------------

class create_npc_rule : public ::google::protobuf::Message {
 public:
  create_npc_rule();
  virtual ~create_npc_rule();

  create_npc_rule(const create_npc_rule& from);

  inline create_npc_rule& operator=(const create_npc_rule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const create_npc_rule& default_instance();

  void Swap(create_npc_rule* other);

  // implements Message ----------------------------------------------

  create_npc_rule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const create_npc_rule& from);
  void MergeFrom(const create_npc_rule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.advance_appeare advance = 1;
  inline int advance_size() const;
  inline void clear_advance();
  static const int kAdvanceFieldNumber = 1;
  inline const ::server::advance_appeare& advance(int index) const;
  inline ::server::advance_appeare* mutable_advance(int index);
  inline ::server::advance_appeare* add_advance();
  inline const ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >&
      advance() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >*
      mutable_advance();

  // repeated .server.into_appeare into = 2;
  inline int into_size() const;
  inline void clear_into();
  static const int kIntoFieldNumber = 2;
  inline const ::server::into_appeare& into(int index) const;
  inline ::server::into_appeare* mutable_into(int index);
  inline ::server::into_appeare* add_into();
  inline const ::google::protobuf::RepeatedPtrField< ::server::into_appeare >&
      into() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::into_appeare >*
      mutable_into();

  // repeated .server.after_story story = 3;
  inline int story_size() const;
  inline void clear_story();
  static const int kStoryFieldNumber = 3;
  inline const ::server::after_story& story(int index) const;
  inline ::server::after_story* mutable_story(int index);
  inline ::server::after_story* add_story();
  inline const ::google::protobuf::RepeatedPtrField< ::server::after_story >&
      story() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::after_story >*
      mutable_story();

  // repeated .server.kill_monster kill = 4;
  inline int kill_size() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 4;
  inline const ::server::kill_monster& kill(int index) const;
  inline ::server::kill_monster* mutable_kill(int index);
  inline ::server::kill_monster* add_kill();
  inline const ::google::protobuf::RepeatedPtrField< ::server::kill_monster >&
      kill() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::kill_monster >*
      mutable_kill();

  // repeated .server.start_time_week week = 5;
  inline int week_size() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 5;
  inline const ::server::start_time_week& week(int index) const;
  inline ::server::start_time_week* mutable_week(int index);
  inline ::server::start_time_week* add_week();
  inline const ::google::protobuf::RepeatedPtrField< ::server::start_time_week >&
      week() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::start_time_week >*
      mutable_week();

  // repeated .server.touch_task task = 6;
  inline int task_size() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 6;
  inline const ::server::touch_task& task(int index) const;
  inline ::server::touch_task* mutable_task(int index);
  inline ::server::touch_task* add_task();
  inline const ::google::protobuf::RepeatedPtrField< ::server::touch_task >&
      task() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::touch_task >*
      mutable_task();

  // repeated .server.start_activity activity = 7;
  inline int activity_size() const;
  inline void clear_activity();
  static const int kActivityFieldNumber = 7;
  inline const ::server::start_activity& activity(int index) const;
  inline ::server::start_activity* mutable_activity(int index);
  inline ::server::start_activity* add_activity();
  inline const ::google::protobuf::RepeatedPtrField< ::server::start_activity >&
      activity() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::start_activity >*
      mutable_activity();

  // repeated .server.start_time time = 8;
  inline int time_size() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 8;
  inline const ::server::start_time& time(int index) const;
  inline ::server::start_time* mutable_time(int index);
  inline ::server::start_time* add_time();
  inline const ::google::protobuf::RepeatedPtrField< ::server::start_time >&
      time() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::start_time >*
      mutable_time();

  // repeated .server.get_item item = 9;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 9;
  inline const ::server::get_item& item(int index) const;
  inline ::server::get_item* mutable_item(int index);
  inline ::server::get_item* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::server::get_item >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::get_item >*
      mutable_item();

  // repeated .server.touch_scense_object object = 10;
  inline int object_size() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 10;
  inline const ::server::touch_scense_object& object(int index) const;
  inline ::server::touch_scense_object* mutable_object(int index);
  inline ::server::touch_scense_object* add_object();
  inline const ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >&
      object() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >*
      mutable_object();

  // repeated .server.find_monster find = 11;
  inline int find_size() const;
  inline void clear_find();
  static const int kFindFieldNumber = 11;
  inline const ::server::find_monster& find(int index) const;
  inline ::server::find_monster* mutable_find(int index);
  inline ::server::find_monster* add_find();
  inline const ::google::protobuf::RepeatedPtrField< ::server::find_monster >&
      find() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::find_monster >*
      mutable_find();

  // repeated .server.group_monster monster = 12;
  inline int monster_size() const;
  inline void clear_monster();
  static const int kMonsterFieldNumber = 12;
  inline const ::server::group_monster& monster(int index) const;
  inline ::server::group_monster* mutable_monster(int index);
  inline ::server::group_monster* add_monster();
  inline const ::google::protobuf::RepeatedPtrField< ::server::group_monster >&
      monster() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::group_monster >*
      mutable_monster();

  // repeated .server.appeare app = 13;
  inline int app_size() const;
  inline void clear_app();
  static const int kAppFieldNumber = 13;
  inline const ::server::appeare& app(int index) const;
  inline ::server::appeare* mutable_app(int index);
  inline ::server::appeare* add_app();
  inline const ::google::protobuf::RepeatedPtrField< ::server::appeare >&
      app() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::appeare >*
      mutable_app();

  // repeated .server.appear_around around = 14;
  inline int around_size() const;
  inline void clear_around();
  static const int kAroundFieldNumber = 14;
  inline const ::server::appear_around& around(int index) const;
  inline ::server::appear_around* mutable_around(int index);
  inline ::server::appear_around* add_around();
  inline const ::google::protobuf::RepeatedPtrField< ::server::appear_around >&
      around() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::appear_around >*
      mutable_around();

  // optional bool clear = 15;
  inline bool has_clear() const;
  inline void clear_clear();
  static const int kClearFieldNumber = 15;
  inline bool clear() const;
  inline void set_clear(bool value);

  // optional uint32 index = 16;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 16;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // repeated .server.create_msg msg = 17;
  inline int msg_size() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 17;
  inline const ::server::create_msg& msg(int index) const;
  inline ::server::create_msg* mutable_msg(int index);
  inline ::server::create_msg* add_msg();
  inline const ::google::protobuf::RepeatedPtrField< ::server::create_msg >&
      msg() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::create_msg >*
      mutable_msg();

  // repeated .server.suspend_create suspend = 18;
  inline int suspend_size() const;
  inline void clear_suspend();
  static const int kSuspendFieldNumber = 18;
  inline const ::server::suspend_create& suspend(int index) const;
  inline ::server::suspend_create* mutable_suspend(int index);
  inline ::server::suspend_create* add_suspend();
  inline const ::google::protobuf::RepeatedPtrField< ::server::suspend_create >&
      suspend() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::suspend_create >*
      mutable_suspend();

  // @@protoc_insertion_point(class_scope:server.create_npc_rule)
 private:
  inline void set_has_clear();
  inline void clear_has_clear();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::advance_appeare > advance_;
  ::google::protobuf::RepeatedPtrField< ::server::into_appeare > into_;
  ::google::protobuf::RepeatedPtrField< ::server::after_story > story_;
  ::google::protobuf::RepeatedPtrField< ::server::kill_monster > kill_;
  ::google::protobuf::RepeatedPtrField< ::server::start_time_week > week_;
  ::google::protobuf::RepeatedPtrField< ::server::touch_task > task_;
  ::google::protobuf::RepeatedPtrField< ::server::start_activity > activity_;
  ::google::protobuf::RepeatedPtrField< ::server::start_time > time_;
  ::google::protobuf::RepeatedPtrField< ::server::get_item > item_;
  ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object > object_;
  ::google::protobuf::RepeatedPtrField< ::server::find_monster > find_;
  ::google::protobuf::RepeatedPtrField< ::server::group_monster > monster_;
  ::google::protobuf::RepeatedPtrField< ::server::appeare > app_;
  ::google::protobuf::RepeatedPtrField< ::server::appear_around > around_;
  bool clear_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::RepeatedPtrField< ::server::create_msg > msg_;
  ::google::protobuf::RepeatedPtrField< ::server::suspend_create > suspend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static create_npc_rule* default_instance_;
};
// -------------------------------------------------------------------

class create_npc_rules : public ::google::protobuf::Message {
 public:
  create_npc_rules();
  virtual ~create_npc_rules();

  create_npc_rules(const create_npc_rules& from);

  inline create_npc_rules& operator=(const create_npc_rules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const create_npc_rules& default_instance();

  void Swap(create_npc_rules* other);

  // implements Message ----------------------------------------------

  create_npc_rules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const create_npc_rules& from);
  void MergeFrom(const create_npc_rules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.create_npc_rule rules = 1;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 1;
  inline const ::server::create_npc_rule& rules(int index) const;
  inline ::server::create_npc_rule* mutable_rules(int index);
  inline ::server::create_npc_rule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::server::create_npc_rule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::create_npc_rule >*
      mutable_rules();

  // @@protoc_insertion_point(class_scope:server.create_npc_rules)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::create_npc_rule > rules_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static create_npc_rules* default_instance_;
};
// -------------------------------------------------------------------

class appear_effect : public ::google::protobuf::Message {
 public:
  appear_effect();
  virtual ~appear_effect();

  appear_effect(const appear_effect& from);

  inline appear_effect& operator=(const appear_effect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const appear_effect& default_instance();

  void Swap(appear_effect* other);

  // implements Message ----------------------------------------------

  appear_effect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const appear_effect& from);
  void MergeFrom(const appear_effect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // required uint32 frequency = 4;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 4;
  inline ::google::protobuf::uint32 frequency() const;
  inline void set_frequency(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.appear_effect)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_frequency();
  inline void clear_has_frequency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 frequency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static appear_effect* default_instance_;
};
// -------------------------------------------------------------------

class create_effect_rule : public ::google::protobuf::Message {
 public:
  create_effect_rule();
  virtual ~create_effect_rule();

  create_effect_rule(const create_effect_rule& from);

  inline create_effect_rule& operator=(const create_effect_rule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const create_effect_rule& default_instance();

  void Swap(create_effect_rule* other);

  // implements Message ----------------------------------------------

  create_effect_rule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const create_effect_rule& from);
  void MergeFrom(const create_effect_rule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.advance_appeare advance = 1;
  inline int advance_size() const;
  inline void clear_advance();
  static const int kAdvanceFieldNumber = 1;
  inline const ::server::advance_appeare& advance(int index) const;
  inline ::server::advance_appeare* mutable_advance(int index);
  inline ::server::advance_appeare* add_advance();
  inline const ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >&
      advance() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >*
      mutable_advance();

  // repeated .server.into_appeare into = 2;
  inline int into_size() const;
  inline void clear_into();
  static const int kIntoFieldNumber = 2;
  inline const ::server::into_appeare& into(int index) const;
  inline ::server::into_appeare* mutable_into(int index);
  inline ::server::into_appeare* add_into();
  inline const ::google::protobuf::RepeatedPtrField< ::server::into_appeare >&
      into() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::into_appeare >*
      mutable_into();

  // repeated .server.after_story story = 3;
  inline int story_size() const;
  inline void clear_story();
  static const int kStoryFieldNumber = 3;
  inline const ::server::after_story& story(int index) const;
  inline ::server::after_story* mutable_story(int index);
  inline ::server::after_story* add_story();
  inline const ::google::protobuf::RepeatedPtrField< ::server::after_story >&
      story() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::after_story >*
      mutable_story();

  // repeated .server.kill_monster kill = 4;
  inline int kill_size() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 4;
  inline const ::server::kill_monster& kill(int index) const;
  inline ::server::kill_monster* mutable_kill(int index);
  inline ::server::kill_monster* add_kill();
  inline const ::google::protobuf::RepeatedPtrField< ::server::kill_monster >&
      kill() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::kill_monster >*
      mutable_kill();

  // repeated .server.start_time_week week = 5;
  inline int week_size() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 5;
  inline const ::server::start_time_week& week(int index) const;
  inline ::server::start_time_week* mutable_week(int index);
  inline ::server::start_time_week* add_week();
  inline const ::google::protobuf::RepeatedPtrField< ::server::start_time_week >&
      week() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::start_time_week >*
      mutable_week();

  // repeated .server.touch_task task = 6;
  inline int task_size() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 6;
  inline const ::server::touch_task& task(int index) const;
  inline ::server::touch_task* mutable_task(int index);
  inline ::server::touch_task* add_task();
  inline const ::google::protobuf::RepeatedPtrField< ::server::touch_task >&
      task() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::touch_task >*
      mutable_task();

  // repeated .server.start_activity activity = 7;
  inline int activity_size() const;
  inline void clear_activity();
  static const int kActivityFieldNumber = 7;
  inline const ::server::start_activity& activity(int index) const;
  inline ::server::start_activity* mutable_activity(int index);
  inline ::server::start_activity* add_activity();
  inline const ::google::protobuf::RepeatedPtrField< ::server::start_activity >&
      activity() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::start_activity >*
      mutable_activity();

  // repeated .server.start_time time = 8;
  inline int time_size() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 8;
  inline const ::server::start_time& time(int index) const;
  inline ::server::start_time* mutable_time(int index);
  inline ::server::start_time* add_time();
  inline const ::google::protobuf::RepeatedPtrField< ::server::start_time >&
      time() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::start_time >*
      mutable_time();

  // repeated .server.get_item item = 9;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 9;
  inline const ::server::get_item& item(int index) const;
  inline ::server::get_item* mutable_item(int index);
  inline ::server::get_item* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::server::get_item >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::get_item >*
      mutable_item();

  // repeated .server.touch_scense_object object = 10;
  inline int object_size() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 10;
  inline const ::server::touch_scense_object& object(int index) const;
  inline ::server::touch_scense_object* mutable_object(int index);
  inline ::server::touch_scense_object* add_object();
  inline const ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >&
      object() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >*
      mutable_object();

  // repeated .server.find_monster find = 11;
  inline int find_size() const;
  inline void clear_find();
  static const int kFindFieldNumber = 11;
  inline const ::server::find_monster& find(int index) const;
  inline ::server::find_monster* mutable_find(int index);
  inline ::server::find_monster* add_find();
  inline const ::google::protobuf::RepeatedPtrField< ::server::find_monster >&
      find() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::find_monster >*
      mutable_find();

  // repeated .server.group_monster monster = 12;
  inline int monster_size() const;
  inline void clear_monster();
  static const int kMonsterFieldNumber = 12;
  inline const ::server::group_monster& monster(int index) const;
  inline ::server::group_monster* mutable_monster(int index);
  inline ::server::group_monster* add_monster();
  inline const ::google::protobuf::RepeatedPtrField< ::server::group_monster >&
      monster() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::group_monster >*
      mutable_monster();

  // repeated .server.appear_effect app = 13;
  inline int app_size() const;
  inline void clear_app();
  static const int kAppFieldNumber = 13;
  inline const ::server::appear_effect& app(int index) const;
  inline ::server::appear_effect* mutable_app(int index);
  inline ::server::appear_effect* add_app();
  inline const ::google::protobuf::RepeatedPtrField< ::server::appear_effect >&
      app() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::appear_effect >*
      mutable_app();

  // @@protoc_insertion_point(class_scope:server.create_effect_rule)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::advance_appeare > advance_;
  ::google::protobuf::RepeatedPtrField< ::server::into_appeare > into_;
  ::google::protobuf::RepeatedPtrField< ::server::after_story > story_;
  ::google::protobuf::RepeatedPtrField< ::server::kill_monster > kill_;
  ::google::protobuf::RepeatedPtrField< ::server::start_time_week > week_;
  ::google::protobuf::RepeatedPtrField< ::server::touch_task > task_;
  ::google::protobuf::RepeatedPtrField< ::server::start_activity > activity_;
  ::google::protobuf::RepeatedPtrField< ::server::start_time > time_;
  ::google::protobuf::RepeatedPtrField< ::server::get_item > item_;
  ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object > object_;
  ::google::protobuf::RepeatedPtrField< ::server::find_monster > find_;
  ::google::protobuf::RepeatedPtrField< ::server::group_monster > monster_;
  ::google::protobuf::RepeatedPtrField< ::server::appear_effect > app_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static create_effect_rule* default_instance_;
};
// -------------------------------------------------------------------

class create_effect_rules : public ::google::protobuf::Message {
 public:
  create_effect_rules();
  virtual ~create_effect_rules();

  create_effect_rules(const create_effect_rules& from);

  inline create_effect_rules& operator=(const create_effect_rules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const create_effect_rules& default_instance();

  void Swap(create_effect_rules* other);

  // implements Message ----------------------------------------------

  create_effect_rules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const create_effect_rules& from);
  void MergeFrom(const create_effect_rules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.create_effect_rule rules = 1;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 1;
  inline const ::server::create_effect_rule& rules(int index) const;
  inline ::server::create_effect_rule* mutable_rules(int index);
  inline ::server::create_effect_rule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::server::create_effect_rule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::create_effect_rule >*
      mutable_rules();

  // @@protoc_insertion_point(class_scope:server.create_effect_rules)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::create_effect_rule > rules_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static create_effect_rules* default_instance_;
};
// -------------------------------------------------------------------

class dead_role : public ::google::protobuf::Message {
 public:
  dead_role();
  virtual ~dead_role();

  dead_role(const dead_role& from);

  inline dead_role& operator=(const dead_role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dead_role& default_instance();

  void Swap(dead_role* other);

  // implements Message ----------------------------------------------

  dead_role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dead_role& from);
  void MergeFrom(const dead_role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.dead_role)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static dead_role* default_instance_;
};
// -------------------------------------------------------------------

class survive_role : public ::google::protobuf::Message {
 public:
  survive_role();
  virtual ~survive_role();

  survive_role(const survive_role& from);

  inline survive_role& operator=(const survive_role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const survive_role& default_instance();

  void Swap(survive_role* other);

  // implements Message ----------------------------------------------

  survive_role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const survive_role& from);
  void MergeFrom(const survive_role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 tick = 2;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 2;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.survive_role)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static survive_role* default_instance_;
};
// -------------------------------------------------------------------

class scene_timeout : public ::google::protobuf::Message {
 public:
  scene_timeout();
  virtual ~scene_timeout();

  scene_timeout(const scene_timeout& from);

  inline scene_timeout& operator=(const scene_timeout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scene_timeout& default_instance();

  void Swap(scene_timeout* other);

  // implements Message ----------------------------------------------

  scene_timeout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scene_timeout& from);
  void MergeFrom(const scene_timeout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tenms = 1;
  inline bool has_tenms() const;
  inline void clear_tenms();
  static const int kTenmsFieldNumber = 1;
  inline ::google::protobuf::uint32 tenms() const;
  inline void set_tenms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.scene_timeout)
 private:
  inline void set_has_tenms();
  inline void clear_has_tenms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tenms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static scene_timeout* default_instance_;
};
// -------------------------------------------------------------------

class dead_count : public ::google::protobuf::Message {
 public:
  dead_count();
  virtual ~dead_count();

  dead_count(const dead_count& from);

  inline dead_count& operator=(const dead_count& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dead_count& default_instance();

  void Swap(dead_count* other);

  // implements Message ----------------------------------------------

  dead_count* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dead_count& from);
  void MergeFrom(const dead_count& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.dead_count)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static dead_count* default_instance_;
};
// -------------------------------------------------------------------

class role_attribute : public ::google::protobuf::Message {
 public:
  role_attribute();
  virtual ~role_attribute();

  role_attribute(const role_attribute& from);

  inline role_attribute& operator=(const role_attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_attribute& default_instance();

  void Swap(role_attribute* other);

  // implements Message ----------------------------------------------

  role_attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_attribute& from);
  void MergeFrom(const role_attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.role_attribute)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static role_attribute* default_instance_;
};
// -------------------------------------------------------------------

class role_postion : public ::google::protobuf::Message {
 public:
  role_postion();
  virtual ~role_postion();

  role_postion(const role_postion& from);

  inline role_postion& operator=(const role_postion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_postion& default_instance();

  void Swap(role_postion* other);

  // implements Message ----------------------------------------------

  role_postion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_postion& from);
  void MergeFrom(const role_postion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // required uint32 distance = 4;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 4;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);

  // required uint32 number = 5;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // required uint32 tick = 6;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 6;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:server.role_postion)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::uint32 number_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static role_postion* default_instance_;
};
// -------------------------------------------------------------------

class raid_success_rule : public ::google::protobuf::Message {
 public:
  raid_success_rule();
  virtual ~raid_success_rule();

  raid_success_rule(const raid_success_rule& from);

  inline raid_success_rule& operator=(const raid_success_rule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_success_rule& default_instance();

  void Swap(raid_success_rule* other);

  // implements Message ----------------------------------------------

  raid_success_rule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_success_rule& from);
  void MergeFrom(const raid_success_rule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.dead_role role = 1;
  inline int role_size() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline const ::server::dead_role& role(int index) const;
  inline ::server::dead_role* mutable_role(int index);
  inline ::server::dead_role* add_role();
  inline const ::google::protobuf::RepeatedPtrField< ::server::dead_role >&
      role() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::dead_role >*
      mutable_role();

  // repeated .server.get_item item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::server::get_item& item(int index) const;
  inline ::server::get_item* mutable_item(int index);
  inline ::server::get_item* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::server::get_item >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::get_item >*
      mutable_item();

  // repeated .server.dead_role touch = 3;
  inline int touch_size() const;
  inline void clear_touch();
  static const int kTouchFieldNumber = 3;
  inline const ::server::dead_role& touch(int index) const;
  inline ::server::dead_role* mutable_touch(int index);
  inline ::server::dead_role* add_touch();
  inline const ::google::protobuf::RepeatedPtrField< ::server::dead_role >&
      touch() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::dead_role >*
      mutable_touch();

  // repeated .server.ai_timer timer = 4;
  inline int timer_size() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 4;
  inline const ::server::ai_timer& timer(int index) const;
  inline ::server::ai_timer* mutable_timer(int index);
  inline ::server::ai_timer* add_timer();
  inline const ::google::protobuf::RepeatedPtrField< ::server::ai_timer >&
      timer() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::ai_timer >*
      mutable_timer();

  // repeated .server.role_postion pos = 5;
  inline int pos_size() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 5;
  inline const ::server::role_postion& pos(int index) const;
  inline ::server::role_postion* mutable_pos(int index);
  inline ::server::role_postion* add_pos();
  inline const ::google::protobuf::RepeatedPtrField< ::server::role_postion >&
      pos() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::role_postion >*
      mutable_pos();

  // repeated .server.role_postion block = 6;
  inline int block_size() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 6;
  inline const ::server::role_postion& block(int index) const;
  inline ::server::role_postion* mutable_block(int index);
  inline ::server::role_postion* add_block();
  inline const ::google::protobuf::RepeatedPtrField< ::server::role_postion >&
      block() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::role_postion >*
      mutable_block();

  // repeated .server.survive_role survive = 7;
  inline int survive_size() const;
  inline void clear_survive();
  static const int kSurviveFieldNumber = 7;
  inline const ::server::survive_role& survive(int index) const;
  inline ::server::survive_role* mutable_survive(int index);
  inline ::server::survive_role* add_survive();
  inline const ::google::protobuf::RepeatedPtrField< ::server::survive_role >&
      survive() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::survive_role >*
      mutable_survive();

  // @@protoc_insertion_point(class_scope:server.raid_success_rule)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::dead_role > role_;
  ::google::protobuf::RepeatedPtrField< ::server::get_item > item_;
  ::google::protobuf::RepeatedPtrField< ::server::dead_role > touch_;
  ::google::protobuf::RepeatedPtrField< ::server::ai_timer > timer_;
  ::google::protobuf::RepeatedPtrField< ::server::role_postion > pos_;
  ::google::protobuf::RepeatedPtrField< ::server::role_postion > block_;
  ::google::protobuf::RepeatedPtrField< ::server::survive_role > survive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static raid_success_rule* default_instance_;
};
// -------------------------------------------------------------------

class raid_failure_rule : public ::google::protobuf::Message {
 public:
  raid_failure_rule();
  virtual ~raid_failure_rule();

  raid_failure_rule(const raid_failure_rule& from);

  inline raid_failure_rule& operator=(const raid_failure_rule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_failure_rule& default_instance();

  void Swap(raid_failure_rule* other);

  // implements Message ----------------------------------------------

  raid_failure_rule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_failure_rule& from);
  void MergeFrom(const raid_failure_rule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.dead_count role = 1;
  inline int role_size() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline const ::server::dead_count& role(int index) const;
  inline ::server::dead_count* mutable_role(int index);
  inline ::server::dead_count* add_role();
  inline const ::google::protobuf::RepeatedPtrField< ::server::dead_count >&
      role() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::dead_count >*
      mutable_role();

  // repeated .server.scene_timeout timeout = 2;
  inline int timeout_size() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline const ::server::scene_timeout& timeout(int index) const;
  inline ::server::scene_timeout* mutable_timeout(int index);
  inline ::server::scene_timeout* add_timeout();
  inline const ::google::protobuf::RepeatedPtrField< ::server::scene_timeout >&
      timeout() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::scene_timeout >*
      mutable_timeout();

  // repeated .server.dead_count count = 3;
  inline int count_size() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline const ::server::dead_count& count(int index) const;
  inline ::server::dead_count* mutable_count(int index);
  inline ::server::dead_count* add_count();
  inline const ::google::protobuf::RepeatedPtrField< ::server::dead_count >&
      count() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::dead_count >*
      mutable_count();

  // repeated .server.role_attribute attr = 4;
  inline int attr_size() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 4;
  inline const ::server::role_attribute& attr(int index) const;
  inline ::server::role_attribute* mutable_attr(int index);
  inline ::server::role_attribute* add_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::server::role_attribute >&
      attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::role_attribute >*
      mutable_attr();

  // repeated .server.role_postion pos = 5;
  inline int pos_size() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 5;
  inline const ::server::role_postion& pos(int index) const;
  inline ::server::role_postion* mutable_pos(int index);
  inline ::server::role_postion* add_pos();
  inline const ::google::protobuf::RepeatedPtrField< ::server::role_postion >&
      pos() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::role_postion >*
      mutable_pos();

  // @@protoc_insertion_point(class_scope:server.raid_failure_rule)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::dead_count > role_;
  ::google::protobuf::RepeatedPtrField< ::server::scene_timeout > timeout_;
  ::google::protobuf::RepeatedPtrField< ::server::dead_count > count_;
  ::google::protobuf::RepeatedPtrField< ::server::role_attribute > attr_;
  ::google::protobuf::RepeatedPtrField< ::server::role_postion > pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static raid_failure_rule* default_instance_;
};
// -------------------------------------------------------------------

class raid_over_rules : public ::google::protobuf::Message {
 public:
  raid_over_rules();
  virtual ~raid_over_rules();

  raid_over_rules(const raid_over_rules& from);

  inline raid_over_rules& operator=(const raid_over_rules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_over_rules& default_instance();

  void Swap(raid_over_rules* other);

  // implements Message ----------------------------------------------

  raid_over_rules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_over_rules& from);
  void MergeFrom(const raid_over_rules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server.raid_success_rule success = 1;
  inline int success_size() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline const ::server::raid_success_rule& success(int index) const;
  inline ::server::raid_success_rule* mutable_success(int index);
  inline ::server::raid_success_rule* add_success();
  inline const ::google::protobuf::RepeatedPtrField< ::server::raid_success_rule >&
      success() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::raid_success_rule >*
      mutable_success();

  // repeated .server.raid_failure_rule failure = 2;
  inline int failure_size() const;
  inline void clear_failure();
  static const int kFailureFieldNumber = 2;
  inline const ::server::raid_failure_rule& failure(int index) const;
  inline ::server::raid_failure_rule* mutable_failure(int index);
  inline ::server::raid_failure_rule* add_failure();
  inline const ::google::protobuf::RepeatedPtrField< ::server::raid_failure_rule >&
      failure() const;
  inline ::google::protobuf::RepeatedPtrField< ::server::raid_failure_rule >*
      mutable_failure();

  // @@protoc_insertion_point(class_scope:server.raid_over_rules)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::server::raid_success_rule > success_;
  ::google::protobuf::RepeatedPtrField< ::server::raid_failure_rule > failure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_server_2eai_2eproto();
  friend void protobuf_AssignDesc_server_2eai_2eproto();
  friend void protobuf_ShutdownFile_server_2eai_2eproto();

  void InitAsDefaultInstance();
  static raid_over_rules* default_instance_;
};
// ===================================================================


// ===================================================================

// ai_method

// required uint32 rand = 1;
inline bool ai_method::has_rand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_method::set_has_rand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_method::clear_has_rand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_method::clear_rand() {
  rand_ = 0u;
  clear_has_rand();
}
inline ::google::protobuf::uint32 ai_method::rand() const {
  return rand_;
}
inline void ai_method::set_rand(::google::protobuf::uint32 value) {
  set_has_rand();
  rand_ = value;
}

// required uint32 skill_id = 2;
inline bool ai_method::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_method::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_method::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_method::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 ai_method::skill_id() const {
  return skill_id_;
}
inline void ai_method::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// required uint32 target = 3;
inline bool ai_method::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_method::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_method::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_method::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 ai_method::target() const {
  return target_;
}
inline void ai_method::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
}

// required uint32 count = 4;
inline bool ai_method::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ai_method::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ai_method::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ai_method::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ai_method::count() const {
  return count_;
}
inline void ai_method::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ai_move

// repeated uint32 x = 1;
inline int ai_move::x_size() const {
  return x_.size();
}
inline void ai_move::clear_x() {
  x_.Clear();
}
inline ::google::protobuf::uint32 ai_move::x(int index) const {
  return x_.Get(index);
}
inline void ai_move::set_x(int index, ::google::protobuf::uint32 value) {
  x_.Set(index, value);
}
inline void ai_move::add_x(::google::protobuf::uint32 value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ai_move::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ai_move::mutable_x() {
  return &x_;
}

// repeated uint32 y = 2;
inline int ai_move::y_size() const {
  return y_.size();
}
inline void ai_move::clear_y() {
  y_.Clear();
}
inline ::google::protobuf::uint32 ai_move::y(int index) const {
  return y_.Get(index);
}
inline void ai_move::set_y(int index, ::google::protobuf::uint32 value) {
  y_.Set(index, value);
}
inline void ai_move::add_y(::google::protobuf::uint32 value) {
  y_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ai_move::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ai_move::mutable_y() {
  return &y_;
}

// required uint32 rand = 3;
inline bool ai_move::has_rand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_move::set_has_rand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_move::clear_has_rand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_move::clear_rand() {
  rand_ = 0u;
  clear_has_rand();
}
inline ::google::protobuf::uint32 ai_move::rand() const {
  return rand_;
}
inline void ai_move::set_rand(::google::protobuf::uint32 value) {
  set_has_rand();
  rand_ = value;
}

// -------------------------------------------------------------------

// ai_fix_move

// repeated uint32 grid = 1;
inline int ai_fix_move::grid_size() const {
  return grid_.size();
}
inline void ai_fix_move::clear_grid() {
  grid_.Clear();
}
inline ::google::protobuf::uint32 ai_fix_move::grid(int index) const {
  return grid_.Get(index);
}
inline void ai_fix_move::set_grid(int index, ::google::protobuf::uint32 value) {
  grid_.Set(index, value);
}
inline void ai_fix_move::add_grid(::google::protobuf::uint32 value) {
  grid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ai_fix_move::grid() const {
  return grid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ai_fix_move::mutable_grid() {
  return &grid_;
}

// repeated uint32 atk = 2;
inline int ai_fix_move::atk_size() const {
  return atk_.size();
}
inline void ai_fix_move::clear_atk() {
  atk_.Clear();
}
inline ::google::protobuf::uint32 ai_fix_move::atk(int index) const {
  return atk_.Get(index);
}
inline void ai_fix_move::set_atk(int index, ::google::protobuf::uint32 value) {
  atk_.Set(index, value);
}
inline void ai_fix_move::add_atk(::google::protobuf::uint32 value) {
  atk_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ai_fix_move::atk() const {
  return atk_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ai_fix_move::mutable_atk() {
  return &atk_;
}

// repeated uint32 watch = 3;
inline int ai_fix_move::watch_size() const {
  return watch_.size();
}
inline void ai_fix_move::clear_watch() {
  watch_.Clear();
}
inline ::google::protobuf::uint32 ai_fix_move::watch(int index) const {
  return watch_.Get(index);
}
inline void ai_fix_move::set_watch(int index, ::google::protobuf::uint32 value) {
  watch_.Set(index, value);
}
inline void ai_fix_move::add_watch(::google::protobuf::uint32 value) {
  watch_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ai_fix_move::watch() const {
  return watch_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ai_fix_move::mutable_watch() {
  return &watch_;
}

// repeated uint32 block = 4;
inline int ai_fix_move::block_size() const {
  return block_.size();
}
inline void ai_fix_move::clear_block() {
  block_.Clear();
}
inline ::google::protobuf::uint32 ai_fix_move::block(int index) const {
  return block_.Get(index);
}
inline void ai_fix_move::set_block(int index, ::google::protobuf::uint32 value) {
  block_.Set(index, value);
}
inline void ai_fix_move::add_block(::google::protobuf::uint32 value) {
  block_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ai_fix_move::block() const {
  return block_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ai_fix_move::mutable_block() {
  return &block_;
}

// required uint32 rand = 5;
inline bool ai_fix_move::has_rand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ai_fix_move::set_has_rand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ai_fix_move::clear_has_rand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ai_fix_move::clear_rand() {
  rand_ = 0u;
  clear_has_rand();
}
inline ::google::protobuf::uint32 ai_fix_move::rand() const {
  return rand_;
}
inline void ai_fix_move::set_rand(::google::protobuf::uint32 value) {
  set_has_rand();
  rand_ = value;
}

// -------------------------------------------------------------------

// ai_timer

// optional uint32 timer = 1;
inline bool ai_timer::has_timer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_timer::set_has_timer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_timer::clear_has_timer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_timer::clear_timer() {
  timer_ = 0u;
  clear_has_timer();
}
inline ::google::protobuf::uint32 ai_timer::timer() const {
  return timer_;
}
inline void ai_timer::set_timer(::google::protobuf::uint32 value) {
  set_has_timer();
  timer_ = value;
}

// optional uint32 alarm = 2;
inline bool ai_timer::has_alarm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_timer::set_has_alarm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_timer::clear_has_alarm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_timer::clear_alarm() {
  alarm_ = 0u;
  clear_has_alarm();
}
inline ::google::protobuf::uint32 ai_timer::alarm() const {
  return alarm_;
}
inline void ai_timer::set_alarm(::google::protobuf::uint32 value) {
  set_has_alarm();
  alarm_ = value;
}

// -------------------------------------------------------------------

// ai_status

// required uint32 status = 1;
inline bool ai_status::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_status::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_status::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_status::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ai_status::status() const {
  return status_;
}
inline void ai_status::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 timer = 2;
inline bool ai_status::has_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_status::set_has_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_status::clear_has_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_status::clear_timer() {
  timer_ = 0u;
  clear_has_timer();
}
inline ::google::protobuf::uint32 ai_status::timer() const {
  return timer_;
}
inline void ai_status::set_timer(::google::protobuf::uint32 value) {
  set_has_timer();
  timer_ = value;
}

// optional uint32 each = 3;
inline bool ai_status::has_each() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_status::set_has_each() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_status::clear_has_each() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_status::clear_each() {
  each_ = 0u;
  clear_has_each();
}
inline ::google::protobuf::uint32 ai_status::each() const {
  return each_;
}
inline void ai_status::set_each(::google::protobuf::uint32 value) {
  set_has_each();
  each_ = value;
}

// -------------------------------------------------------------------

// ai_attr

// required uint32 attr = 1;
inline bool ai_attr::has_attr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_attr::set_has_attr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_attr::clear_has_attr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_attr::clear_attr() {
  attr_ = 0u;
  clear_has_attr();
}
inline ::google::protobuf::uint32 ai_attr::attr() const {
  return attr_;
}
inline void ai_attr::set_attr(::google::protobuf::uint32 value) {
  set_has_attr();
  attr_ = value;
}

// optional uint32 less = 2;
inline bool ai_attr::has_less() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_attr::set_has_less() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_attr::clear_has_less() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_attr::clear_less() {
  less_ = 0u;
  clear_has_less();
}
inline ::google::protobuf::uint32 ai_attr::less() const {
  return less_;
}
inline void ai_attr::set_less(::google::protobuf::uint32 value) {
  set_has_less();
  less_ = value;
}

// optional uint32 greater = 3;
inline bool ai_attr::has_greater() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_attr::set_has_greater() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_attr::clear_has_greater() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_attr::clear_greater() {
  greater_ = 0u;
  clear_has_greater();
}
inline ::google::protobuf::uint32 ai_attr::greater() const {
  return greater_;
}
inline void ai_attr::set_greater(::google::protobuf::uint32 value) {
  set_has_greater();
  greater_ = value;
}

// optional uint32 equal = 4;
inline bool ai_attr::has_equal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ai_attr::set_has_equal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ai_attr::clear_has_equal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ai_attr::clear_equal() {
  equal_ = 0u;
  clear_has_equal();
}
inline ::google::protobuf::uint32 ai_attr::equal() const {
  return equal_;
}
inline void ai_attr::set_equal(::google::protobuf::uint32 value) {
  set_has_equal();
  equal_ = value;
}

// -------------------------------------------------------------------

// ai_distance

// required uint32 distance = 1;
inline bool ai_distance::has_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_distance::set_has_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_distance::clear_has_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_distance::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 ai_distance::distance() const {
  return distance_;
}
inline void ai_distance::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
}

// required uint32 limit = 2;
inline bool ai_distance::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_distance::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_distance::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_distance::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 ai_distance::limit() const {
  return limit_;
}
inline void ai_distance::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
}

// optional uint32 less = 3;
inline bool ai_distance::has_less() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_distance::set_has_less() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_distance::clear_has_less() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_distance::clear_less() {
  less_ = 0u;
  clear_has_less();
}
inline ::google::protobuf::uint32 ai_distance::less() const {
  return less_;
}
inline void ai_distance::set_less(::google::protobuf::uint32 value) {
  set_has_less();
  less_ = value;
}

// optional uint32 greater = 4;
inline bool ai_distance::has_greater() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ai_distance::set_has_greater() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ai_distance::clear_has_greater() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ai_distance::clear_greater() {
  greater_ = 0u;
  clear_has_greater();
}
inline ::google::protobuf::uint32 ai_distance::greater() const {
  return greater_;
}
inline void ai_distance::set_greater(::google::protobuf::uint32 value) {
  set_has_greater();
  greater_ = value;
}

// optional uint32 equal = 5;
inline bool ai_distance::has_equal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ai_distance::set_has_equal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ai_distance::clear_has_equal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ai_distance::clear_equal() {
  equal_ = 0u;
  clear_has_equal();
}
inline ::google::protobuf::uint32 ai_distance::equal() const {
  return equal_;
}
inline void ai_distance::set_equal(::google::protobuf::uint32 value) {
  set_has_equal();
  equal_ = value;
}

// -------------------------------------------------------------------

// ai_attack

// required uint32 attack = 1;
inline bool ai_attack::has_attack() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_attack::set_has_attack() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_attack::clear_has_attack() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_attack::clear_attack() {
  attack_ = 0u;
  clear_has_attack();
}
inline ::google::protobuf::uint32 ai_attack::attack() const {
  return attack_;
}
inline void ai_attack::set_attack(::google::protobuf::uint32 value) {
  set_has_attack();
  attack_ = value;
}

// -------------------------------------------------------------------

// ai_defense

// required uint32 defense = 1;
inline bool ai_defense::has_defense() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_defense::set_has_defense() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_defense::clear_has_defense() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_defense::clear_defense() {
  defense_ = 0u;
  clear_has_defense();
}
inline ::google::protobuf::uint32 ai_defense::defense() const {
  return defense_;
}
inline void ai_defense::set_defense(::google::protobuf::uint32 value) {
  set_has_defense();
  defense_ = value;
}

// -------------------------------------------------------------------

// ai_dead

// required bool dead = 1;
inline bool ai_dead::has_dead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_dead::set_has_dead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_dead::clear_has_dead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_dead::clear_dead() {
  dead_ = false;
  clear_has_dead();
}
inline bool ai_dead::dead() const {
  return dead_;
}
inline void ai_dead::set_dead(bool value) {
  set_has_dead();
  dead_ = value;
}

// -------------------------------------------------------------------

// ai_hide

// required uint32 time = 1;
inline bool ai_hide::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_hide::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_hide::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_hide::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 ai_hide::time() const {
  return time_;
}
inline void ai_hide::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 rand = 2;
inline bool ai_hide::has_rand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_hide::set_has_rand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_hide::clear_has_rand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_hide::clear_rand() {
  rand_ = 0u;
  clear_has_rand();
}
inline ::google::protobuf::uint32 ai_hide::rand() const {
  return rand_;
}
inline void ai_hide::set_rand(::google::protobuf::uint32 value) {
  set_has_rand();
  rand_ = value;
}

// required uint32 pet = 3;
inline bool ai_hide::has_pet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_hide::set_has_pet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_hide::clear_has_pet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_hide::clear_pet() {
  pet_ = 0u;
  clear_has_pet();
}
inline ::google::protobuf::uint32 ai_hide::pet() const {
  return pet_;
}
inline void ai_hide::set_pet(::google::protobuf::uint32 value) {
  set_has_pet();
  pet_ = value;
}

// -------------------------------------------------------------------

// ai_stop

// required uint32 time = 1;
inline bool ai_stop::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_stop::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_stop::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_stop::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 ai_stop::time() const {
  return time_;
}
inline void ai_stop::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 rand = 2;
inline bool ai_stop::has_rand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_stop::set_has_rand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_stop::clear_has_rand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_stop::clear_rand() {
  rand_ = 0u;
  clear_has_rand();
}
inline ::google::protobuf::uint32 ai_stop::rand() const {
  return rand_;
}
inline void ai_stop::set_rand(::google::protobuf::uint32 value) {
  set_has_rand();
  rand_ = value;
}

// -------------------------------------------------------------------

// ai_master

// required uint32 type = 1;
inline bool ai_master::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_master::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_master::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_master::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ai_master::type() const {
  return type_;
}
inline void ai_master::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 time = 2;
inline bool ai_master::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_master::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_master::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_master::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 ai_master::time() const {
  return time_;
}
inline void ai_master::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 rand = 3;
inline bool ai_master::has_rand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_master::set_has_rand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_master::clear_has_rand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_master::clear_rand() {
  rand_ = 0u;
  clear_has_rand();
}
inline ::google::protobuf::uint32 ai_master::rand() const {
  return rand_;
}
inline void ai_master::set_rand(::google::protobuf::uint32 value) {
  set_has_rand();
  rand_ = value;
}

// -------------------------------------------------------------------

// ai_msg

// required string text = 1;
inline bool ai_msg::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_msg::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_msg::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_msg::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ai_msg::text() const {
  return *text_;
}
inline void ai_msg::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ai_msg::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ai_msg::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ai_msg::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ai_msg::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ai_msg::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 show = 2;
inline bool ai_msg::has_show() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_msg::set_has_show() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_msg::clear_has_show() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_msg::clear_show() {
  show_ = 0u;
  clear_has_show();
}
inline ::google::protobuf::uint32 ai_msg::show() const {
  return show_;
}
inline void ai_msg::set_show(::google::protobuf::uint32 value) {
  set_has_show();
  show_ = value;
}

// required uint32 delay = 3;
inline bool ai_msg::has_delay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_msg::set_has_delay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_msg::clear_has_delay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_msg::clear_delay() {
  delay_ = 0u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 ai_msg::delay() const {
  return delay_;
}
inline void ai_msg::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
}

// optional bool send = 4;
inline bool ai_msg::has_send() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ai_msg::set_has_send() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ai_msg::clear_has_send() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ai_msg::clear_send() {
  send_ = false;
  clear_has_send();
}
inline bool ai_msg::send() const {
  return send_;
}
inline void ai_msg::set_send(bool value) {
  set_has_send();
  send_ = value;
}

// -------------------------------------------------------------------

// ai_data

// repeated .server.ai_timer timer = 1;
inline int ai_data::timer_size() const {
  return timer_.size();
}
inline void ai_data::clear_timer() {
  timer_.Clear();
}
inline const ::server::ai_timer& ai_data::timer(int index) const {
  return timer_.Get(index);
}
inline ::server::ai_timer* ai_data::mutable_timer(int index) {
  return timer_.Mutable(index);
}
inline ::server::ai_timer* ai_data::add_timer() {
  return timer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_timer >&
ai_data::timer() const {
  return timer_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_timer >*
ai_data::mutable_timer() {
  return &timer_;
}

// repeated .server.ai_status status = 2;
inline int ai_data::status_size() const {
  return status_.size();
}
inline void ai_data::clear_status() {
  status_.Clear();
}
inline const ::server::ai_status& ai_data::status(int index) const {
  return status_.Get(index);
}
inline ::server::ai_status* ai_data::mutable_status(int index) {
  return status_.Mutable(index);
}
inline ::server::ai_status* ai_data::add_status() {
  return status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_status >&
ai_data::status() const {
  return status_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_status >*
ai_data::mutable_status() {
  return &status_;
}

// repeated .server.ai_attr attr = 3;
inline int ai_data::attr_size() const {
  return attr_.size();
}
inline void ai_data::clear_attr() {
  attr_.Clear();
}
inline const ::server::ai_attr& ai_data::attr(int index) const {
  return attr_.Get(index);
}
inline ::server::ai_attr* ai_data::mutable_attr(int index) {
  return attr_.Mutable(index);
}
inline ::server::ai_attr* ai_data::add_attr() {
  return attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_attr >&
ai_data::attr() const {
  return attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_attr >*
ai_data::mutable_attr() {
  return &attr_;
}

// repeated .server.ai_distance distance = 4;
inline int ai_data::distance_size() const {
  return distance_.size();
}
inline void ai_data::clear_distance() {
  distance_.Clear();
}
inline const ::server::ai_distance& ai_data::distance(int index) const {
  return distance_.Get(index);
}
inline ::server::ai_distance* ai_data::mutable_distance(int index) {
  return distance_.Mutable(index);
}
inline ::server::ai_distance* ai_data::add_distance() {
  return distance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_distance >&
ai_data::distance() const {
  return distance_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_distance >*
ai_data::mutable_distance() {
  return &distance_;
}

// repeated .server.ai_attack attack = 5;
inline int ai_data::attack_size() const {
  return attack_.size();
}
inline void ai_data::clear_attack() {
  attack_.Clear();
}
inline const ::server::ai_attack& ai_data::attack(int index) const {
  return attack_.Get(index);
}
inline ::server::ai_attack* ai_data::mutable_attack(int index) {
  return attack_.Mutable(index);
}
inline ::server::ai_attack* ai_data::add_attack() {
  return attack_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_attack >&
ai_data::attack() const {
  return attack_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_attack >*
ai_data::mutable_attack() {
  return &attack_;
}

// repeated .server.ai_defense defense = 6;
inline int ai_data::defense_size() const {
  return defense_.size();
}
inline void ai_data::clear_defense() {
  defense_.Clear();
}
inline const ::server::ai_defense& ai_data::defense(int index) const {
  return defense_.Get(index);
}
inline ::server::ai_defense* ai_data::mutable_defense(int index) {
  return defense_.Mutable(index);
}
inline ::server::ai_defense* ai_data::add_defense() {
  return defense_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_defense >&
ai_data::defense() const {
  return defense_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_defense >*
ai_data::mutable_defense() {
  return &defense_;
}

// optional .server.ai_dead dead = 7;
inline bool ai_data::has_dead() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ai_data::set_has_dead() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ai_data::clear_has_dead() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ai_data::clear_dead() {
  if (dead_ != NULL) dead_->::server::ai_dead::Clear();
  clear_has_dead();
}
inline const ::server::ai_dead& ai_data::dead() const {
  return dead_ != NULL ? *dead_ : *default_instance_->dead_;
}
inline ::server::ai_dead* ai_data::mutable_dead() {
  set_has_dead();
  if (dead_ == NULL) dead_ = new ::server::ai_dead;
  return dead_;
}
inline ::server::ai_dead* ai_data::release_dead() {
  clear_has_dead();
  ::server::ai_dead* temp = dead_;
  dead_ = NULL;
  return temp;
}
inline void ai_data::set_allocated_dead(::server::ai_dead* dead) {
  delete dead_;
  dead_ = dead;
  if (dead) {
    set_has_dead();
  } else {
    clear_has_dead();
  }
}

// repeated .server.ai_method method = 8;
inline int ai_data::method_size() const {
  return method_.size();
}
inline void ai_data::clear_method() {
  method_.Clear();
}
inline const ::server::ai_method& ai_data::method(int index) const {
  return method_.Get(index);
}
inline ::server::ai_method* ai_data::mutable_method(int index) {
  return method_.Mutable(index);
}
inline ::server::ai_method* ai_data::add_method() {
  return method_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_method >&
ai_data::method() const {
  return method_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_method >*
ai_data::mutable_method() {
  return &method_;
}

// repeated .server.ai_move move = 9;
inline int ai_data::move_size() const {
  return move_.size();
}
inline void ai_data::clear_move() {
  move_.Clear();
}
inline const ::server::ai_move& ai_data::move(int index) const {
  return move_.Get(index);
}
inline ::server::ai_move* ai_data::mutable_move(int index) {
  return move_.Mutable(index);
}
inline ::server::ai_move* ai_data::add_move() {
  return move_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_move >&
ai_data::move() const {
  return move_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_move >*
ai_data::mutable_move() {
  return &move_;
}

// repeated .server.ai_fix_move fix_move = 10;
inline int ai_data::fix_move_size() const {
  return fix_move_.size();
}
inline void ai_data::clear_fix_move() {
  fix_move_.Clear();
}
inline const ::server::ai_fix_move& ai_data::fix_move(int index) const {
  return fix_move_.Get(index);
}
inline ::server::ai_fix_move* ai_data::mutable_fix_move(int index) {
  return fix_move_.Mutable(index);
}
inline ::server::ai_fix_move* ai_data::add_fix_move() {
  return fix_move_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_fix_move >&
ai_data::fix_move() const {
  return fix_move_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_fix_move >*
ai_data::mutable_fix_move() {
  return &fix_move_;
}

// repeated .server.ai_move force_move = 11;
inline int ai_data::force_move_size() const {
  return force_move_.size();
}
inline void ai_data::clear_force_move() {
  force_move_.Clear();
}
inline const ::server::ai_move& ai_data::force_move(int index) const {
  return force_move_.Get(index);
}
inline ::server::ai_move* ai_data::mutable_force_move(int index) {
  return force_move_.Mutable(index);
}
inline ::server::ai_move* ai_data::add_force_move() {
  return force_move_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_move >&
ai_data::force_move() const {
  return force_move_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_move >*
ai_data::mutable_force_move() {
  return &force_move_;
}

// repeated .server.ai_attack target = 12;
inline int ai_data::target_size() const {
  return target_.size();
}
inline void ai_data::clear_target() {
  target_.Clear();
}
inline const ::server::ai_attack& ai_data::target(int index) const {
  return target_.Get(index);
}
inline ::server::ai_attack* ai_data::mutable_target(int index) {
  return target_.Mutable(index);
}
inline ::server::ai_attack* ai_data::add_target() {
  return target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_attack >&
ai_data::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_attack >*
ai_data::mutable_target() {
  return &target_;
}

// optional .server.ai_msg msg = 13;
inline bool ai_data::has_msg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ai_data::set_has_msg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ai_data::clear_has_msg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ai_data::clear_msg() {
  if (msg_ != NULL) msg_->::server::ai_msg::Clear();
  clear_has_msg();
}
inline const ::server::ai_msg& ai_data::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::server::ai_msg* ai_data::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::server::ai_msg;
  return msg_;
}
inline ::server::ai_msg* ai_data::release_msg() {
  clear_has_msg();
  ::server::ai_msg* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void ai_data::set_allocated_msg(::server::ai_msg* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// optional .server.ai_stop stop = 14;
inline bool ai_data::has_stop() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ai_data::set_has_stop() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ai_data::clear_has_stop() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ai_data::clear_stop() {
  if (stop_ != NULL) stop_->::server::ai_stop::Clear();
  clear_has_stop();
}
inline const ::server::ai_stop& ai_data::stop() const {
  return stop_ != NULL ? *stop_ : *default_instance_->stop_;
}
inline ::server::ai_stop* ai_data::mutable_stop() {
  set_has_stop();
  if (stop_ == NULL) stop_ = new ::server::ai_stop;
  return stop_;
}
inline ::server::ai_stop* ai_data::release_stop() {
  clear_has_stop();
  ::server::ai_stop* temp = stop_;
  stop_ = NULL;
  return temp;
}
inline void ai_data::set_allocated_stop(::server::ai_stop* stop) {
  delete stop_;
  stop_ = stop;
  if (stop) {
    set_has_stop();
  } else {
    clear_has_stop();
  }
}

// optional .server.ai_hide hide = 15;
inline bool ai_data::has_hide() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ai_data::set_has_hide() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ai_data::clear_has_hide() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ai_data::clear_hide() {
  if (hide_ != NULL) hide_->::server::ai_hide::Clear();
  clear_has_hide();
}
inline const ::server::ai_hide& ai_data::hide() const {
  return hide_ != NULL ? *hide_ : *default_instance_->hide_;
}
inline ::server::ai_hide* ai_data::mutable_hide() {
  set_has_hide();
  if (hide_ == NULL) hide_ = new ::server::ai_hide;
  return hide_;
}
inline ::server::ai_hide* ai_data::release_hide() {
  clear_has_hide();
  ::server::ai_hide* temp = hide_;
  hide_ = NULL;
  return temp;
}
inline void ai_data::set_allocated_hide(::server::ai_hide* hide) {
  delete hide_;
  hide_ = hide;
  if (hide) {
    set_has_hide();
  } else {
    clear_has_hide();
  }
}

// optional .server.ai_master master = 16;
inline bool ai_data::has_master() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ai_data::set_has_master() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ai_data::clear_has_master() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ai_data::clear_master() {
  if (master_ != NULL) master_->::server::ai_master::Clear();
  clear_has_master();
}
inline const ::server::ai_master& ai_data::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::server::ai_master* ai_data::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::server::ai_master;
  return master_;
}
inline ::server::ai_master* ai_data::release_master() {
  clear_has_master();
  ::server::ai_master* temp = master_;
  master_ = NULL;
  return temp;
}
inline void ai_data::set_allocated_master(::server::ai_master* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// -------------------------------------------------------------------

// ai_info

// repeated .server.ai_data ai = 1;
inline int ai_info::ai_size() const {
  return ai_.size();
}
inline void ai_info::clear_ai() {
  ai_.Clear();
}
inline const ::server::ai_data& ai_info::ai(int index) const {
  return ai_.Get(index);
}
inline ::server::ai_data* ai_info::mutable_ai(int index) {
  return ai_.Mutable(index);
}
inline ::server::ai_data* ai_info::add_ai() {
  return ai_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_data >&
ai_info::ai() const {
  return ai_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_data >*
ai_info::mutable_ai() {
  return &ai_;
}

// -------------------------------------------------------------------

// ai_run

// optional .server.ai_method method = 1;
inline bool ai_run::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ai_run::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ai_run::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ai_run::clear_method() {
  if (method_ != NULL) method_->::server::ai_method::Clear();
  clear_has_method();
}
inline const ::server::ai_method& ai_run::method() const {
  return method_ != NULL ? *method_ : *default_instance_->method_;
}
inline ::server::ai_method* ai_run::mutable_method() {
  set_has_method();
  if (method_ == NULL) method_ = new ::server::ai_method;
  return method_;
}
inline ::server::ai_method* ai_run::release_method() {
  clear_has_method();
  ::server::ai_method* temp = method_;
  method_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_method(::server::ai_method* method) {
  delete method_;
  method_ = method;
  if (method) {
    set_has_method();
  } else {
    clear_has_method();
  }
}

// optional .server.ai_move move = 2;
inline bool ai_run::has_move() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ai_run::set_has_move() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ai_run::clear_has_move() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ai_run::clear_move() {
  if (move_ != NULL) move_->::server::ai_move::Clear();
  clear_has_move();
}
inline const ::server::ai_move& ai_run::move() const {
  return move_ != NULL ? *move_ : *default_instance_->move_;
}
inline ::server::ai_move* ai_run::mutable_move() {
  set_has_move();
  if (move_ == NULL) move_ = new ::server::ai_move;
  return move_;
}
inline ::server::ai_move* ai_run::release_move() {
  clear_has_move();
  ::server::ai_move* temp = move_;
  move_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_move(::server::ai_move* move) {
  delete move_;
  move_ = move;
  if (move) {
    set_has_move();
  } else {
    clear_has_move();
  }
}

// optional .server.ai_fix_move fix_move = 3;
inline bool ai_run::has_fix_move() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ai_run::set_has_fix_move() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ai_run::clear_has_fix_move() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ai_run::clear_fix_move() {
  if (fix_move_ != NULL) fix_move_->::server::ai_fix_move::Clear();
  clear_has_fix_move();
}
inline const ::server::ai_fix_move& ai_run::fix_move() const {
  return fix_move_ != NULL ? *fix_move_ : *default_instance_->fix_move_;
}
inline ::server::ai_fix_move* ai_run::mutable_fix_move() {
  set_has_fix_move();
  if (fix_move_ == NULL) fix_move_ = new ::server::ai_fix_move;
  return fix_move_;
}
inline ::server::ai_fix_move* ai_run::release_fix_move() {
  clear_has_fix_move();
  ::server::ai_fix_move* temp = fix_move_;
  fix_move_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_fix_move(::server::ai_fix_move* fix_move) {
  delete fix_move_;
  fix_move_ = fix_move;
  if (fix_move) {
    set_has_fix_move();
  } else {
    clear_has_fix_move();
  }
}

// optional .server.ai_attack target = 4;
inline bool ai_run::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ai_run::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ai_run::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ai_run::clear_target() {
  if (target_ != NULL) target_->::server::ai_attack::Clear();
  clear_has_target();
}
inline const ::server::ai_attack& ai_run::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::server::ai_attack* ai_run::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::server::ai_attack;
  return target_;
}
inline ::server::ai_attack* ai_run::release_target() {
  clear_has_target();
  ::server::ai_attack* temp = target_;
  target_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_target(::server::ai_attack* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// optional .server.ai_msg msg = 5;
inline bool ai_run::has_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ai_run::set_has_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ai_run::clear_has_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ai_run::clear_msg() {
  if (msg_ != NULL) msg_->::server::ai_msg::Clear();
  clear_has_msg();
}
inline const ::server::ai_msg& ai_run::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::server::ai_msg* ai_run::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::server::ai_msg;
  return msg_;
}
inline ::server::ai_msg* ai_run::release_msg() {
  clear_has_msg();
  ::server::ai_msg* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_msg(::server::ai_msg* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// optional .server.ai_stop stop = 6;
inline bool ai_run::has_stop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ai_run::set_has_stop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ai_run::clear_has_stop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ai_run::clear_stop() {
  if (stop_ != NULL) stop_->::server::ai_stop::Clear();
  clear_has_stop();
}
inline const ::server::ai_stop& ai_run::stop() const {
  return stop_ != NULL ? *stop_ : *default_instance_->stop_;
}
inline ::server::ai_stop* ai_run::mutable_stop() {
  set_has_stop();
  if (stop_ == NULL) stop_ = new ::server::ai_stop;
  return stop_;
}
inline ::server::ai_stop* ai_run::release_stop() {
  clear_has_stop();
  ::server::ai_stop* temp = stop_;
  stop_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_stop(::server::ai_stop* stop) {
  delete stop_;
  stop_ = stop;
  if (stop) {
    set_has_stop();
  } else {
    clear_has_stop();
  }
}

// optional .server.ai_hide hide = 7;
inline bool ai_run::has_hide() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ai_run::set_has_hide() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ai_run::clear_has_hide() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ai_run::clear_hide() {
  if (hide_ != NULL) hide_->::server::ai_hide::Clear();
  clear_has_hide();
}
inline const ::server::ai_hide& ai_run::hide() const {
  return hide_ != NULL ? *hide_ : *default_instance_->hide_;
}
inline ::server::ai_hide* ai_run::mutable_hide() {
  set_has_hide();
  if (hide_ == NULL) hide_ = new ::server::ai_hide;
  return hide_;
}
inline ::server::ai_hide* ai_run::release_hide() {
  clear_has_hide();
  ::server::ai_hide* temp = hide_;
  hide_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_hide(::server::ai_hide* hide) {
  delete hide_;
  hide_ = hide;
  if (hide) {
    set_has_hide();
  } else {
    clear_has_hide();
  }
}

// optional .server.ai_master master = 8;
inline bool ai_run::has_master() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ai_run::set_has_master() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ai_run::clear_has_master() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ai_run::clear_master() {
  if (master_ != NULL) master_->::server::ai_master::Clear();
  clear_has_master();
}
inline const ::server::ai_master& ai_run::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::server::ai_master* ai_run::mutable_master() {
  set_has_master();
  if (master_ == NULL) master_ = new ::server::ai_master;
  return master_;
}
inline ::server::ai_master* ai_run::release_master() {
  clear_has_master();
  ::server::ai_master* temp = master_;
  master_ = NULL;
  return temp;
}
inline void ai_run::set_allocated_master(::server::ai_master* master) {
  delete master_;
  master_ = master;
  if (master) {
    set_has_master();
  } else {
    clear_has_master();
  }
}

// -------------------------------------------------------------------

// appeare

// repeated int32 x = 1;
inline int appeare::x_size() const {
  return x_.size();
}
inline void appeare::clear_x() {
  x_.Clear();
}
inline ::google::protobuf::int32 appeare::x(int index) const {
  return x_.Get(index);
}
inline void appeare::set_x(int index, ::google::protobuf::int32 value) {
  x_.Set(index, value);
}
inline void appeare::add_x(::google::protobuf::int32 value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
appeare::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
appeare::mutable_x() {
  return &x_;
}

// repeated int32 y = 2;
inline int appeare::y_size() const {
  return y_.size();
}
inline void appeare::clear_y() {
  y_.Clear();
}
inline ::google::protobuf::int32 appeare::y(int index) const {
  return y_.Get(index);
}
inline void appeare::set_y(int index, ::google::protobuf::int32 value) {
  y_.Set(index, value);
}
inline void appeare::add_y(::google::protobuf::int32 value) {
  y_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
appeare::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
appeare::mutable_y() {
  return &y_;
}

// repeated int32 roll = 3;
inline int appeare::roll_size() const {
  return roll_.size();
}
inline void appeare::clear_roll() {
  roll_.Clear();
}
inline ::google::protobuf::int32 appeare::roll(int index) const {
  return roll_.Get(index);
}
inline void appeare::set_roll(int index, ::google::protobuf::int32 value) {
  roll_.Set(index, value);
}
inline void appeare::add_roll(::google::protobuf::int32 value) {
  roll_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
appeare::roll() const {
  return roll_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
appeare::mutable_roll() {
  return &roll_;
}

// repeated uint32 effect = 4;
inline int appeare::effect_size() const {
  return effect_.size();
}
inline void appeare::clear_effect() {
  effect_.Clear();
}
inline ::google::protobuf::uint32 appeare::effect(int index) const {
  return effect_.Get(index);
}
inline void appeare::set_effect(int index, ::google::protobuf::uint32 value) {
  effect_.Set(index, value);
}
inline void appeare::add_effect(::google::protobuf::uint32 value) {
  effect_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
appeare::effect() const {
  return effect_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
appeare::mutable_effect() {
  return &effect_;
}

// required .server.appeare.type t = 5;
inline bool appeare::has_t() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void appeare::set_has_t() {
  _has_bits_[0] |= 0x00000010u;
}
inline void appeare::clear_has_t() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void appeare::clear_t() {
  t_ = 1;
  clear_has_t();
}
inline ::server::appeare_type appeare::t() const {
  return static_cast< ::server::appeare_type >(t_);
}
inline void appeare::set_t(::server::appeare_type value) {
  assert(::server::appeare_type_IsValid(value));
  set_has_t();
  t_ = value;
}

// -------------------------------------------------------------------

// advance_appeare

// required int32 x = 1;
inline bool advance_appeare::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void advance_appeare::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void advance_appeare::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void advance_appeare::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 advance_appeare::x() const {
  return x_;
}
inline void advance_appeare::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool advance_appeare::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void advance_appeare::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void advance_appeare::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void advance_appeare::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 advance_appeare::y() const {
  return y_;
}
inline void advance_appeare::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// into_appeare

// required int32 x = 1;
inline bool into_appeare::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void into_appeare::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void into_appeare::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void into_appeare::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 into_appeare::x() const {
  return x_;
}
inline void into_appeare::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool into_appeare::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void into_appeare::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void into_appeare::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void into_appeare::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 into_appeare::y() const {
  return y_;
}
inline void into_appeare::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 distance = 3;
inline bool into_appeare::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void into_appeare::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void into_appeare::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void into_appeare::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline ::google::protobuf::int32 into_appeare::distance() const {
  return distance_;
}
inline void into_appeare::set_distance(::google::protobuf::int32 value) {
  set_has_distance();
  distance_ = value;
}

// optional uint32 seconds = 4;
inline bool into_appeare::has_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void into_appeare::set_has_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void into_appeare::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void into_appeare::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 into_appeare::seconds() const {
  return seconds_;
}
inline void into_appeare::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// optional uint32 role = 5;
inline bool into_appeare::has_role() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void into_appeare::set_has_role() {
  _has_bits_[0] |= 0x00000010u;
}
inline void into_appeare::clear_has_role() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void into_appeare::clear_role() {
  role_ = 0u;
  clear_has_role();
}
inline ::google::protobuf::uint32 into_appeare::role() const {
  return role_;
}
inline void into_appeare::set_role(::google::protobuf::uint32 value) {
  set_has_role();
  role_ = value;
}

// -------------------------------------------------------------------

// after_story

// required uint32 id = 1;
inline bool after_story::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void after_story::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void after_story::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void after_story::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 after_story::id() const {
  return id_;
}
inline void after_story::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 tick = 2;
inline bool after_story::has_tick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void after_story::set_has_tick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void after_story::clear_has_tick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void after_story::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 after_story::tick() const {
  return tick_;
}
inline void after_story::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// kill_monster

// required uint32 monster_id = 1;
inline bool kill_monster::has_monster_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void kill_monster::set_has_monster_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void kill_monster::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void kill_monster::clear_monster_id() {
  monster_id_ = 0u;
  clear_has_monster_id();
}
inline ::google::protobuf::uint32 kill_monster::monster_id() const {
  return monster_id_;
}
inline void kill_monster::set_monster_id(::google::protobuf::uint32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// required uint32 number = 2;
inline bool kill_monster::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void kill_monster::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void kill_monster::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void kill_monster::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 kill_monster::number() const {
  return number_;
}
inline void kill_monster::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional uint32 seconds = 3;
inline bool kill_monster::has_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void kill_monster::set_has_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void kill_monster::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void kill_monster::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 kill_monster::seconds() const {
  return seconds_;
}
inline void kill_monster::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// -------------------------------------------------------------------

// touch_task

// required uint32 task_id = 1;
inline bool touch_task::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void touch_task::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void touch_task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void touch_task::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 touch_task::task_id() const {
  return task_id_;
}
inline void touch_task::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// -------------------------------------------------------------------

// start_activity

// required uint32 activity_id = 1;
inline bool start_activity::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_activity::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_activity::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_activity::clear_activity_id() {
  activity_id_ = 0u;
  clear_has_activity_id();
}
inline ::google::protobuf::uint32 start_activity::activity_id() const {
  return activity_id_;
}
inline void start_activity::set_activity_id(::google::protobuf::uint32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// -------------------------------------------------------------------

// start_time_week

// required uint32 d = 1;
inline bool start_time_week::has_d() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_time_week::set_has_d() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_time_week::clear_has_d() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_time_week::clear_d() {
  d_ = 0u;
  clear_has_d();
}
inline ::google::protobuf::uint32 start_time_week::d() const {
  return d_;
}
inline void start_time_week::set_d(::google::protobuf::uint32 value) {
  set_has_d();
  d_ = value;
}

// required .server.start_time_day t = 2;
inline bool start_time_week::has_t() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void start_time_week::set_has_t() {
  _has_bits_[0] |= 0x00000002u;
}
inline void start_time_week::clear_has_t() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void start_time_week::clear_t() {
  if (t_ != NULL) t_->::server::start_time_day::Clear();
  clear_has_t();
}
inline const ::server::start_time_day& start_time_week::t() const {
  return t_ != NULL ? *t_ : *default_instance_->t_;
}
inline ::server::start_time_day* start_time_week::mutable_t() {
  set_has_t();
  if (t_ == NULL) t_ = new ::server::start_time_day;
  return t_;
}
inline ::server::start_time_day* start_time_week::release_t() {
  clear_has_t();
  ::server::start_time_day* temp = t_;
  t_ = NULL;
  return temp;
}
inline void start_time_week::set_allocated_t(::server::start_time_day* t) {
  delete t_;
  t_ = t;
  if (t) {
    set_has_t();
  } else {
    clear_has_t();
  }
}

// -------------------------------------------------------------------

// start_time_day

// required uint32 h = 1;
inline bool start_time_day::has_h() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_time_day::set_has_h() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_time_day::clear_has_h() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_time_day::clear_h() {
  h_ = 0u;
  clear_has_h();
}
inline ::google::protobuf::uint32 start_time_day::h() const {
  return h_;
}
inline void start_time_day::set_h(::google::protobuf::uint32 value) {
  set_has_h();
  h_ = value;
}

// required uint32 m = 2;
inline bool start_time_day::has_m() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void start_time_day::set_has_m() {
  _has_bits_[0] |= 0x00000002u;
}
inline void start_time_day::clear_has_m() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void start_time_day::clear_m() {
  m_ = 0u;
  clear_has_m();
}
inline ::google::protobuf::uint32 start_time_day::m() const {
  return m_;
}
inline void start_time_day::set_m(::google::protobuf::uint32 value) {
  set_has_m();
  m_ = value;
}

// required uint32 s = 3;
inline bool start_time_day::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void start_time_day::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void start_time_day::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void start_time_day::clear_s() {
  s_ = 0u;
  clear_has_s();
}
inline ::google::protobuf::uint32 start_time_day::s() const {
  return s_;
}
inline void start_time_day::set_s(::google::protobuf::uint32 value) {
  set_has_s();
  s_ = value;
}

// required uint32 c = 4;
inline bool start_time_day::has_c() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void start_time_day::set_has_c() {
  _has_bits_[0] |= 0x00000008u;
}
inline void start_time_day::clear_has_c() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void start_time_day::clear_c() {
  c_ = 0u;
  clear_has_c();
}
inline ::google::protobuf::uint32 start_time_day::c() const {
  return c_;
}
inline void start_time_day::set_c(::google::protobuf::uint32 value) {
  set_has_c();
  c_ = value;
}

// -------------------------------------------------------------------

// start_time

// required uint32 time = 1;
inline bool start_time::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_time::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_time::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_time::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 start_time::time() const {
  return time_;
}
inline void start_time::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// get_item

// required uint32 item_id = 1;
inline bool get_item::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_item::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_item::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_item::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 get_item::item_id() const {
  return item_id_;
}
inline void get_item::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// required uint32 count = 2;
inline bool get_item::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_item::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_item::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_item::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 get_item::count() const {
  return count_;
}
inline void get_item::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 tick = 3;
inline bool get_item::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void get_item::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void get_item::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void get_item::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 get_item::tick() const {
  return tick_;
}
inline void get_item::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// touch_scense_object

// required uint32 object = 1;
inline bool touch_scense_object::has_object() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void touch_scense_object::set_has_object() {
  _has_bits_[0] |= 0x00000001u;
}
inline void touch_scense_object::clear_has_object() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void touch_scense_object::clear_object() {
  object_ = 0u;
  clear_has_object();
}
inline ::google::protobuf::uint32 touch_scense_object::object() const {
  return object_;
}
inline void touch_scense_object::set_object(::google::protobuf::uint32 value) {
  set_has_object();
  object_ = value;
}

// required uint32 count = 2;
inline bool touch_scense_object::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void touch_scense_object::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void touch_scense_object::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void touch_scense_object::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 touch_scense_object::count() const {
  return count_;
}
inline void touch_scense_object::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 tick = 3;
inline bool touch_scense_object::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void touch_scense_object::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void touch_scense_object::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void touch_scense_object::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 touch_scense_object::tick() const {
  return tick_;
}
inline void touch_scense_object::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// find_monster

// required uint32 character_id = 1;
inline bool find_monster::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void find_monster::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void find_monster::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void find_monster::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 find_monster::character_id() const {
  return character_id_;
}
inline void find_monster::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
}

// optional uint32 distance = 2;
inline bool find_monster::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void find_monster::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void find_monster::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void find_monster::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 find_monster::distance() const {
  return distance_;
}
inline void find_monster::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
}

// optional uint32 seconds = 3;
inline bool find_monster::has_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void find_monster::set_has_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void find_monster::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void find_monster::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 find_monster::seconds() const {
  return seconds_;
}
inline void find_monster::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// -------------------------------------------------------------------

// group_monster

// required uint32 monster_id = 1;
inline bool group_monster::has_monster_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void group_monster::set_has_monster_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void group_monster::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void group_monster::clear_monster_id() {
  monster_id_ = 0u;
  clear_has_monster_id();
}
inline ::google::protobuf::uint32 group_monster::monster_id() const {
  return monster_id_;
}
inline void group_monster::set_monster_id(::google::protobuf::uint32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// required uint32 number = 2;
inline bool group_monster::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void group_monster::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void group_monster::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void group_monster::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 group_monster::number() const {
  return number_;
}
inline void group_monster::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional uint32 seconds = 3;
inline bool group_monster::has_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void group_monster::set_has_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void group_monster::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void group_monster::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 group_monster::seconds() const {
  return seconds_;
}
inline void group_monster::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// -------------------------------------------------------------------

// appear_around

// required uint32 id = 1;
inline bool appear_around::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void appear_around::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void appear_around::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void appear_around::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 appear_around::id() const {
  return id_;
}
inline void appear_around::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 distance = 2;
inline bool appear_around::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void appear_around::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void appear_around::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void appear_around::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 appear_around::distance() const {
  return distance_;
}
inline void appear_around::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
}

// required uint32 tick = 3;
inline bool appear_around::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void appear_around::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void appear_around::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void appear_around::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 appear_around::tick() const {
  return tick_;
}
inline void appear_around::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// create_msg

// required string content = 1;
inline bool create_msg::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void create_msg::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void create_msg::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void create_msg::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& create_msg::content() const {
  return *content_;
}
inline void create_msg::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void create_msg::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void create_msg::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* create_msg::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* create_msg::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void create_msg::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 delay = 2;
inline bool create_msg::has_delay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void create_msg::set_has_delay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void create_msg::clear_has_delay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void create_msg::clear_delay() {
  delay_ = 0u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 create_msg::delay() const {
  return delay_;
}
inline void create_msg::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
}

// required uint32 show = 3;
inline bool create_msg::has_show() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void create_msg::set_has_show() {
  _has_bits_[0] |= 0x00000004u;
}
inline void create_msg::clear_has_show() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void create_msg::clear_show() {
  show_ = 0u;
  clear_has_show();
}
inline ::google::protobuf::uint32 create_msg::show() const {
  return show_;
}
inline void create_msg::set_show(::google::protobuf::uint32 value) {
  set_has_show();
  show_ = value;
}

// -------------------------------------------------------------------

// suspend_create

// required uint32 type = 1;
inline bool suspend_create::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void suspend_create::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void suspend_create::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void suspend_create::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 suspend_create::type() const {
  return type_;
}
inline void suspend_create::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 count = 2;
inline bool suspend_create::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void suspend_create::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void suspend_create::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void suspend_create::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 suspend_create::count() const {
  return count_;
}
inline void suspend_create::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// create_npc_rule

// repeated .server.advance_appeare advance = 1;
inline int create_npc_rule::advance_size() const {
  return advance_.size();
}
inline void create_npc_rule::clear_advance() {
  advance_.Clear();
}
inline const ::server::advance_appeare& create_npc_rule::advance(int index) const {
  return advance_.Get(index);
}
inline ::server::advance_appeare* create_npc_rule::mutable_advance(int index) {
  return advance_.Mutable(index);
}
inline ::server::advance_appeare* create_npc_rule::add_advance() {
  return advance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >&
create_npc_rule::advance() const {
  return advance_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >*
create_npc_rule::mutable_advance() {
  return &advance_;
}

// repeated .server.into_appeare into = 2;
inline int create_npc_rule::into_size() const {
  return into_.size();
}
inline void create_npc_rule::clear_into() {
  into_.Clear();
}
inline const ::server::into_appeare& create_npc_rule::into(int index) const {
  return into_.Get(index);
}
inline ::server::into_appeare* create_npc_rule::mutable_into(int index) {
  return into_.Mutable(index);
}
inline ::server::into_appeare* create_npc_rule::add_into() {
  return into_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::into_appeare >&
create_npc_rule::into() const {
  return into_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::into_appeare >*
create_npc_rule::mutable_into() {
  return &into_;
}

// repeated .server.after_story story = 3;
inline int create_npc_rule::story_size() const {
  return story_.size();
}
inline void create_npc_rule::clear_story() {
  story_.Clear();
}
inline const ::server::after_story& create_npc_rule::story(int index) const {
  return story_.Get(index);
}
inline ::server::after_story* create_npc_rule::mutable_story(int index) {
  return story_.Mutable(index);
}
inline ::server::after_story* create_npc_rule::add_story() {
  return story_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::after_story >&
create_npc_rule::story() const {
  return story_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::after_story >*
create_npc_rule::mutable_story() {
  return &story_;
}

// repeated .server.kill_monster kill = 4;
inline int create_npc_rule::kill_size() const {
  return kill_.size();
}
inline void create_npc_rule::clear_kill() {
  kill_.Clear();
}
inline const ::server::kill_monster& create_npc_rule::kill(int index) const {
  return kill_.Get(index);
}
inline ::server::kill_monster* create_npc_rule::mutable_kill(int index) {
  return kill_.Mutable(index);
}
inline ::server::kill_monster* create_npc_rule::add_kill() {
  return kill_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::kill_monster >&
create_npc_rule::kill() const {
  return kill_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::kill_monster >*
create_npc_rule::mutable_kill() {
  return &kill_;
}

// repeated .server.start_time_week week = 5;
inline int create_npc_rule::week_size() const {
  return week_.size();
}
inline void create_npc_rule::clear_week() {
  week_.Clear();
}
inline const ::server::start_time_week& create_npc_rule::week(int index) const {
  return week_.Get(index);
}
inline ::server::start_time_week* create_npc_rule::mutable_week(int index) {
  return week_.Mutable(index);
}
inline ::server::start_time_week* create_npc_rule::add_week() {
  return week_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::start_time_week >&
create_npc_rule::week() const {
  return week_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::start_time_week >*
create_npc_rule::mutable_week() {
  return &week_;
}

// repeated .server.touch_task task = 6;
inline int create_npc_rule::task_size() const {
  return task_.size();
}
inline void create_npc_rule::clear_task() {
  task_.Clear();
}
inline const ::server::touch_task& create_npc_rule::task(int index) const {
  return task_.Get(index);
}
inline ::server::touch_task* create_npc_rule::mutable_task(int index) {
  return task_.Mutable(index);
}
inline ::server::touch_task* create_npc_rule::add_task() {
  return task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::touch_task >&
create_npc_rule::task() const {
  return task_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::touch_task >*
create_npc_rule::mutable_task() {
  return &task_;
}

// repeated .server.start_activity activity = 7;
inline int create_npc_rule::activity_size() const {
  return activity_.size();
}
inline void create_npc_rule::clear_activity() {
  activity_.Clear();
}
inline const ::server::start_activity& create_npc_rule::activity(int index) const {
  return activity_.Get(index);
}
inline ::server::start_activity* create_npc_rule::mutable_activity(int index) {
  return activity_.Mutable(index);
}
inline ::server::start_activity* create_npc_rule::add_activity() {
  return activity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::start_activity >&
create_npc_rule::activity() const {
  return activity_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::start_activity >*
create_npc_rule::mutable_activity() {
  return &activity_;
}

// repeated .server.start_time time = 8;
inline int create_npc_rule::time_size() const {
  return time_.size();
}
inline void create_npc_rule::clear_time() {
  time_.Clear();
}
inline const ::server::start_time& create_npc_rule::time(int index) const {
  return time_.Get(index);
}
inline ::server::start_time* create_npc_rule::mutable_time(int index) {
  return time_.Mutable(index);
}
inline ::server::start_time* create_npc_rule::add_time() {
  return time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::start_time >&
create_npc_rule::time() const {
  return time_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::start_time >*
create_npc_rule::mutable_time() {
  return &time_;
}

// repeated .server.get_item item = 9;
inline int create_npc_rule::item_size() const {
  return item_.size();
}
inline void create_npc_rule::clear_item() {
  item_.Clear();
}
inline const ::server::get_item& create_npc_rule::item(int index) const {
  return item_.Get(index);
}
inline ::server::get_item* create_npc_rule::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::server::get_item* create_npc_rule::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::get_item >&
create_npc_rule::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::get_item >*
create_npc_rule::mutable_item() {
  return &item_;
}

// repeated .server.touch_scense_object object = 10;
inline int create_npc_rule::object_size() const {
  return object_.size();
}
inline void create_npc_rule::clear_object() {
  object_.Clear();
}
inline const ::server::touch_scense_object& create_npc_rule::object(int index) const {
  return object_.Get(index);
}
inline ::server::touch_scense_object* create_npc_rule::mutable_object(int index) {
  return object_.Mutable(index);
}
inline ::server::touch_scense_object* create_npc_rule::add_object() {
  return object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >&
create_npc_rule::object() const {
  return object_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >*
create_npc_rule::mutable_object() {
  return &object_;
}

// repeated .server.find_monster find = 11;
inline int create_npc_rule::find_size() const {
  return find_.size();
}
inline void create_npc_rule::clear_find() {
  find_.Clear();
}
inline const ::server::find_monster& create_npc_rule::find(int index) const {
  return find_.Get(index);
}
inline ::server::find_monster* create_npc_rule::mutable_find(int index) {
  return find_.Mutable(index);
}
inline ::server::find_monster* create_npc_rule::add_find() {
  return find_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::find_monster >&
create_npc_rule::find() const {
  return find_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::find_monster >*
create_npc_rule::mutable_find() {
  return &find_;
}

// repeated .server.group_monster monster = 12;
inline int create_npc_rule::monster_size() const {
  return monster_.size();
}
inline void create_npc_rule::clear_monster() {
  monster_.Clear();
}
inline const ::server::group_monster& create_npc_rule::monster(int index) const {
  return monster_.Get(index);
}
inline ::server::group_monster* create_npc_rule::mutable_monster(int index) {
  return monster_.Mutable(index);
}
inline ::server::group_monster* create_npc_rule::add_monster() {
  return monster_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::group_monster >&
create_npc_rule::monster() const {
  return monster_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::group_monster >*
create_npc_rule::mutable_monster() {
  return &monster_;
}

// repeated .server.appeare app = 13;
inline int create_npc_rule::app_size() const {
  return app_.size();
}
inline void create_npc_rule::clear_app() {
  app_.Clear();
}
inline const ::server::appeare& create_npc_rule::app(int index) const {
  return app_.Get(index);
}
inline ::server::appeare* create_npc_rule::mutable_app(int index) {
  return app_.Mutable(index);
}
inline ::server::appeare* create_npc_rule::add_app() {
  return app_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::appeare >&
create_npc_rule::app() const {
  return app_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::appeare >*
create_npc_rule::mutable_app() {
  return &app_;
}

// repeated .server.appear_around around = 14;
inline int create_npc_rule::around_size() const {
  return around_.size();
}
inline void create_npc_rule::clear_around() {
  around_.Clear();
}
inline const ::server::appear_around& create_npc_rule::around(int index) const {
  return around_.Get(index);
}
inline ::server::appear_around* create_npc_rule::mutable_around(int index) {
  return around_.Mutable(index);
}
inline ::server::appear_around* create_npc_rule::add_around() {
  return around_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::appear_around >&
create_npc_rule::around() const {
  return around_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::appear_around >*
create_npc_rule::mutable_around() {
  return &around_;
}

// optional bool clear = 15;
inline bool create_npc_rule::has_clear() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void create_npc_rule::set_has_clear() {
  _has_bits_[0] |= 0x00004000u;
}
inline void create_npc_rule::clear_has_clear() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void create_npc_rule::clear_clear() {
  clear_ = false;
  clear_has_clear();
}
inline bool create_npc_rule::clear() const {
  return clear_;
}
inline void create_npc_rule::set_clear(bool value) {
  set_has_clear();
  clear_ = value;
}

// optional uint32 index = 16;
inline bool create_npc_rule::has_index() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void create_npc_rule::set_has_index() {
  _has_bits_[0] |= 0x00008000u;
}
inline void create_npc_rule::clear_has_index() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void create_npc_rule::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 create_npc_rule::index() const {
  return index_;
}
inline void create_npc_rule::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// repeated .server.create_msg msg = 17;
inline int create_npc_rule::msg_size() const {
  return msg_.size();
}
inline void create_npc_rule::clear_msg() {
  msg_.Clear();
}
inline const ::server::create_msg& create_npc_rule::msg(int index) const {
  return msg_.Get(index);
}
inline ::server::create_msg* create_npc_rule::mutable_msg(int index) {
  return msg_.Mutable(index);
}
inline ::server::create_msg* create_npc_rule::add_msg() {
  return msg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::create_msg >&
create_npc_rule::msg() const {
  return msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::create_msg >*
create_npc_rule::mutable_msg() {
  return &msg_;
}

// repeated .server.suspend_create suspend = 18;
inline int create_npc_rule::suspend_size() const {
  return suspend_.size();
}
inline void create_npc_rule::clear_suspend() {
  suspend_.Clear();
}
inline const ::server::suspend_create& create_npc_rule::suspend(int index) const {
  return suspend_.Get(index);
}
inline ::server::suspend_create* create_npc_rule::mutable_suspend(int index) {
  return suspend_.Mutable(index);
}
inline ::server::suspend_create* create_npc_rule::add_suspend() {
  return suspend_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::suspend_create >&
create_npc_rule::suspend() const {
  return suspend_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::suspend_create >*
create_npc_rule::mutable_suspend() {
  return &suspend_;
}

// -------------------------------------------------------------------

// create_npc_rules

// repeated .server.create_npc_rule rules = 1;
inline int create_npc_rules::rules_size() const {
  return rules_.size();
}
inline void create_npc_rules::clear_rules() {
  rules_.Clear();
}
inline const ::server::create_npc_rule& create_npc_rules::rules(int index) const {
  return rules_.Get(index);
}
inline ::server::create_npc_rule* create_npc_rules::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::server::create_npc_rule* create_npc_rules::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::create_npc_rule >&
create_npc_rules::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::create_npc_rule >*
create_npc_rules::mutable_rules() {
  return &rules_;
}

// -------------------------------------------------------------------

// appear_effect

// required uint32 id = 1;
inline bool appear_effect::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void appear_effect::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void appear_effect::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void appear_effect::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 appear_effect::id() const {
  return id_;
}
inline void appear_effect::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 x = 2;
inline bool appear_effect::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void appear_effect::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void appear_effect::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void appear_effect::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 appear_effect::x() const {
  return x_;
}
inline void appear_effect::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// required uint32 y = 3;
inline bool appear_effect::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void appear_effect::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void appear_effect::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void appear_effect::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 appear_effect::y() const {
  return y_;
}
inline void appear_effect::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// required uint32 frequency = 4;
inline bool appear_effect::has_frequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void appear_effect::set_has_frequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void appear_effect::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void appear_effect::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 appear_effect::frequency() const {
  return frequency_;
}
inline void appear_effect::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
}

// -------------------------------------------------------------------

// create_effect_rule

// repeated .server.advance_appeare advance = 1;
inline int create_effect_rule::advance_size() const {
  return advance_.size();
}
inline void create_effect_rule::clear_advance() {
  advance_.Clear();
}
inline const ::server::advance_appeare& create_effect_rule::advance(int index) const {
  return advance_.Get(index);
}
inline ::server::advance_appeare* create_effect_rule::mutable_advance(int index) {
  return advance_.Mutable(index);
}
inline ::server::advance_appeare* create_effect_rule::add_advance() {
  return advance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >&
create_effect_rule::advance() const {
  return advance_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::advance_appeare >*
create_effect_rule::mutable_advance() {
  return &advance_;
}

// repeated .server.into_appeare into = 2;
inline int create_effect_rule::into_size() const {
  return into_.size();
}
inline void create_effect_rule::clear_into() {
  into_.Clear();
}
inline const ::server::into_appeare& create_effect_rule::into(int index) const {
  return into_.Get(index);
}
inline ::server::into_appeare* create_effect_rule::mutable_into(int index) {
  return into_.Mutable(index);
}
inline ::server::into_appeare* create_effect_rule::add_into() {
  return into_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::into_appeare >&
create_effect_rule::into() const {
  return into_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::into_appeare >*
create_effect_rule::mutable_into() {
  return &into_;
}

// repeated .server.after_story story = 3;
inline int create_effect_rule::story_size() const {
  return story_.size();
}
inline void create_effect_rule::clear_story() {
  story_.Clear();
}
inline const ::server::after_story& create_effect_rule::story(int index) const {
  return story_.Get(index);
}
inline ::server::after_story* create_effect_rule::mutable_story(int index) {
  return story_.Mutable(index);
}
inline ::server::after_story* create_effect_rule::add_story() {
  return story_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::after_story >&
create_effect_rule::story() const {
  return story_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::after_story >*
create_effect_rule::mutable_story() {
  return &story_;
}

// repeated .server.kill_monster kill = 4;
inline int create_effect_rule::kill_size() const {
  return kill_.size();
}
inline void create_effect_rule::clear_kill() {
  kill_.Clear();
}
inline const ::server::kill_monster& create_effect_rule::kill(int index) const {
  return kill_.Get(index);
}
inline ::server::kill_monster* create_effect_rule::mutable_kill(int index) {
  return kill_.Mutable(index);
}
inline ::server::kill_monster* create_effect_rule::add_kill() {
  return kill_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::kill_monster >&
create_effect_rule::kill() const {
  return kill_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::kill_monster >*
create_effect_rule::mutable_kill() {
  return &kill_;
}

// repeated .server.start_time_week week = 5;
inline int create_effect_rule::week_size() const {
  return week_.size();
}
inline void create_effect_rule::clear_week() {
  week_.Clear();
}
inline const ::server::start_time_week& create_effect_rule::week(int index) const {
  return week_.Get(index);
}
inline ::server::start_time_week* create_effect_rule::mutable_week(int index) {
  return week_.Mutable(index);
}
inline ::server::start_time_week* create_effect_rule::add_week() {
  return week_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::start_time_week >&
create_effect_rule::week() const {
  return week_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::start_time_week >*
create_effect_rule::mutable_week() {
  return &week_;
}

// repeated .server.touch_task task = 6;
inline int create_effect_rule::task_size() const {
  return task_.size();
}
inline void create_effect_rule::clear_task() {
  task_.Clear();
}
inline const ::server::touch_task& create_effect_rule::task(int index) const {
  return task_.Get(index);
}
inline ::server::touch_task* create_effect_rule::mutable_task(int index) {
  return task_.Mutable(index);
}
inline ::server::touch_task* create_effect_rule::add_task() {
  return task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::touch_task >&
create_effect_rule::task() const {
  return task_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::touch_task >*
create_effect_rule::mutable_task() {
  return &task_;
}

// repeated .server.start_activity activity = 7;
inline int create_effect_rule::activity_size() const {
  return activity_.size();
}
inline void create_effect_rule::clear_activity() {
  activity_.Clear();
}
inline const ::server::start_activity& create_effect_rule::activity(int index) const {
  return activity_.Get(index);
}
inline ::server::start_activity* create_effect_rule::mutable_activity(int index) {
  return activity_.Mutable(index);
}
inline ::server::start_activity* create_effect_rule::add_activity() {
  return activity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::start_activity >&
create_effect_rule::activity() const {
  return activity_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::start_activity >*
create_effect_rule::mutable_activity() {
  return &activity_;
}

// repeated .server.start_time time = 8;
inline int create_effect_rule::time_size() const {
  return time_.size();
}
inline void create_effect_rule::clear_time() {
  time_.Clear();
}
inline const ::server::start_time& create_effect_rule::time(int index) const {
  return time_.Get(index);
}
inline ::server::start_time* create_effect_rule::mutable_time(int index) {
  return time_.Mutable(index);
}
inline ::server::start_time* create_effect_rule::add_time() {
  return time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::start_time >&
create_effect_rule::time() const {
  return time_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::start_time >*
create_effect_rule::mutable_time() {
  return &time_;
}

// repeated .server.get_item item = 9;
inline int create_effect_rule::item_size() const {
  return item_.size();
}
inline void create_effect_rule::clear_item() {
  item_.Clear();
}
inline const ::server::get_item& create_effect_rule::item(int index) const {
  return item_.Get(index);
}
inline ::server::get_item* create_effect_rule::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::server::get_item* create_effect_rule::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::get_item >&
create_effect_rule::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::get_item >*
create_effect_rule::mutable_item() {
  return &item_;
}

// repeated .server.touch_scense_object object = 10;
inline int create_effect_rule::object_size() const {
  return object_.size();
}
inline void create_effect_rule::clear_object() {
  object_.Clear();
}
inline const ::server::touch_scense_object& create_effect_rule::object(int index) const {
  return object_.Get(index);
}
inline ::server::touch_scense_object* create_effect_rule::mutable_object(int index) {
  return object_.Mutable(index);
}
inline ::server::touch_scense_object* create_effect_rule::add_object() {
  return object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >&
create_effect_rule::object() const {
  return object_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::touch_scense_object >*
create_effect_rule::mutable_object() {
  return &object_;
}

// repeated .server.find_monster find = 11;
inline int create_effect_rule::find_size() const {
  return find_.size();
}
inline void create_effect_rule::clear_find() {
  find_.Clear();
}
inline const ::server::find_monster& create_effect_rule::find(int index) const {
  return find_.Get(index);
}
inline ::server::find_monster* create_effect_rule::mutable_find(int index) {
  return find_.Mutable(index);
}
inline ::server::find_monster* create_effect_rule::add_find() {
  return find_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::find_monster >&
create_effect_rule::find() const {
  return find_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::find_monster >*
create_effect_rule::mutable_find() {
  return &find_;
}

// repeated .server.group_monster monster = 12;
inline int create_effect_rule::monster_size() const {
  return monster_.size();
}
inline void create_effect_rule::clear_monster() {
  monster_.Clear();
}
inline const ::server::group_monster& create_effect_rule::monster(int index) const {
  return monster_.Get(index);
}
inline ::server::group_monster* create_effect_rule::mutable_monster(int index) {
  return monster_.Mutable(index);
}
inline ::server::group_monster* create_effect_rule::add_monster() {
  return monster_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::group_monster >&
create_effect_rule::monster() const {
  return monster_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::group_monster >*
create_effect_rule::mutable_monster() {
  return &monster_;
}

// repeated .server.appear_effect app = 13;
inline int create_effect_rule::app_size() const {
  return app_.size();
}
inline void create_effect_rule::clear_app() {
  app_.Clear();
}
inline const ::server::appear_effect& create_effect_rule::app(int index) const {
  return app_.Get(index);
}
inline ::server::appear_effect* create_effect_rule::mutable_app(int index) {
  return app_.Mutable(index);
}
inline ::server::appear_effect* create_effect_rule::add_app() {
  return app_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::appear_effect >&
create_effect_rule::app() const {
  return app_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::appear_effect >*
create_effect_rule::mutable_app() {
  return &app_;
}

// -------------------------------------------------------------------

// create_effect_rules

// repeated .server.create_effect_rule rules = 1;
inline int create_effect_rules::rules_size() const {
  return rules_.size();
}
inline void create_effect_rules::clear_rules() {
  rules_.Clear();
}
inline const ::server::create_effect_rule& create_effect_rules::rules(int index) const {
  return rules_.Get(index);
}
inline ::server::create_effect_rule* create_effect_rules::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::server::create_effect_rule* create_effect_rules::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::create_effect_rule >&
create_effect_rules::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::create_effect_rule >*
create_effect_rules::mutable_rules() {
  return &rules_;
}

// -------------------------------------------------------------------

// dead_role

// required uint32 id = 1;
inline bool dead_role::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dead_role::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dead_role::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dead_role::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 dead_role::id() const {
  return id_;
}
inline void dead_role::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 count = 2;
inline bool dead_role::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dead_role::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dead_role::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dead_role::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 dead_role::count() const {
  return count_;
}
inline void dead_role::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 tick = 3;
inline bool dead_role::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dead_role::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dead_role::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dead_role::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 dead_role::tick() const {
  return tick_;
}
inline void dead_role::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// survive_role

// required uint32 count = 1;
inline bool survive_role::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void survive_role::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void survive_role::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void survive_role::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 survive_role::count() const {
  return count_;
}
inline void survive_role::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 tick = 2;
inline bool survive_role::has_tick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void survive_role::set_has_tick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void survive_role::clear_has_tick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void survive_role::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 survive_role::tick() const {
  return tick_;
}
inline void survive_role::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// scene_timeout

// required uint32 tenms = 1;
inline bool scene_timeout::has_tenms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scene_timeout::set_has_tenms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scene_timeout::clear_has_tenms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scene_timeout::clear_tenms() {
  tenms_ = 0u;
  clear_has_tenms();
}
inline ::google::protobuf::uint32 scene_timeout::tenms() const {
  return tenms_;
}
inline void scene_timeout::set_tenms(::google::protobuf::uint32 value) {
  set_has_tenms();
  tenms_ = value;
}

// -------------------------------------------------------------------

// dead_count

// required uint32 count = 1;
inline bool dead_count::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dead_count::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dead_count::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dead_count::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 dead_count::count() const {
  return count_;
}
inline void dead_count::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// role_attribute

// required uint32 id = 1;
inline bool role_attribute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_attribute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_attribute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_attribute::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 role_attribute::id() const {
  return id_;
}
inline void role_attribute::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 type = 2;
inline bool role_attribute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_attribute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_attribute::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 role_attribute::type() const {
  return type_;
}
inline void role_attribute::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 value = 3;
inline bool role_attribute::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_attribute::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_attribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_attribute::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 role_attribute::value() const {
  return value_;
}
inline void role_attribute::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// role_postion

// required uint32 id = 1;
inline bool role_postion::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_postion::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_postion::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_postion::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 role_postion::id() const {
  return id_;
}
inline void role_postion::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 x = 2;
inline bool role_postion::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_postion::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_postion::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_postion::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 role_postion::x() const {
  return x_;
}
inline void role_postion::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// required uint32 y = 3;
inline bool role_postion::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_postion::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_postion::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_postion::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 role_postion::y() const {
  return y_;
}
inline void role_postion::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// required uint32 distance = 4;
inline bool role_postion::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_postion::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_postion::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_postion::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 role_postion::distance() const {
  return distance_;
}
inline void role_postion::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
}

// required uint32 number = 5;
inline bool role_postion::has_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_postion::set_has_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_postion::clear_has_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_postion::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 role_postion::number() const {
  return number_;
}
inline void role_postion::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// required uint32 tick = 6;
inline bool role_postion::has_tick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_postion::set_has_tick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_postion::clear_has_tick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_postion::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 role_postion::tick() const {
  return tick_;
}
inline void role_postion::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// raid_success_rule

// repeated .server.dead_role role = 1;
inline int raid_success_rule::role_size() const {
  return role_.size();
}
inline void raid_success_rule::clear_role() {
  role_.Clear();
}
inline const ::server::dead_role& raid_success_rule::role(int index) const {
  return role_.Get(index);
}
inline ::server::dead_role* raid_success_rule::mutable_role(int index) {
  return role_.Mutable(index);
}
inline ::server::dead_role* raid_success_rule::add_role() {
  return role_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::dead_role >&
raid_success_rule::role() const {
  return role_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::dead_role >*
raid_success_rule::mutable_role() {
  return &role_;
}

// repeated .server.get_item item = 2;
inline int raid_success_rule::item_size() const {
  return item_.size();
}
inline void raid_success_rule::clear_item() {
  item_.Clear();
}
inline const ::server::get_item& raid_success_rule::item(int index) const {
  return item_.Get(index);
}
inline ::server::get_item* raid_success_rule::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::server::get_item* raid_success_rule::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::get_item >&
raid_success_rule::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::get_item >*
raid_success_rule::mutable_item() {
  return &item_;
}

// repeated .server.dead_role touch = 3;
inline int raid_success_rule::touch_size() const {
  return touch_.size();
}
inline void raid_success_rule::clear_touch() {
  touch_.Clear();
}
inline const ::server::dead_role& raid_success_rule::touch(int index) const {
  return touch_.Get(index);
}
inline ::server::dead_role* raid_success_rule::mutable_touch(int index) {
  return touch_.Mutable(index);
}
inline ::server::dead_role* raid_success_rule::add_touch() {
  return touch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::dead_role >&
raid_success_rule::touch() const {
  return touch_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::dead_role >*
raid_success_rule::mutable_touch() {
  return &touch_;
}

// repeated .server.ai_timer timer = 4;
inline int raid_success_rule::timer_size() const {
  return timer_.size();
}
inline void raid_success_rule::clear_timer() {
  timer_.Clear();
}
inline const ::server::ai_timer& raid_success_rule::timer(int index) const {
  return timer_.Get(index);
}
inline ::server::ai_timer* raid_success_rule::mutable_timer(int index) {
  return timer_.Mutable(index);
}
inline ::server::ai_timer* raid_success_rule::add_timer() {
  return timer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::ai_timer >&
raid_success_rule::timer() const {
  return timer_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::ai_timer >*
raid_success_rule::mutable_timer() {
  return &timer_;
}

// repeated .server.role_postion pos = 5;
inline int raid_success_rule::pos_size() const {
  return pos_.size();
}
inline void raid_success_rule::clear_pos() {
  pos_.Clear();
}
inline const ::server::role_postion& raid_success_rule::pos(int index) const {
  return pos_.Get(index);
}
inline ::server::role_postion* raid_success_rule::mutable_pos(int index) {
  return pos_.Mutable(index);
}
inline ::server::role_postion* raid_success_rule::add_pos() {
  return pos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::role_postion >&
raid_success_rule::pos() const {
  return pos_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::role_postion >*
raid_success_rule::mutable_pos() {
  return &pos_;
}

// repeated .server.role_postion block = 6;
inline int raid_success_rule::block_size() const {
  return block_.size();
}
inline void raid_success_rule::clear_block() {
  block_.Clear();
}
inline const ::server::role_postion& raid_success_rule::block(int index) const {
  return block_.Get(index);
}
inline ::server::role_postion* raid_success_rule::mutable_block(int index) {
  return block_.Mutable(index);
}
inline ::server::role_postion* raid_success_rule::add_block() {
  return block_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::role_postion >&
raid_success_rule::block() const {
  return block_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::role_postion >*
raid_success_rule::mutable_block() {
  return &block_;
}

// repeated .server.survive_role survive = 7;
inline int raid_success_rule::survive_size() const {
  return survive_.size();
}
inline void raid_success_rule::clear_survive() {
  survive_.Clear();
}
inline const ::server::survive_role& raid_success_rule::survive(int index) const {
  return survive_.Get(index);
}
inline ::server::survive_role* raid_success_rule::mutable_survive(int index) {
  return survive_.Mutable(index);
}
inline ::server::survive_role* raid_success_rule::add_survive() {
  return survive_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::survive_role >&
raid_success_rule::survive() const {
  return survive_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::survive_role >*
raid_success_rule::mutable_survive() {
  return &survive_;
}

// -------------------------------------------------------------------

// raid_failure_rule

// repeated .server.dead_count role = 1;
inline int raid_failure_rule::role_size() const {
  return role_.size();
}
inline void raid_failure_rule::clear_role() {
  role_.Clear();
}
inline const ::server::dead_count& raid_failure_rule::role(int index) const {
  return role_.Get(index);
}
inline ::server::dead_count* raid_failure_rule::mutable_role(int index) {
  return role_.Mutable(index);
}
inline ::server::dead_count* raid_failure_rule::add_role() {
  return role_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::dead_count >&
raid_failure_rule::role() const {
  return role_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::dead_count >*
raid_failure_rule::mutable_role() {
  return &role_;
}

// repeated .server.scene_timeout timeout = 2;
inline int raid_failure_rule::timeout_size() const {
  return timeout_.size();
}
inline void raid_failure_rule::clear_timeout() {
  timeout_.Clear();
}
inline const ::server::scene_timeout& raid_failure_rule::timeout(int index) const {
  return timeout_.Get(index);
}
inline ::server::scene_timeout* raid_failure_rule::mutable_timeout(int index) {
  return timeout_.Mutable(index);
}
inline ::server::scene_timeout* raid_failure_rule::add_timeout() {
  return timeout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::scene_timeout >&
raid_failure_rule::timeout() const {
  return timeout_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::scene_timeout >*
raid_failure_rule::mutable_timeout() {
  return &timeout_;
}

// repeated .server.dead_count count = 3;
inline int raid_failure_rule::count_size() const {
  return count_.size();
}
inline void raid_failure_rule::clear_count() {
  count_.Clear();
}
inline const ::server::dead_count& raid_failure_rule::count(int index) const {
  return count_.Get(index);
}
inline ::server::dead_count* raid_failure_rule::mutable_count(int index) {
  return count_.Mutable(index);
}
inline ::server::dead_count* raid_failure_rule::add_count() {
  return count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::dead_count >&
raid_failure_rule::count() const {
  return count_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::dead_count >*
raid_failure_rule::mutable_count() {
  return &count_;
}

// repeated .server.role_attribute attr = 4;
inline int raid_failure_rule::attr_size() const {
  return attr_.size();
}
inline void raid_failure_rule::clear_attr() {
  attr_.Clear();
}
inline const ::server::role_attribute& raid_failure_rule::attr(int index) const {
  return attr_.Get(index);
}
inline ::server::role_attribute* raid_failure_rule::mutable_attr(int index) {
  return attr_.Mutable(index);
}
inline ::server::role_attribute* raid_failure_rule::add_attr() {
  return attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::role_attribute >&
raid_failure_rule::attr() const {
  return attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::role_attribute >*
raid_failure_rule::mutable_attr() {
  return &attr_;
}

// repeated .server.role_postion pos = 5;
inline int raid_failure_rule::pos_size() const {
  return pos_.size();
}
inline void raid_failure_rule::clear_pos() {
  pos_.Clear();
}
inline const ::server::role_postion& raid_failure_rule::pos(int index) const {
  return pos_.Get(index);
}
inline ::server::role_postion* raid_failure_rule::mutable_pos(int index) {
  return pos_.Mutable(index);
}
inline ::server::role_postion* raid_failure_rule::add_pos() {
  return pos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::role_postion >&
raid_failure_rule::pos() const {
  return pos_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::role_postion >*
raid_failure_rule::mutable_pos() {
  return &pos_;
}

// -------------------------------------------------------------------

// raid_over_rules

// repeated .server.raid_success_rule success = 1;
inline int raid_over_rules::success_size() const {
  return success_.size();
}
inline void raid_over_rules::clear_success() {
  success_.Clear();
}
inline const ::server::raid_success_rule& raid_over_rules::success(int index) const {
  return success_.Get(index);
}
inline ::server::raid_success_rule* raid_over_rules::mutable_success(int index) {
  return success_.Mutable(index);
}
inline ::server::raid_success_rule* raid_over_rules::add_success() {
  return success_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::raid_success_rule >&
raid_over_rules::success() const {
  return success_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::raid_success_rule >*
raid_over_rules::mutable_success() {
  return &success_;
}

// repeated .server.raid_failure_rule failure = 2;
inline int raid_over_rules::failure_size() const {
  return failure_.size();
}
inline void raid_over_rules::clear_failure() {
  failure_.Clear();
}
inline const ::server::raid_failure_rule& raid_over_rules::failure(int index) const {
  return failure_.Get(index);
}
inline ::server::raid_failure_rule* raid_over_rules::mutable_failure(int index) {
  return failure_.Mutable(index);
}
inline ::server::raid_failure_rule* raid_over_rules::add_failure() {
  return failure_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server::raid_failure_rule >&
raid_over_rules::failure() const {
  return failure_;
}
inline ::google::protobuf::RepeatedPtrField< ::server::raid_failure_rule >*
raid_over_rules::mutable_failure() {
  return &failure_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace server

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::appeare_type>() {
  return ::server::appeare_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::AI_COMPARE_RULE>() {
  return ::server::AI_COMPARE_RULE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::AI_TARGET_TYPE>() {
  return ::server::AI_TARGET_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_server_2eai_2eproto__INCLUDED
