// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.lottery.proto

#ifndef PROTOBUF_client_2elottery_2eproto__INCLUDED
#define PROTOBUF_client_2elottery_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
#include "client.role_props.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2elottery_2eproto();
void protobuf_AssignDesc_client_2elottery_2eproto();
void protobuf_ShutdownFile_client_2elottery_2eproto();

class lottery_item;
class lottery_info;
class lottery_time_req;
class lottery_time_rsp;
class lottery_open_req;
class lottery_open_rsp;

enum lottery_open_rsp_ret_e {
  lottery_open_rsp_ret_e_SUCCESS = 0,
  lottery_open_rsp_ret_e_PROP_LIMIT = 1,
  lottery_open_rsp_ret_e_BAG_LIMIT = 2,
  lottery_open_rsp_ret_e_MONEY_LIMIT = 3,
  lottery_open_rsp_ret_e_INGOT_LIMIT = 4,
  lottery_open_rsp_ret_e_FAILURE = 5
};
bool lottery_open_rsp_ret_e_IsValid(int value);
const lottery_open_rsp_ret_e lottery_open_rsp_ret_e_ret_e_MIN = lottery_open_rsp_ret_e_SUCCESS;
const lottery_open_rsp_ret_e lottery_open_rsp_ret_e_ret_e_MAX = lottery_open_rsp_ret_e_FAILURE;
const int lottery_open_rsp_ret_e_ret_e_ARRAYSIZE = lottery_open_rsp_ret_e_ret_e_MAX + 1;

const ::google::protobuf::EnumDescriptor* lottery_open_rsp_ret_e_descriptor();
inline const ::std::string& lottery_open_rsp_ret_e_Name(lottery_open_rsp_ret_e value) {
  return ::google::protobuf::internal::NameOfEnum(
    lottery_open_rsp_ret_e_descriptor(), value);
}
inline bool lottery_open_rsp_ret_e_Parse(
    const ::std::string& name, lottery_open_rsp_ret_e* value) {
  return ::google::protobuf::internal::ParseNamedEnum<lottery_open_rsp_ret_e>(
    lottery_open_rsp_ret_e_descriptor(), name, value);
}
enum LOTTERY_TYPE_E {
  GOLD_BOX = 0,
  BRONZE_BOX = 1
};
bool LOTTERY_TYPE_E_IsValid(int value);
const LOTTERY_TYPE_E LOTTERY_TYPE_E_MIN = GOLD_BOX;
const LOTTERY_TYPE_E LOTTERY_TYPE_E_MAX = BRONZE_BOX;
const int LOTTERY_TYPE_E_ARRAYSIZE = LOTTERY_TYPE_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* LOTTERY_TYPE_E_descriptor();
inline const ::std::string& LOTTERY_TYPE_E_Name(LOTTERY_TYPE_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    LOTTERY_TYPE_E_descriptor(), value);
}
inline bool LOTTERY_TYPE_E_Parse(
    const ::std::string& name, LOTTERY_TYPE_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LOTTERY_TYPE_E>(
    LOTTERY_TYPE_E_descriptor(), name, value);
}
// ===================================================================

class lottery_item : public ::google::protobuf::Message {
 public:
  lottery_item();
  virtual ~lottery_item();

  lottery_item(const lottery_item& from);

  inline lottery_item& operator=(const lottery_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lottery_item& default_instance();

  void Swap(lottery_item* other);

  // implements Message ----------------------------------------------

  lottery_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lottery_item& from);
  void MergeFrom(const lottery_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 prop_id = 1;
  inline bool has_prop_id() const;
  inline void clear_prop_id();
  static const int kPropIdFieldNumber = 1;
  inline ::google::protobuf::uint32 prop_id() const;
  inline void set_prop_id(::google::protobuf::uint32 value);

  // optional uint32 gold_box = 2 [default = 0];
  inline bool has_gold_box() const;
  inline void clear_gold_box();
  static const int kGoldBoxFieldNumber = 2;
  inline ::google::protobuf::uint32 gold_box() const;
  inline void set_gold_box(::google::protobuf::uint32 value);

  // optional uint32 bronze_box = 3 [default = 0];
  inline bool has_bronze_box() const;
  inline void clear_bronze_box();
  static const int kBronzeBoxFieldNumber = 3;
  inline ::google::protobuf::uint32 bronze_box() const;
  inline void set_bronze_box(::google::protobuf::uint32 value);

  // optional uint32 num = 4 [default = 1];
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.lottery_item)
 private:
  inline void set_has_prop_id();
  inline void clear_has_prop_id();
  inline void set_has_gold_box();
  inline void clear_has_gold_box();
  inline void set_has_bronze_box();
  inline void clear_has_bronze_box();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 prop_id_;
  ::google::protobuf::uint32 gold_box_;
  ::google::protobuf::uint32 bronze_box_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2elottery_2eproto();
  friend void protobuf_AssignDesc_client_2elottery_2eproto();
  friend void protobuf_ShutdownFile_client_2elottery_2eproto();

  void InitAsDefaultInstance();
  static lottery_item* default_instance_;
};
// -------------------------------------------------------------------

class lottery_info : public ::google::protobuf::Message {
 public:
  lottery_info();
  virtual ~lottery_info();

  lottery_info(const lottery_info& from);

  inline lottery_info& operator=(const lottery_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lottery_info& default_instance();

  void Swap(lottery_info* other);

  // implements Message ----------------------------------------------

  lottery_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lottery_info& from);
  void MergeFrom(const lottery_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gold_time = 1;
  inline bool has_gold_time() const;
  inline void clear_gold_time();
  static const int kGoldTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 gold_time() const;
  inline void set_gold_time(::google::protobuf::uint32 value);

  // required uint32 bronze_time = 2;
  inline bool has_bronze_time() const;
  inline void clear_bronze_time();
  static const int kBronzeTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 bronze_time() const;
  inline void set_bronze_time(::google::protobuf::uint32 value);

  // required .client.lottery_item gold_lpi = 3;
  inline bool has_gold_lpi() const;
  inline void clear_gold_lpi();
  static const int kGoldLpiFieldNumber = 3;
  inline const ::client::lottery_item& gold_lpi() const;
  inline ::client::lottery_item* mutable_gold_lpi();
  inline ::client::lottery_item* release_gold_lpi();
  inline void set_allocated_gold_lpi(::client::lottery_item* gold_lpi);

  // @@protoc_insertion_point(class_scope:client.lottery_info)
 private:
  inline void set_has_gold_time();
  inline void clear_has_gold_time();
  inline void set_has_bronze_time();
  inline void clear_has_bronze_time();
  inline void set_has_gold_lpi();
  inline void clear_has_gold_lpi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gold_time_;
  ::google::protobuf::uint32 bronze_time_;
  ::client::lottery_item* gold_lpi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2elottery_2eproto();
  friend void protobuf_AssignDesc_client_2elottery_2eproto();
  friend void protobuf_ShutdownFile_client_2elottery_2eproto();

  void InitAsDefaultInstance();
  static lottery_info* default_instance_;
};
// -------------------------------------------------------------------

class lottery_time_req : public ::google::protobuf::Message {
 public:
  lottery_time_req();
  virtual ~lottery_time_req();

  lottery_time_req(const lottery_time_req& from);

  inline lottery_time_req& operator=(const lottery_time_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lottery_time_req& default_instance();

  void Swap(lottery_time_req* other);

  // implements Message ----------------------------------------------

  lottery_time_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lottery_time_req& from);
  void MergeFrom(const lottery_time_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.lottery_time_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2elottery_2eproto();
  friend void protobuf_AssignDesc_client_2elottery_2eproto();
  friend void protobuf_ShutdownFile_client_2elottery_2eproto();

  void InitAsDefaultInstance();
  static lottery_time_req* default_instance_;
};
// -------------------------------------------------------------------

class lottery_time_rsp : public ::google::protobuf::Message {
 public:
  lottery_time_rsp();
  virtual ~lottery_time_rsp();

  lottery_time_rsp(const lottery_time_rsp& from);

  inline lottery_time_rsp& operator=(const lottery_time_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lottery_time_rsp& default_instance();

  void Swap(lottery_time_rsp* other);

  // implements Message ----------------------------------------------

  lottery_time_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lottery_time_rsp& from);
  void MergeFrom(const lottery_time_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gold_time = 1;
  inline bool has_gold_time() const;
  inline void clear_gold_time();
  static const int kGoldTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 gold_time() const;
  inline void set_gold_time(::google::protobuf::uint32 value);

  // required uint32 bronze_time = 2;
  inline bool has_bronze_time() const;
  inline void clear_bronze_time();
  static const int kBronzeTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 bronze_time() const;
  inline void set_bronze_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.lottery_time_rsp)
 private:
  inline void set_has_gold_time();
  inline void clear_has_gold_time();
  inline void set_has_bronze_time();
  inline void clear_has_bronze_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gold_time_;
  ::google::protobuf::uint32 bronze_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2elottery_2eproto();
  friend void protobuf_AssignDesc_client_2elottery_2eproto();
  friend void protobuf_ShutdownFile_client_2elottery_2eproto();

  void InitAsDefaultInstance();
  static lottery_time_rsp* default_instance_;
};
// -------------------------------------------------------------------

class lottery_open_req : public ::google::protobuf::Message {
 public:
  lottery_open_req();
  virtual ~lottery_open_req();

  lottery_open_req(const lottery_open_req& from);

  inline lottery_open_req& operator=(const lottery_open_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lottery_open_req& default_instance();

  void Swap(lottery_open_req* other);

  // implements Message ----------------------------------------------

  lottery_open_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lottery_open_req& from);
  void MergeFrom(const lottery_open_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 times = 1;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 1;
  inline ::google::protobuf::uint32 times() const;
  inline void set_times(::google::protobuf::uint32 value);

  // required .client.LOTTERY_TYPE_E type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::client::LOTTERY_TYPE_E type() const;
  inline void set_type(::client::LOTTERY_TYPE_E value);

  // required uint32 auto_buy = 3;
  inline bool has_auto_buy() const;
  inline void clear_auto_buy();
  static const int kAutoBuyFieldNumber = 3;
  inline ::google::protobuf::uint32 auto_buy() const;
  inline void set_auto_buy(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.lottery_open_req)
 private:
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_auto_buy();
  inline void clear_has_auto_buy();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 times_;
  int type_;
  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 auto_buy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2elottery_2eproto();
  friend void protobuf_AssignDesc_client_2elottery_2eproto();
  friend void protobuf_ShutdownFile_client_2elottery_2eproto();

  void InitAsDefaultInstance();
  static lottery_open_req* default_instance_;
};
// -------------------------------------------------------------------

class lottery_open_rsp : public ::google::protobuf::Message {
 public:
  lottery_open_rsp();
  virtual ~lottery_open_rsp();

  lottery_open_rsp(const lottery_open_rsp& from);

  inline lottery_open_rsp& operator=(const lottery_open_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lottery_open_rsp& default_instance();

  void Swap(lottery_open_rsp* other);

  // implements Message ----------------------------------------------

  lottery_open_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lottery_open_rsp& from);
  void MergeFrom(const lottery_open_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef lottery_open_rsp_ret_e ret_e;
  static const ret_e SUCCESS = lottery_open_rsp_ret_e_SUCCESS;
  static const ret_e PROP_LIMIT = lottery_open_rsp_ret_e_PROP_LIMIT;
  static const ret_e BAG_LIMIT = lottery_open_rsp_ret_e_BAG_LIMIT;
  static const ret_e MONEY_LIMIT = lottery_open_rsp_ret_e_MONEY_LIMIT;
  static const ret_e INGOT_LIMIT = lottery_open_rsp_ret_e_INGOT_LIMIT;
  static const ret_e FAILURE = lottery_open_rsp_ret_e_FAILURE;
  static inline bool ret_e_IsValid(int value) {
    return lottery_open_rsp_ret_e_IsValid(value);
  }
  static const ret_e ret_e_MIN =
    lottery_open_rsp_ret_e_ret_e_MIN;
  static const ret_e ret_e_MAX =
    lottery_open_rsp_ret_e_ret_e_MAX;
  static const int ret_e_ARRAYSIZE =
    lottery_open_rsp_ret_e_ret_e_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ret_e_descriptor() {
    return lottery_open_rsp_ret_e_descriptor();
  }
  static inline const ::std::string& ret_e_Name(ret_e value) {
    return lottery_open_rsp_ret_e_Name(value);
  }
  static inline bool ret_e_Parse(const ::std::string& name,
      ret_e* value) {
    return lottery_open_rsp_ret_e_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.lottery_open_rsp.ret_e ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::lottery_open_rsp_ret_e ret() const;
  inline void set_ret(::client::lottery_open_rsp_ret_e value);

  // repeated .client.props_info pi = 2;
  inline int pi_size() const;
  inline void clear_pi();
  static const int kPiFieldNumber = 2;
  inline const ::client::props_info& pi(int index) const;
  inline ::client::props_info* mutable_pi(int index);
  inline ::client::props_info* add_pi();
  inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
      pi() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
      mutable_pi();

  // @@protoc_insertion_point(class_scope:client.lottery_open_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::props_info > pi_;
  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2elottery_2eproto();
  friend void protobuf_AssignDesc_client_2elottery_2eproto();
  friend void protobuf_ShutdownFile_client_2elottery_2eproto();

  void InitAsDefaultInstance();
  static lottery_open_rsp* default_instance_;
};
// ===================================================================


// ===================================================================

// lottery_item

// required uint32 prop_id = 1;
inline bool lottery_item::has_prop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lottery_item::set_has_prop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lottery_item::clear_has_prop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lottery_item::clear_prop_id() {
  prop_id_ = 0u;
  clear_has_prop_id();
}
inline ::google::protobuf::uint32 lottery_item::prop_id() const {
  return prop_id_;
}
inline void lottery_item::set_prop_id(::google::protobuf::uint32 value) {
  set_has_prop_id();
  prop_id_ = value;
}

// optional uint32 gold_box = 2 [default = 0];
inline bool lottery_item::has_gold_box() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lottery_item::set_has_gold_box() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lottery_item::clear_has_gold_box() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lottery_item::clear_gold_box() {
  gold_box_ = 0u;
  clear_has_gold_box();
}
inline ::google::protobuf::uint32 lottery_item::gold_box() const {
  return gold_box_;
}
inline void lottery_item::set_gold_box(::google::protobuf::uint32 value) {
  set_has_gold_box();
  gold_box_ = value;
}

// optional uint32 bronze_box = 3 [default = 0];
inline bool lottery_item::has_bronze_box() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lottery_item::set_has_bronze_box() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lottery_item::clear_has_bronze_box() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lottery_item::clear_bronze_box() {
  bronze_box_ = 0u;
  clear_has_bronze_box();
}
inline ::google::protobuf::uint32 lottery_item::bronze_box() const {
  return bronze_box_;
}
inline void lottery_item::set_bronze_box(::google::protobuf::uint32 value) {
  set_has_bronze_box();
  bronze_box_ = value;
}

// optional uint32 num = 4 [default = 1];
inline bool lottery_item::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lottery_item::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lottery_item::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lottery_item::clear_num() {
  num_ = 1u;
  clear_has_num();
}
inline ::google::protobuf::uint32 lottery_item::num() const {
  return num_;
}
inline void lottery_item::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// lottery_info

// required uint32 gold_time = 1;
inline bool lottery_info::has_gold_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lottery_info::set_has_gold_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lottery_info::clear_has_gold_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lottery_info::clear_gold_time() {
  gold_time_ = 0u;
  clear_has_gold_time();
}
inline ::google::protobuf::uint32 lottery_info::gold_time() const {
  return gold_time_;
}
inline void lottery_info::set_gold_time(::google::protobuf::uint32 value) {
  set_has_gold_time();
  gold_time_ = value;
}

// required uint32 bronze_time = 2;
inline bool lottery_info::has_bronze_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lottery_info::set_has_bronze_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lottery_info::clear_has_bronze_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lottery_info::clear_bronze_time() {
  bronze_time_ = 0u;
  clear_has_bronze_time();
}
inline ::google::protobuf::uint32 lottery_info::bronze_time() const {
  return bronze_time_;
}
inline void lottery_info::set_bronze_time(::google::protobuf::uint32 value) {
  set_has_bronze_time();
  bronze_time_ = value;
}

// required .client.lottery_item gold_lpi = 3;
inline bool lottery_info::has_gold_lpi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lottery_info::set_has_gold_lpi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lottery_info::clear_has_gold_lpi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lottery_info::clear_gold_lpi() {
  if (gold_lpi_ != NULL) gold_lpi_->::client::lottery_item::Clear();
  clear_has_gold_lpi();
}
inline const ::client::lottery_item& lottery_info::gold_lpi() const {
  return gold_lpi_ != NULL ? *gold_lpi_ : *default_instance_->gold_lpi_;
}
inline ::client::lottery_item* lottery_info::mutable_gold_lpi() {
  set_has_gold_lpi();
  if (gold_lpi_ == NULL) gold_lpi_ = new ::client::lottery_item;
  return gold_lpi_;
}
inline ::client::lottery_item* lottery_info::release_gold_lpi() {
  clear_has_gold_lpi();
  ::client::lottery_item* temp = gold_lpi_;
  gold_lpi_ = NULL;
  return temp;
}
inline void lottery_info::set_allocated_gold_lpi(::client::lottery_item* gold_lpi) {
  delete gold_lpi_;
  gold_lpi_ = gold_lpi;
  if (gold_lpi) {
    set_has_gold_lpi();
  } else {
    clear_has_gold_lpi();
  }
}

// -------------------------------------------------------------------

// lottery_time_req

// required uint32 role_id = 1;
inline bool lottery_time_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lottery_time_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lottery_time_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lottery_time_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 lottery_time_req::role_id() const {
  return role_id_;
}
inline void lottery_time_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool lottery_time_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lottery_time_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lottery_time_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lottery_time_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& lottery_time_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* lottery_time_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* lottery_time_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void lottery_time_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// lottery_time_rsp

// required uint32 gold_time = 1;
inline bool lottery_time_rsp::has_gold_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lottery_time_rsp::set_has_gold_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lottery_time_rsp::clear_has_gold_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lottery_time_rsp::clear_gold_time() {
  gold_time_ = 0u;
  clear_has_gold_time();
}
inline ::google::protobuf::uint32 lottery_time_rsp::gold_time() const {
  return gold_time_;
}
inline void lottery_time_rsp::set_gold_time(::google::protobuf::uint32 value) {
  set_has_gold_time();
  gold_time_ = value;
}

// required uint32 bronze_time = 2;
inline bool lottery_time_rsp::has_bronze_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lottery_time_rsp::set_has_bronze_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lottery_time_rsp::clear_has_bronze_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lottery_time_rsp::clear_bronze_time() {
  bronze_time_ = 0u;
  clear_has_bronze_time();
}
inline ::google::protobuf::uint32 lottery_time_rsp::bronze_time() const {
  return bronze_time_;
}
inline void lottery_time_rsp::set_bronze_time(::google::protobuf::uint32 value) {
  set_has_bronze_time();
  bronze_time_ = value;
}

// -------------------------------------------------------------------

// lottery_open_req

// required uint32 times = 1;
inline bool lottery_open_req::has_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lottery_open_req::set_has_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lottery_open_req::clear_has_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lottery_open_req::clear_times() {
  times_ = 0u;
  clear_has_times();
}
inline ::google::protobuf::uint32 lottery_open_req::times() const {
  return times_;
}
inline void lottery_open_req::set_times(::google::protobuf::uint32 value) {
  set_has_times();
  times_ = value;
}

// required .client.LOTTERY_TYPE_E type = 2;
inline bool lottery_open_req::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lottery_open_req::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lottery_open_req::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lottery_open_req::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::client::LOTTERY_TYPE_E lottery_open_req::type() const {
  return static_cast< ::client::LOTTERY_TYPE_E >(type_);
}
inline void lottery_open_req::set_type(::client::LOTTERY_TYPE_E value) {
  assert(::client::LOTTERY_TYPE_E_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint32 auto_buy = 3;
inline bool lottery_open_req::has_auto_buy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lottery_open_req::set_has_auto_buy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lottery_open_req::clear_has_auto_buy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lottery_open_req::clear_auto_buy() {
  auto_buy_ = 0u;
  clear_has_auto_buy();
}
inline ::google::protobuf::uint32 lottery_open_req::auto_buy() const {
  return auto_buy_;
}
inline void lottery_open_req::set_auto_buy(::google::protobuf::uint32 value) {
  set_has_auto_buy();
  auto_buy_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool lottery_open_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lottery_open_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lottery_open_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lottery_open_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& lottery_open_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* lottery_open_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* lottery_open_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void lottery_open_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// lottery_open_rsp

// required .client.lottery_open_rsp.ret_e ret = 1;
inline bool lottery_open_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lottery_open_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lottery_open_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lottery_open_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::lottery_open_rsp_ret_e lottery_open_rsp::ret() const {
  return static_cast< ::client::lottery_open_rsp_ret_e >(ret_);
}
inline void lottery_open_rsp::set_ret(::client::lottery_open_rsp_ret_e value) {
  assert(::client::lottery_open_rsp_ret_e_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// repeated .client.props_info pi = 2;
inline int lottery_open_rsp::pi_size() const {
  return pi_.size();
}
inline void lottery_open_rsp::clear_pi() {
  pi_.Clear();
}
inline const ::client::props_info& lottery_open_rsp::pi(int index) const {
  return pi_.Get(index);
}
inline ::client::props_info* lottery_open_rsp::mutable_pi(int index) {
  return pi_.Mutable(index);
}
inline ::client::props_info* lottery_open_rsp::add_pi() {
  return pi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
lottery_open_rsp::pi() const {
  return pi_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
lottery_open_rsp::mutable_pi() {
  return &pi_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::lottery_open_rsp_ret_e>() {
  return ::client::lottery_open_rsp_ret_e_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::LOTTERY_TYPE_E>() {
  return ::client::LOTTERY_TYPE_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2elottery_2eproto__INCLUDED
