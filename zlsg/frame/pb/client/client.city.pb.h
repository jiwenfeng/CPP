// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.city.proto

#ifndef PROTOBUF_client_2ecity_2eproto__INCLUDED
#define PROTOBUF_client_2ecity_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
#include "client.family.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2ecity_2eproto();
void protobuf_AssignDesc_client_2ecity_2eproto();
void protobuf_ShutdownFile_client_2ecity_2eproto();

class official_info;
class city_info_req;
class city_info_rsp;
class city_mod_title_req;
class city_mod_title_rsp;
class city_welfare_info_req;
class city_pos_reward;
class city_welfare_info_rsp;
class city_welfare_get_req;
class city_welfare_get_rsp;
class city_welfare_get_notify;
class siege_enter_req;
class siege_enter_rsp;
class siege_enter_field;
class siege_scene_camp_req;
class siege_scene_camp;
class siege_dead_msg_rsp;
class siege_revive_req;
class siege_revive_rsp;
class siege_status;
class siege_status_rsp;
class siege_personal_info;
class siege_over;
class siege_skill_modify;
class king_skill_add;
class siege_random_trans;
class siege_flag_occupy;
class city_welfare_get_confirm;
class siege_call_info;
class siege_call_req;
class siege_call_rsp;
class siege_call_accept_req;
class siege_call;
class siege_call_accept_rsp;
class siege_call_status;
class siege_personal_info_req;
class siege_personal_info_rsp;
class siege_field_open;
class siege_start;
class siege_broadcast_msg;
class update_sculpture;
class kingdom_sculpture_info;
class kingdom_sculpture;

enum siege_enter_rsp_RET {
  siege_enter_rsp_RET_SUCCESS = 0,
  siege_enter_rsp_RET_FAILURE = 1,
  siege_enter_rsp_RET_SCENE_CLOSED = 2
};
bool siege_enter_rsp_RET_IsValid(int value);
const siege_enter_rsp_RET siege_enter_rsp_RET_RET_MIN = siege_enter_rsp_RET_SUCCESS;
const siege_enter_rsp_RET siege_enter_rsp_RET_RET_MAX = siege_enter_rsp_RET_SCENE_CLOSED;
const int siege_enter_rsp_RET_RET_ARRAYSIZE = siege_enter_rsp_RET_RET_MAX + 1;

const ::google::protobuf::EnumDescriptor* siege_enter_rsp_RET_descriptor();
inline const ::std::string& siege_enter_rsp_RET_Name(siege_enter_rsp_RET value) {
  return ::google::protobuf::internal::NameOfEnum(
    siege_enter_rsp_RET_descriptor(), value);
}
inline bool siege_enter_rsp_RET_Parse(
    const ::std::string& name, siege_enter_rsp_RET* value) {
  return ::google::protobuf::internal::ParseNamedEnum<siege_enter_rsp_RET>(
    siege_enter_rsp_RET_descriptor(), name, value);
}
enum siege_call_accept_rsp_RET {
  siege_call_accept_rsp_RET_SUCCESS = 0,
  siege_call_accept_rsp_RET_TIMEOUT = 1,
  siege_call_accept_rsp_RET_OUTSIDE = 2,
  siege_call_accept_rsp_RET_KING_OUTSIDE = 3,
  siege_call_accept_rsp_RET_NO_FAMILY = 4,
  siege_call_accept_rsp_RET_MY_CALL = 5,
  siege_call_accept_rsp_RET_DEAD = 6
};
bool siege_call_accept_rsp_RET_IsValid(int value);
const siege_call_accept_rsp_RET siege_call_accept_rsp_RET_RET_MIN = siege_call_accept_rsp_RET_SUCCESS;
const siege_call_accept_rsp_RET siege_call_accept_rsp_RET_RET_MAX = siege_call_accept_rsp_RET_DEAD;
const int siege_call_accept_rsp_RET_RET_ARRAYSIZE = siege_call_accept_rsp_RET_RET_MAX + 1;

const ::google::protobuf::EnumDescriptor* siege_call_accept_rsp_RET_descriptor();
inline const ::std::string& siege_call_accept_rsp_RET_Name(siege_call_accept_rsp_RET value) {
  return ::google::protobuf::internal::NameOfEnum(
    siege_call_accept_rsp_RET_descriptor(), value);
}
inline bool siege_call_accept_rsp_RET_Parse(
    const ::std::string& name, siege_call_accept_rsp_RET* value) {
  return ::google::protobuf::internal::ParseNamedEnum<siege_call_accept_rsp_RET>(
    siege_call_accept_rsp_RET_descriptor(), name, value);
}
enum CITY_OPT_ERR_NO_E {
  SUCCESS = 0,
  SIEGE_PROCEED = 1,
  KING_LIMIT = 2,
  NAME_EXIST = 3,
  NAME_TOO_LONG = 4,
  SIEGE_CLOSED = 5,
  ALREADY_ENTERED = 6,
  LV_LIMIT = 7,
  FAMILY_LIMIT = 8,
  OFFICIAL_LIMIT = 9,
  REWARD_GOT = 10,
  BAG_LIMIT = 11,
  CHIEF_LIMIT = 12,
  OCCUPY_REPEAT = 13,
  MONEY_LIMIT = 14,
  SIEGE_NOT_CLOSED = 15,
  TIME_LIMIT = 16,
  ROLE_DEAD = 17,
  CD_TIME = 18,
  NAME_MUST_CHINESE = 19,
  ILLEGAL_WORD = 20,
  FAILURE = 21
};
bool CITY_OPT_ERR_NO_E_IsValid(int value);
const CITY_OPT_ERR_NO_E CITY_OPT_ERR_NO_E_MIN = SUCCESS;
const CITY_OPT_ERR_NO_E CITY_OPT_ERR_NO_E_MAX = FAILURE;
const int CITY_OPT_ERR_NO_E_ARRAYSIZE = CITY_OPT_ERR_NO_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* CITY_OPT_ERR_NO_E_descriptor();
inline const ::std::string& CITY_OPT_ERR_NO_E_Name(CITY_OPT_ERR_NO_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    CITY_OPT_ERR_NO_E_descriptor(), value);
}
inline bool CITY_OPT_ERR_NO_E_Parse(
    const ::std::string& name, CITY_OPT_ERR_NO_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CITY_OPT_ERR_NO_E>(
    CITY_OPT_ERR_NO_E_descriptor(), name, value);
}
// ===================================================================

class official_info : public ::google::protobuf::Message {
 public:
  official_info();
  virtual ~official_info();

  official_info(const official_info& from);

  inline official_info& operator=(const official_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const official_info& default_instance();

  void Swap(official_info* other);

  // implements Message ----------------------------------------------

  official_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const official_info& from);
  void MergeFrom(const official_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // required uint32 pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // required uint32 sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // required string model_id = 5;
  inline bool has_model_id() const;
  inline void clear_model_id();
  static const int kModelIdFieldNumber = 5;
  inline const ::std::string& model_id() const;
  inline void set_model_id(const ::std::string& value);
  inline void set_model_id(const char* value);
  inline void set_model_id(const char* value, size_t size);
  inline ::std::string* mutable_model_id();
  inline ::std::string* release_model_id();
  inline void set_allocated_model_id(::std::string* model_id);

  // @@protoc_insertion_point(class_scope:client.official_info)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_model_id();
  inline void clear_has_model_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 pos_;
  ::std::string* model_id_;
  ::google::protobuf::uint32 sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static official_info* default_instance_;
};
// -------------------------------------------------------------------

class city_info_req : public ::google::protobuf::Message {
 public:
  city_info_req();
  virtual ~city_info_req();

  city_info_req(const city_info_req& from);

  inline city_info_req& operator=(const city_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_info_req& default_instance();

  void Swap(city_info_req* other);

  // implements Message ----------------------------------------------

  city_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_info_req& from);
  void MergeFrom(const city_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.city_info_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_info_req* default_instance_;
};
// -------------------------------------------------------------------

class city_info_rsp : public ::google::protobuf::Message {
 public:
  city_info_rsp();
  virtual ~city_info_rsp();

  city_info_rsp(const city_info_rsp& from);

  inline city_info_rsp& operator=(const city_info_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_info_rsp& default_instance();

  void Swap(city_info_rsp* other);

  // implements Message ----------------------------------------------

  city_info_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_info_rsp& from);
  void MergeFrom(const city_info_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool modify = 1 [default = false];
  inline bool has_modify() const;
  inline void clear_modify();
  static const int kModifyFieldNumber = 1;
  inline bool modify() const;
  inline void set_modify(bool value);

  // required uint32 open_time = 2;
  inline bool has_open_time() const;
  inline void clear_open_time();
  static const int kOpenTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 open_time() const;
  inline void set_open_time(::google::protobuf::uint32 value);

  // required uint32 last = 3;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 3;
  inline ::google::protobuf::uint32 last() const;
  inline void set_last(::google::protobuf::uint32 value);

  // repeated .client.official_info oi = 4;
  inline int oi_size() const;
  inline void clear_oi();
  static const int kOiFieldNumber = 4;
  inline const ::client::official_info& oi(int index) const;
  inline ::client::official_info* mutable_oi(int index);
  inline ::client::official_info* add_oi();
  inline const ::google::protobuf::RepeatedPtrField< ::client::official_info >&
      oi() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::official_info >*
      mutable_oi();

  // optional uint32 timelong = 5;
  inline bool has_timelong() const;
  inline void clear_timelong();
  static const int kTimelongFieldNumber = 5;
  inline ::google::protobuf::uint32 timelong() const;
  inline void set_timelong(::google::protobuf::uint32 value);

  // optional string family_name = 6;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 6;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional string title = 7;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 7;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // @@protoc_insertion_point(class_scope:client.city_info_rsp)
 private:
  inline void set_has_modify();
  inline void clear_has_modify();
  inline void set_has_open_time();
  inline void clear_has_open_time();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_timelong();
  inline void clear_has_timelong();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_title();
  inline void clear_has_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool modify_;
  ::google::protobuf::uint32 open_time_;
  ::google::protobuf::RepeatedPtrField< ::client::official_info > oi_;
  ::google::protobuf::uint32 last_;
  ::google::protobuf::uint32 timelong_;
  ::std::string* family_name_;
  ::std::string* title_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_info_rsp* default_instance_;
};
// -------------------------------------------------------------------

class city_mod_title_req : public ::google::protobuf::Message {
 public:
  city_mod_title_req();
  virtual ~city_mod_title_req();

  city_mod_title_req(const city_mod_title_req& from);

  inline city_mod_title_req& operator=(const city_mod_title_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_mod_title_req& default_instance();

  void Swap(city_mod_title_req* other);

  // implements Message ----------------------------------------------

  city_mod_title_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_mod_title_req& from);
  void MergeFrom(const city_mod_title_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string city_title = 1;
  inline bool has_city_title() const;
  inline void clear_city_title();
  static const int kCityTitleFieldNumber = 1;
  inline const ::std::string& city_title() const;
  inline void set_city_title(const ::std::string& value);
  inline void set_city_title(const char* value);
  inline void set_city_title(const char* value, size_t size);
  inline ::std::string* mutable_city_title();
  inline ::std::string* release_city_title();
  inline void set_allocated_city_title(::std::string* city_title);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.city_mod_title_req)
 private:
  inline void set_has_city_title();
  inline void clear_has_city_title();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* city_title_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_mod_title_req* default_instance_;
};
// -------------------------------------------------------------------

class city_mod_title_rsp : public ::google::protobuf::Message {
 public:
  city_mod_title_rsp();
  virtual ~city_mod_title_rsp();

  city_mod_title_rsp(const city_mod_title_rsp& from);

  inline city_mod_title_rsp& operator=(const city_mod_title_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_mod_title_rsp& default_instance();

  void Swap(city_mod_title_rsp* other);

  // implements Message ----------------------------------------------

  city_mod_title_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_mod_title_rsp& from);
  void MergeFrom(const city_mod_title_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.CITY_OPT_ERR_NO_E err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::client::CITY_OPT_ERR_NO_E err_no() const;
  inline void set_err_no(::client::CITY_OPT_ERR_NO_E value);

  // @@protoc_insertion_point(class_scope:client.city_mod_title_rsp)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_mod_title_rsp* default_instance_;
};
// -------------------------------------------------------------------

class city_welfare_info_req : public ::google::protobuf::Message {
 public:
  city_welfare_info_req();
  virtual ~city_welfare_info_req();

  city_welfare_info_req(const city_welfare_info_req& from);

  inline city_welfare_info_req& operator=(const city_welfare_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_welfare_info_req& default_instance();

  void Swap(city_welfare_info_req* other);

  // implements Message ----------------------------------------------

  city_welfare_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_welfare_info_req& from);
  void MergeFrom(const city_welfare_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.city_welfare_info_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_welfare_info_req* default_instance_;
};
// -------------------------------------------------------------------

class city_pos_reward : public ::google::protobuf::Message {
 public:
  city_pos_reward();
  virtual ~city_pos_reward();

  city_pos_reward(const city_pos_reward& from);

  inline city_pos_reward& operator=(const city_pos_reward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_pos_reward& default_instance();

  void Swap(city_pos_reward* other);

  // implements Message ----------------------------------------------

  city_pos_reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_pos_reward& from);
  void MergeFrom(const city_pos_reward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.city_pos_reward)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_pos_reward* default_instance_;
};
// -------------------------------------------------------------------

class city_welfare_info_rsp : public ::google::protobuf::Message {
 public:
  city_welfare_info_rsp();
  virtual ~city_welfare_info_rsp();

  city_welfare_info_rsp(const city_welfare_info_rsp& from);

  inline city_welfare_info_rsp& operator=(const city_welfare_info_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_welfare_info_rsp& default_instance();

  void Swap(city_welfare_info_rsp* other);

  // implements Message ----------------------------------------------

  city_welfare_info_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_welfare_info_rsp& from);
  void MergeFrom(const city_welfare_info_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // repeated .client.city_pos_reward cpr = 2;
  inline int cpr_size() const;
  inline void clear_cpr();
  static const int kCprFieldNumber = 2;
  inline const ::client::city_pos_reward& cpr(int index) const;
  inline ::client::city_pos_reward* mutable_cpr(int index);
  inline ::client::city_pos_reward* add_cpr();
  inline const ::google::protobuf::RepeatedPtrField< ::client::city_pos_reward >&
      cpr() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::city_pos_reward >*
      mutable_cpr();

  // optional uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.city_welfare_info_rsp)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::city_pos_reward > cpr_;
  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_welfare_info_rsp* default_instance_;
};
// -------------------------------------------------------------------

class city_welfare_get_req : public ::google::protobuf::Message {
 public:
  city_welfare_get_req();
  virtual ~city_welfare_get_req();

  city_welfare_get_req(const city_welfare_get_req& from);

  inline city_welfare_get_req& operator=(const city_welfare_get_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_welfare_get_req& default_instance();

  void Swap(city_welfare_get_req* other);

  // implements Message ----------------------------------------------

  city_welfare_get_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_welfare_get_req& from);
  void MergeFrom(const city_welfare_get_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.city_welfare_get_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_welfare_get_req* default_instance_;
};
// -------------------------------------------------------------------

class city_welfare_get_rsp : public ::google::protobuf::Message {
 public:
  city_welfare_get_rsp();
  virtual ~city_welfare_get_rsp();

  city_welfare_get_rsp(const city_welfare_get_rsp& from);

  inline city_welfare_get_rsp& operator=(const city_welfare_get_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_welfare_get_rsp& default_instance();

  void Swap(city_welfare_get_rsp* other);

  // implements Message ----------------------------------------------

  city_welfare_get_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_welfare_get_rsp& from);
  void MergeFrom(const city_welfare_get_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.CITY_OPT_ERR_NO_E err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::client::CITY_OPT_ERR_NO_E err_no() const;
  inline void set_err_no(::client::CITY_OPT_ERR_NO_E value);

  // @@protoc_insertion_point(class_scope:client.city_welfare_get_rsp)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_welfare_get_rsp* default_instance_;
};
// -------------------------------------------------------------------

class city_welfare_get_notify : public ::google::protobuf::Message {
 public:
  city_welfare_get_notify();
  virtual ~city_welfare_get_notify();

  city_welfare_get_notify(const city_welfare_get_notify& from);

  inline city_welfare_get_notify& operator=(const city_welfare_get_notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_welfare_get_notify& default_instance();

  void Swap(city_welfare_get_notify* other);

  // implements Message ----------------------------------------------

  city_welfare_get_notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_welfare_get_notify& from);
  void MergeFrom(const city_welfare_get_notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required uint32 props_id = 2;
  inline bool has_props_id() const;
  inline void clear_props_id();
  static const int kPropsIdFieldNumber = 2;
  inline ::google::protobuf::uint32 props_id() const;
  inline void set_props_id(::google::protobuf::uint32 value);

  // required int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.city_welfare_get_notify)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_props_id();
  inline void clear_has_props_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 props_id_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_welfare_get_notify* default_instance_;
};
// -------------------------------------------------------------------

class siege_enter_req : public ::google::protobuf::Message {
 public:
  siege_enter_req();
  virtual ~siege_enter_req();

  siege_enter_req(const siege_enter_req& from);

  inline siege_enter_req& operator=(const siege_enter_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_enter_req& default_instance();

  void Swap(siege_enter_req* other);

  // implements Message ----------------------------------------------

  siege_enter_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_enter_req& from);
  void MergeFrom(const siege_enter_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.siege_enter_req)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_enter_req* default_instance_;
};
// -------------------------------------------------------------------

class siege_enter_rsp : public ::google::protobuf::Message {
 public:
  siege_enter_rsp();
  virtual ~siege_enter_rsp();

  siege_enter_rsp(const siege_enter_rsp& from);

  inline siege_enter_rsp& operator=(const siege_enter_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_enter_rsp& default_instance();

  void Swap(siege_enter_rsp* other);

  // implements Message ----------------------------------------------

  siege_enter_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_enter_rsp& from);
  void MergeFrom(const siege_enter_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef siege_enter_rsp_RET RET;
  static const RET SUCCESS = siege_enter_rsp_RET_SUCCESS;
  static const RET FAILURE = siege_enter_rsp_RET_FAILURE;
  static const RET SCENE_CLOSED = siege_enter_rsp_RET_SCENE_CLOSED;
  static inline bool RET_IsValid(int value) {
    return siege_enter_rsp_RET_IsValid(value);
  }
  static const RET RET_MIN =
    siege_enter_rsp_RET_RET_MIN;
  static const RET RET_MAX =
    siege_enter_rsp_RET_RET_MAX;
  static const int RET_ARRAYSIZE =
    siege_enter_rsp_RET_RET_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RET_descriptor() {
    return siege_enter_rsp_RET_descriptor();
  }
  static inline const ::std::string& RET_Name(RET value) {
    return siege_enter_rsp_RET_Name(value);
  }
  static inline bool RET_Parse(const ::std::string& name,
      RET* value) {
    return siege_enter_rsp_RET_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.siege_enter_rsp.RET ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::siege_enter_rsp_RET ret() const;
  inline void set_ret(::client::siege_enter_rsp_RET value);

  // @@protoc_insertion_point(class_scope:client.siege_enter_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_enter_rsp* default_instance_;
};
// -------------------------------------------------------------------

class siege_enter_field : public ::google::protobuf::Message {
 public:
  siege_enter_field();
  virtual ~siege_enter_field();

  siege_enter_field(const siege_enter_field& from);

  inline siege_enter_field& operator=(const siege_enter_field& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_enter_field& default_instance();

  void Swap(siege_enter_field* other);

  // implements Message ----------------------------------------------

  siege_enter_field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_enter_field& from);
  void MergeFrom(const siege_enter_field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_enter_field)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_enter_field* default_instance_;
};
// -------------------------------------------------------------------

class siege_scene_camp_req : public ::google::protobuf::Message {
 public:
  siege_scene_camp_req();
  virtual ~siege_scene_camp_req();

  siege_scene_camp_req(const siege_scene_camp_req& from);

  inline siege_scene_camp_req& operator=(const siege_scene_camp_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_scene_camp_req& default_instance();

  void Swap(siege_scene_camp_req* other);

  // implements Message ----------------------------------------------

  siege_scene_camp_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_scene_camp_req& from);
  void MergeFrom(const siege_scene_camp_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.siege_scene_camp_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_scene_camp_req* default_instance_;
};
// -------------------------------------------------------------------

class siege_scene_camp : public ::google::protobuf::Message {
 public:
  siege_scene_camp();
  virtual ~siege_scene_camp();

  siege_scene_camp(const siege_scene_camp& from);

  inline siege_scene_camp& operator=(const siege_scene_camp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_scene_camp& default_instance();

  void Swap(siege_scene_camp* other);

  // implements Message ----------------------------------------------

  siege_scene_camp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_scene_camp& from);
  void MergeFrom(const siege_scene_camp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 camp = 1;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 1;
  inline ::google::protobuf::uint32 camp() const;
  inline void set_camp(::google::protobuf::uint32 value);

  // required uint32 open_time = 2;
  inline bool has_open_time() const;
  inline void clear_open_time();
  static const int kOpenTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 open_time() const;
  inline void set_open_time(::google::protobuf::uint32 value);

  // optional string family_name = 3;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 3;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional string user_name = 4;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 4;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional uint32 occupy_time = 5;
  inline bool has_occupy_time() const;
  inline void clear_occupy_time();
  static const int kOccupyTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 occupy_time() const;
  inline void set_occupy_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_scene_camp)
 private:
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_open_time();
  inline void clear_has_open_time();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_occupy_time();
  inline void clear_has_occupy_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 camp_;
  ::google::protobuf::uint32 open_time_;
  ::std::string* family_name_;
  ::std::string* user_name_;
  ::google::protobuf::uint32 occupy_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_scene_camp* default_instance_;
};
// -------------------------------------------------------------------

class siege_dead_msg_rsp : public ::google::protobuf::Message {
 public:
  siege_dead_msg_rsp();
  virtual ~siege_dead_msg_rsp();

  siege_dead_msg_rsp(const siege_dead_msg_rsp& from);

  inline siege_dead_msg_rsp& operator=(const siege_dead_msg_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_dead_msg_rsp& default_instance();

  void Swap(siege_dead_msg_rsp* other);

  // implements Message ----------------------------------------------

  siege_dead_msg_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_dead_msg_rsp& from);
  void MergeFrom(const siege_dead_msg_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string family_name = 2;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 2;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // @@protoc_insertion_point(class_scope:client.siege_dead_msg_rsp)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_family_name();
  inline void clear_has_family_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::std::string* family_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_dead_msg_rsp* default_instance_;
};
// -------------------------------------------------------------------

class siege_revive_req : public ::google::protobuf::Message {
 public:
  siege_revive_req();
  virtual ~siege_revive_req();

  siege_revive_req(const siege_revive_req& from);

  inline siege_revive_req& operator=(const siege_revive_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_revive_req& default_instance();

  void Swap(siege_revive_req* other);

  // implements Message ----------------------------------------------

  siege_revive_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_revive_req& from);
  void MergeFrom(const siege_revive_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.siege_revive_req)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_revive_req* default_instance_;
};
// -------------------------------------------------------------------

class siege_revive_rsp : public ::google::protobuf::Message {
 public:
  siege_revive_rsp();
  virtual ~siege_revive_rsp();

  siege_revive_rsp(const siege_revive_rsp& from);

  inline siege_revive_rsp& operator=(const siege_revive_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_revive_rsp& default_instance();

  void Swap(siege_revive_rsp* other);

  // implements Message ----------------------------------------------

  siege_revive_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_revive_rsp& from);
  void MergeFrom(const siege_revive_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_revive_rsp)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_revive_rsp* default_instance_;
};
// -------------------------------------------------------------------

class siege_status : public ::google::protobuf::Message {
 public:
  siege_status();
  virtual ~siege_status();

  siege_status(const siege_status& from);

  inline siege_status& operator=(const siege_status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_status& default_instance();

  void Swap(siege_status* other);

  // implements Message ----------------------------------------------

  siege_status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_status& from);
  void MergeFrom(const siege_status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_status)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_status* default_instance_;
};
// -------------------------------------------------------------------

class siege_status_rsp : public ::google::protobuf::Message {
 public:
  siege_status_rsp();
  virtual ~siege_status_rsp();

  siege_status_rsp(const siege_status_rsp& from);

  inline siege_status_rsp& operator=(const siege_status_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_status_rsp& default_instance();

  void Swap(siege_status_rsp* other);

  // implements Message ----------------------------------------------

  siege_status_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_status_rsp& from);
  void MergeFrom(const siege_status_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_status_rsp)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_status_rsp* default_instance_;
};
// -------------------------------------------------------------------

class siege_personal_info : public ::google::protobuf::Message {
 public:
  siege_personal_info();
  virtual ~siege_personal_info();

  siege_personal_info(const siege_personal_info& from);

  inline siege_personal_info& operator=(const siege_personal_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_personal_info& default_instance();

  void Swap(siege_personal_info* other);

  // implements Message ----------------------------------------------

  siege_personal_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_personal_info& from);
  void MergeFrom(const siege_personal_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // required uint32 cur_combo = 4;
  inline bool has_cur_combo() const;
  inline void clear_cur_combo();
  static const int kCurComboFieldNumber = 4;
  inline ::google::protobuf::uint32 cur_combo() const;
  inline void set_cur_combo(::google::protobuf::uint32 value);

  // required uint32 exp = 5 [default = 0];
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // required uint32 region = 6;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 6;
  inline ::google::protobuf::uint32 region() const;
  inline void set_region(::google::protobuf::uint32 value);

  // required uint32 timelong = 7 [default = 0];
  inline bool has_timelong() const;
  inline void clear_timelong();
  static const int kTimelongFieldNumber = 7;
  inline ::google::protobuf::uint32 timelong() const;
  inline void set_timelong(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_personal_info)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_tick();
  inline void clear_has_tick();
  inline void set_has_cur_combo();
  inline void clear_has_cur_combo();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_timelong();
  inline void clear_has_timelong();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 tick_;
  ::google::protobuf::uint32 cur_combo_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 region_;
  ::google::protobuf::uint32 timelong_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_personal_info* default_instance_;
};
// -------------------------------------------------------------------

class siege_over : public ::google::protobuf::Message {
 public:
  siege_over();
  virtual ~siege_over();

  siege_over(const siege_over& from);

  inline siege_over& operator=(const siege_over& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_over& default_instance();

  void Swap(siege_over* other);

  // implements Message ----------------------------------------------

  siege_over* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_over& from);
  void MergeFrom(const siege_over& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 family_id = 1;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 family_id() const;
  inline void set_family_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // repeated uint32 role = 3;
  inline int role_size() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 3;
  inline ::google::protobuf::uint32 role(int index) const;
  inline void set_role(int index, ::google::protobuf::uint32 value);
  inline void add_role(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      role() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_role();

  // @@protoc_insertion_point(class_scope:client.siege_over)
 private:
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 family_id_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_over* default_instance_;
};
// -------------------------------------------------------------------

class siege_skill_modify : public ::google::protobuf::Message {
 public:
  siege_skill_modify();
  virtual ~siege_skill_modify();

  siege_skill_modify(const siege_skill_modify& from);

  inline siege_skill_modify& operator=(const siege_skill_modify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_skill_modify& default_instance();

  void Swap(siege_skill_modify* other);

  // implements Message ----------------------------------------------

  siege_skill_modify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_skill_modify& from);
  void MergeFrom(const siege_skill_modify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // repeated uint32 id = 2;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::uint32 value);
  inline void add_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_id();

  // required uint32 op = 3;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 3;
  inline ::google::protobuf::uint32 op() const;
  inline void set_op(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_skill_modify)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_op();
  inline void clear_has_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > id_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 op_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_skill_modify* default_instance_;
};
// -------------------------------------------------------------------

class king_skill_add : public ::google::protobuf::Message {
 public:
  king_skill_add();
  virtual ~king_skill_add();

  king_skill_add(const king_skill_add& from);

  inline king_skill_add& operator=(const king_skill_add& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_skill_add& default_instance();

  void Swap(king_skill_add* other);

  // implements Message ----------------------------------------------

  king_skill_add* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_skill_add& from);
  void MergeFrom(const king_skill_add& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required uint32 family_id = 2;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 family_id() const;
  inline void set_family_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.king_skill_add)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_family_id();
  inline void clear_has_family_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 family_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static king_skill_add* default_instance_;
};
// -------------------------------------------------------------------

class siege_random_trans : public ::google::protobuf::Message {
 public:
  siege_random_trans();
  virtual ~siege_random_trans();

  siege_random_trans(const siege_random_trans& from);

  inline siege_random_trans& operator=(const siege_random_trans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_random_trans& default_instance();

  void Swap(siege_random_trans* other);

  // implements Message ----------------------------------------------

  siege_random_trans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_random_trans& from);
  void MergeFrom(const siege_random_trans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_random_trans)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_random_trans* default_instance_;
};
// -------------------------------------------------------------------

class siege_flag_occupy : public ::google::protobuf::Message {
 public:
  siege_flag_occupy();
  virtual ~siege_flag_occupy();

  siege_flag_occupy(const siege_flag_occupy& from);

  inline siege_flag_occupy& operator=(const siege_flag_occupy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_flag_occupy& default_instance();

  void Swap(siege_flag_occupy* other);

  // implements Message ----------------------------------------------

  siege_flag_occupy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_flag_occupy& from);
  void MergeFrom(const siege_flag_occupy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 old_family_id = 1;
  inline bool has_old_family_id() const;
  inline void clear_old_family_id();
  static const int kOldFamilyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 old_family_id() const;
  inline void set_old_family_id(::google::protobuf::uint32 value);

  // required uint32 new_family_id = 2;
  inline bool has_new_family_id() const;
  inline void clear_new_family_id();
  static const int kNewFamilyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 new_family_id() const;
  inline void set_new_family_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_flag_occupy)
 private:
  inline void set_has_old_family_id();
  inline void clear_has_old_family_id();
  inline void set_has_new_family_id();
  inline void clear_has_new_family_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 old_family_id_;
  ::google::protobuf::uint32 new_family_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_flag_occupy* default_instance_;
};
// -------------------------------------------------------------------

class city_welfare_get_confirm : public ::google::protobuf::Message {
 public:
  city_welfare_get_confirm();
  virtual ~city_welfare_get_confirm();

  city_welfare_get_confirm(const city_welfare_get_confirm& from);

  inline city_welfare_get_confirm& operator=(const city_welfare_get_confirm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_welfare_get_confirm& default_instance();

  void Swap(city_welfare_get_confirm* other);

  // implements Message ----------------------------------------------

  city_welfare_get_confirm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_welfare_get_confirm& from);
  void MergeFrom(const city_welfare_get_confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.city_welfare_get_confirm)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static city_welfare_get_confirm* default_instance_;
};
// -------------------------------------------------------------------

class siege_call_info : public ::google::protobuf::Message {
 public:
  siege_call_info();
  virtual ~siege_call_info();

  siege_call_info(const siege_call_info& from);

  inline siege_call_info& operator=(const siege_call_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_call_info& default_instance();

  void Swap(siege_call_info* other);

  // implements Message ----------------------------------------------

  siege_call_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_call_info& from);
  void MergeFrom(const siege_call_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 family_id = 1;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 family_id() const;
  inline void set_family_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_call_info)
 private:
  inline void set_has_family_id();
  inline void clear_has_family_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 family_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_call_info* default_instance_;
};
// -------------------------------------------------------------------

class siege_call_req : public ::google::protobuf::Message {
 public:
  siege_call_req();
  virtual ~siege_call_req();

  siege_call_req(const siege_call_req& from);

  inline siege_call_req& operator=(const siege_call_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_call_req& default_instance();

  void Swap(siege_call_req* other);

  // implements Message ----------------------------------------------

  siege_call_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_call_req& from);
  void MergeFrom(const siege_call_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.siege_call_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_call_req* default_instance_;
};
// -------------------------------------------------------------------

class siege_call_rsp : public ::google::protobuf::Message {
 public:
  siege_call_rsp();
  virtual ~siege_call_rsp();

  siege_call_rsp(const siege_call_rsp& from);

  inline siege_call_rsp& operator=(const siege_call_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_call_rsp& default_instance();

  void Swap(siege_call_rsp* other);

  // implements Message ----------------------------------------------

  siege_call_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_call_rsp& from);
  void MergeFrom(const siege_call_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.CITY_OPT_ERR_NO_E err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::client::CITY_OPT_ERR_NO_E err_no() const;
  inline void set_err_no(::client::CITY_OPT_ERR_NO_E value);

  // @@protoc_insertion_point(class_scope:client.siege_call_rsp)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_call_rsp* default_instance_;
};
// -------------------------------------------------------------------

class siege_call_accept_req : public ::google::protobuf::Message {
 public:
  siege_call_accept_req();
  virtual ~siege_call_accept_req();

  siege_call_accept_req(const siege_call_accept_req& from);

  inline siege_call_accept_req& operator=(const siege_call_accept_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_call_accept_req& default_instance();

  void Swap(siege_call_accept_req* other);

  // implements Message ----------------------------------------------

  siege_call_accept_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_call_accept_req& from);
  void MergeFrom(const siege_call_accept_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 family_id = 1;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 family_id() const;
  inline void set_family_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.siege_call_accept_req)
 private:
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 family_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_call_accept_req* default_instance_;
};
// -------------------------------------------------------------------

class siege_call : public ::google::protobuf::Message {
 public:
  siege_call();
  virtual ~siege_call();

  siege_call(const siege_call& from);

  inline siege_call& operator=(const siege_call& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_call& default_instance();

  void Swap(siege_call* other);

  // implements Message ----------------------------------------------

  siege_call* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_call& from);
  void MergeFrom(const siege_call& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required uint32 chief = 2;
  inline bool has_chief() const;
  inline void clear_chief();
  static const int kChiefFieldNumber = 2;
  inline ::google::protobuf::uint32 chief() const;
  inline void set_chief(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_call)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_chief();
  inline void clear_has_chief();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 chief_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_call* default_instance_;
};
// -------------------------------------------------------------------

class siege_call_accept_rsp : public ::google::protobuf::Message {
 public:
  siege_call_accept_rsp();
  virtual ~siege_call_accept_rsp();

  siege_call_accept_rsp(const siege_call_accept_rsp& from);

  inline siege_call_accept_rsp& operator=(const siege_call_accept_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_call_accept_rsp& default_instance();

  void Swap(siege_call_accept_rsp* other);

  // implements Message ----------------------------------------------

  siege_call_accept_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_call_accept_rsp& from);
  void MergeFrom(const siege_call_accept_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef siege_call_accept_rsp_RET RET;
  static const RET SUCCESS = siege_call_accept_rsp_RET_SUCCESS;
  static const RET TIMEOUT = siege_call_accept_rsp_RET_TIMEOUT;
  static const RET OUTSIDE = siege_call_accept_rsp_RET_OUTSIDE;
  static const RET KING_OUTSIDE = siege_call_accept_rsp_RET_KING_OUTSIDE;
  static const RET NO_FAMILY = siege_call_accept_rsp_RET_NO_FAMILY;
  static const RET MY_CALL = siege_call_accept_rsp_RET_MY_CALL;
  static const RET DEAD = siege_call_accept_rsp_RET_DEAD;
  static inline bool RET_IsValid(int value) {
    return siege_call_accept_rsp_RET_IsValid(value);
  }
  static const RET RET_MIN =
    siege_call_accept_rsp_RET_RET_MIN;
  static const RET RET_MAX =
    siege_call_accept_rsp_RET_RET_MAX;
  static const int RET_ARRAYSIZE =
    siege_call_accept_rsp_RET_RET_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RET_descriptor() {
    return siege_call_accept_rsp_RET_descriptor();
  }
  static inline const ::std::string& RET_Name(RET value) {
    return siege_call_accept_rsp_RET_Name(value);
  }
  static inline bool RET_Parse(const ::std::string& name,
      RET* value) {
    return siege_call_accept_rsp_RET_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.siege_call_accept_rsp.RET ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::siege_call_accept_rsp_RET ret() const;
  inline void set_ret(::client::siege_call_accept_rsp_RET value);

  // @@protoc_insertion_point(class_scope:client.siege_call_accept_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_call_accept_rsp* default_instance_;
};
// -------------------------------------------------------------------

class siege_call_status : public ::google::protobuf::Message {
 public:
  siege_call_status();
  virtual ~siege_call_status();

  siege_call_status(const siege_call_status& from);

  inline siege_call_status& operator=(const siege_call_status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_call_status& default_instance();

  void Swap(siege_call_status* other);

  // implements Message ----------------------------------------------

  siege_call_status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_call_status& from);
  void MergeFrom(const siege_call_status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_call_status)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_call_status* default_instance_;
};
// -------------------------------------------------------------------

class siege_personal_info_req : public ::google::protobuf::Message {
 public:
  siege_personal_info_req();
  virtual ~siege_personal_info_req();

  siege_personal_info_req(const siege_personal_info_req& from);

  inline siege_personal_info_req& operator=(const siege_personal_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_personal_info_req& default_instance();

  void Swap(siege_personal_info_req* other);

  // implements Message ----------------------------------------------

  siege_personal_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_personal_info_req& from);
  void MergeFrom(const siege_personal_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.siege_personal_info_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_personal_info_req* default_instance_;
};
// -------------------------------------------------------------------

class siege_personal_info_rsp : public ::google::protobuf::Message {
 public:
  siege_personal_info_rsp();
  virtual ~siege_personal_info_rsp();

  siege_personal_info_rsp(const siege_personal_info_rsp& from);

  inline siege_personal_info_rsp& operator=(const siege_personal_info_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_personal_info_rsp& default_instance();

  void Swap(siege_personal_info_rsp* other);

  // implements Message ----------------------------------------------

  siege_personal_info_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_personal_info_rsp& from);
  void MergeFrom(const siege_personal_info_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::google::protobuf::uint32 region() const;
  inline void set_region(::google::protobuf::uint32 value);

  // required uint32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // required uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 add = 4;
  inline bool has_add() const;
  inline void clear_add();
  static const int kAddFieldNumber = 4;
  inline ::google::protobuf::uint32 add() const;
  inline void set_add(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_personal_info_rsp)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_add();
  inline void clear_has_add();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 region_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 add_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_personal_info_rsp* default_instance_;
};
// -------------------------------------------------------------------

class siege_field_open : public ::google::protobuf::Message {
 public:
  siege_field_open();
  virtual ~siege_field_open();

  siege_field_open(const siege_field_open& from);

  inline siege_field_open& operator=(const siege_field_open& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_field_open& default_instance();

  void Swap(siege_field_open* other);

  // implements Message ----------------------------------------------

  siege_field_open* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_field_open& from);
  void MergeFrom(const siege_field_open& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.siege_field_open)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_field_open* default_instance_;
};
// -------------------------------------------------------------------

class siege_start : public ::google::protobuf::Message {
 public:
  siege_start();
  virtual ~siege_start();

  siege_start(const siege_start& from);

  inline siege_start& operator=(const siege_start& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_start& default_instance();

  void Swap(siege_start* other);

  // implements Message ----------------------------------------------

  siege_start* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_start& from);
  void MergeFrom(const siege_start& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 open_time = 1;
  inline bool has_open_time() const;
  inline void clear_open_time();
  static const int kOpenTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 open_time() const;
  inline void set_open_time(::google::protobuf::uint32 value);

  // required uint32 close_time = 2;
  inline bool has_close_time() const;
  inline void clear_close_time();
  static const int kCloseTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 close_time() const;
  inline void set_close_time(::google::protobuf::uint32 value);

  // optional uint32 family_id = 3;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 3;
  inline ::google::protobuf::uint32 family_id() const;
  inline void set_family_id(::google::protobuf::uint32 value);

  // optional uint32 occupy_time = 4;
  inline bool has_occupy_time() const;
  inline void clear_occupy_time();
  static const int kOccupyTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 occupy_time() const;
  inline void set_occupy_time(::google::protobuf::uint32 value);

  // repeated .client.family_simple_info fsi = 5;
  inline int fsi_size() const;
  inline void clear_fsi();
  static const int kFsiFieldNumber = 5;
  inline const ::client::family_simple_info& fsi(int index) const;
  inline ::client::family_simple_info* mutable_fsi(int index);
  inline ::client::family_simple_info* add_fsi();
  inline const ::google::protobuf::RepeatedPtrField< ::client::family_simple_info >&
      fsi() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::family_simple_info >*
      mutable_fsi();

  // @@protoc_insertion_point(class_scope:client.siege_start)
 private:
  inline void set_has_open_time();
  inline void clear_has_open_time();
  inline void set_has_close_time();
  inline void clear_has_close_time();
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_occupy_time();
  inline void clear_has_occupy_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 open_time_;
  ::google::protobuf::uint32 close_time_;
  ::google::protobuf::uint32 family_id_;
  ::google::protobuf::uint32 occupy_time_;
  ::google::protobuf::RepeatedPtrField< ::client::family_simple_info > fsi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_start* default_instance_;
};
// -------------------------------------------------------------------

class siege_broadcast_msg : public ::google::protobuf::Message {
 public:
  siege_broadcast_msg();
  virtual ~siege_broadcast_msg();

  siege_broadcast_msg(const siege_broadcast_msg& from);

  inline siege_broadcast_msg& operator=(const siege_broadcast_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const siege_broadcast_msg& default_instance();

  void Swap(siege_broadcast_msg* other);

  // implements Message ----------------------------------------------

  siege_broadcast_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const siege_broadcast_msg& from);
  void MergeFrom(const siege_broadcast_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:client.siege_broadcast_msg)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static siege_broadcast_msg* default_instance_;
};
// -------------------------------------------------------------------

class update_sculpture : public ::google::protobuf::Message {
 public:
  update_sculpture();
  virtual ~update_sculpture();

  update_sculpture(const update_sculpture& from);

  inline update_sculpture& operator=(const update_sculpture& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const update_sculpture& default_instance();

  void Swap(update_sculpture* other);

  // implements Message ----------------------------------------------

  update_sculpture* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const update_sculpture& from);
  void MergeFrom(const update_sculpture& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required string king = 2;
  inline bool has_king() const;
  inline void clear_king();
  static const int kKingFieldNumber = 2;
  inline const ::std::string& king() const;
  inline void set_king(const ::std::string& value);
  inline void set_king(const char* value);
  inline void set_king(const char* value, size_t size);
  inline ::std::string* mutable_king();
  inline ::std::string* release_king();
  inline void set_allocated_king(::std::string* king);

  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required string family_name = 4;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 4;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // @@protoc_insertion_point(class_scope:client.update_sculpture)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_king();
  inline void clear_has_king();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_family_name();
  inline void clear_has_family_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* king_;
  ::std::string* title_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static update_sculpture* default_instance_;
};
// -------------------------------------------------------------------

class kingdom_sculpture_info : public ::google::protobuf::Message {
 public:
  kingdom_sculpture_info();
  virtual ~kingdom_sculpture_info();

  kingdom_sculpture_info(const kingdom_sculpture_info& from);

  inline kingdom_sculpture_info& operator=(const kingdom_sculpture_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const kingdom_sculpture_info& default_instance();

  void Swap(kingdom_sculpture_info* other);

  // implements Message ----------------------------------------------

  kingdom_sculpture_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const kingdom_sculpture_info& from);
  void MergeFrom(const kingdom_sculpture_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required string king = 2;
  inline bool has_king() const;
  inline void clear_king();
  static const int kKingFieldNumber = 2;
  inline const ::std::string& king() const;
  inline void set_king(const ::std::string& value);
  inline void set_king(const char* value);
  inline void set_king(const char* value, size_t size);
  inline ::std::string* mutable_king();
  inline ::std::string* release_king();
  inline void set_allocated_king(::std::string* king);

  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required uint64 inst_id = 4;
  inline bool has_inst_id() const;
  inline void clear_inst_id();
  static const int kInstIdFieldNumber = 4;
  inline ::google::protobuf::uint64 inst_id() const;
  inline void set_inst_id(::google::protobuf::uint64 value);

  // required uint32 x = 5;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 6;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 6;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // required string family_name = 7;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 7;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // @@protoc_insertion_point(class_scope:client.kingdom_sculpture_info)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_king();
  inline void clear_has_king();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_inst_id();
  inline void clear_has_inst_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_family_name();
  inline void clear_has_family_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* king_;
  ::std::string* title_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint64 inst_id_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static kingdom_sculpture_info* default_instance_;
};
// -------------------------------------------------------------------

class kingdom_sculpture : public ::google::protobuf::Message {
 public:
  kingdom_sculpture();
  virtual ~kingdom_sculpture();

  kingdom_sculpture(const kingdom_sculpture& from);

  inline kingdom_sculpture& operator=(const kingdom_sculpture& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const kingdom_sculpture& default_instance();

  void Swap(kingdom_sculpture* other);

  // implements Message ----------------------------------------------

  kingdom_sculpture* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const kingdom_sculpture& from);
  void MergeFrom(const kingdom_sculpture& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.kingdom_sculpture_info ksi = 1;
  inline int ksi_size() const;
  inline void clear_ksi();
  static const int kKsiFieldNumber = 1;
  inline const ::client::kingdom_sculpture_info& ksi(int index) const;
  inline ::client::kingdom_sculpture_info* mutable_ksi(int index);
  inline ::client::kingdom_sculpture_info* add_ksi();
  inline const ::google::protobuf::RepeatedPtrField< ::client::kingdom_sculpture_info >&
      ksi() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::kingdom_sculpture_info >*
      mutable_ksi();

  // @@protoc_insertion_point(class_scope:client.kingdom_sculpture)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::kingdom_sculpture_info > ksi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2ecity_2eproto();
  friend void protobuf_AssignDesc_client_2ecity_2eproto();
  friend void protobuf_ShutdownFile_client_2ecity_2eproto();

  void InitAsDefaultInstance();
  static kingdom_sculpture* default_instance_;
};
// ===================================================================


// ===================================================================

// official_info

// required uint32 role_id = 1;
inline bool official_info::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void official_info::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void official_info::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void official_info::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 official_info::role_id() const {
  return role_id_;
}
inline void official_info::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required string role_name = 2;
inline bool official_info::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void official_info::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void official_info::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void official_info::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& official_info::role_name() const {
  return *role_name_;
}
inline void official_info::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void official_info::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void official_info::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* official_info::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* official_info::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void official_info::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 pos = 3;
inline bool official_info::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void official_info::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void official_info::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void official_info::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 official_info::pos() const {
  return pos_;
}
inline void official_info::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// required uint32 sex = 4;
inline bool official_info::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void official_info::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void official_info::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void official_info::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 official_info::sex() const {
  return sex_;
}
inline void official_info::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// required string model_id = 5;
inline bool official_info::has_model_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void official_info::set_has_model_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void official_info::clear_has_model_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void official_info::clear_model_id() {
  if (model_id_ != &::google::protobuf::internal::kEmptyString) {
    model_id_->clear();
  }
  clear_has_model_id();
}
inline const ::std::string& official_info::model_id() const {
  return *model_id_;
}
inline void official_info::set_model_id(const ::std::string& value) {
  set_has_model_id();
  if (model_id_ == &::google::protobuf::internal::kEmptyString) {
    model_id_ = new ::std::string;
  }
  model_id_->assign(value);
}
inline void official_info::set_model_id(const char* value) {
  set_has_model_id();
  if (model_id_ == &::google::protobuf::internal::kEmptyString) {
    model_id_ = new ::std::string;
  }
  model_id_->assign(value);
}
inline void official_info::set_model_id(const char* value, size_t size) {
  set_has_model_id();
  if (model_id_ == &::google::protobuf::internal::kEmptyString) {
    model_id_ = new ::std::string;
  }
  model_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* official_info::mutable_model_id() {
  set_has_model_id();
  if (model_id_ == &::google::protobuf::internal::kEmptyString) {
    model_id_ = new ::std::string;
  }
  return model_id_;
}
inline ::std::string* official_info::release_model_id() {
  clear_has_model_id();
  if (model_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_id_;
    model_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void official_info::set_allocated_model_id(::std::string* model_id) {
  if (model_id_ != &::google::protobuf::internal::kEmptyString) {
    delete model_id_;
  }
  if (model_id) {
    set_has_model_id();
    model_id_ = model_id;
  } else {
    clear_has_model_id();
    model_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// city_info_req

// required uint32 role_id = 1;
inline bool city_info_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_info_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_info_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_info_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 city_info_req::role_id() const {
  return role_id_;
}
inline void city_info_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool city_info_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_info_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_info_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_info_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& city_info_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* city_info_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* city_info_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void city_info_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// city_info_rsp

// required bool modify = 1 [default = false];
inline bool city_info_rsp::has_modify() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_info_rsp::set_has_modify() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_info_rsp::clear_has_modify() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_info_rsp::clear_modify() {
  modify_ = false;
  clear_has_modify();
}
inline bool city_info_rsp::modify() const {
  return modify_;
}
inline void city_info_rsp::set_modify(bool value) {
  set_has_modify();
  modify_ = value;
}

// required uint32 open_time = 2;
inline bool city_info_rsp::has_open_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_info_rsp::set_has_open_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_info_rsp::clear_has_open_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_info_rsp::clear_open_time() {
  open_time_ = 0u;
  clear_has_open_time();
}
inline ::google::protobuf::uint32 city_info_rsp::open_time() const {
  return open_time_;
}
inline void city_info_rsp::set_open_time(::google::protobuf::uint32 value) {
  set_has_open_time();
  open_time_ = value;
}

// required uint32 last = 3;
inline bool city_info_rsp::has_last() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_info_rsp::set_has_last() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_info_rsp::clear_has_last() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_info_rsp::clear_last() {
  last_ = 0u;
  clear_has_last();
}
inline ::google::protobuf::uint32 city_info_rsp::last() const {
  return last_;
}
inline void city_info_rsp::set_last(::google::protobuf::uint32 value) {
  set_has_last();
  last_ = value;
}

// repeated .client.official_info oi = 4;
inline int city_info_rsp::oi_size() const {
  return oi_.size();
}
inline void city_info_rsp::clear_oi() {
  oi_.Clear();
}
inline const ::client::official_info& city_info_rsp::oi(int index) const {
  return oi_.Get(index);
}
inline ::client::official_info* city_info_rsp::mutable_oi(int index) {
  return oi_.Mutable(index);
}
inline ::client::official_info* city_info_rsp::add_oi() {
  return oi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::official_info >&
city_info_rsp::oi() const {
  return oi_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::official_info >*
city_info_rsp::mutable_oi() {
  return &oi_;
}

// optional uint32 timelong = 5;
inline bool city_info_rsp::has_timelong() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void city_info_rsp::set_has_timelong() {
  _has_bits_[0] |= 0x00000010u;
}
inline void city_info_rsp::clear_has_timelong() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void city_info_rsp::clear_timelong() {
  timelong_ = 0u;
  clear_has_timelong();
}
inline ::google::protobuf::uint32 city_info_rsp::timelong() const {
  return timelong_;
}
inline void city_info_rsp::set_timelong(::google::protobuf::uint32 value) {
  set_has_timelong();
  timelong_ = value;
}

// optional string family_name = 6;
inline bool city_info_rsp::has_family_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void city_info_rsp::set_has_family_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void city_info_rsp::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void city_info_rsp::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& city_info_rsp::family_name() const {
  return *family_name_;
}
inline void city_info_rsp::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void city_info_rsp::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void city_info_rsp::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* city_info_rsp::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* city_info_rsp::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void city_info_rsp::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string title = 7;
inline bool city_info_rsp::has_title() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void city_info_rsp::set_has_title() {
  _has_bits_[0] |= 0x00000040u;
}
inline void city_info_rsp::clear_has_title() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void city_info_rsp::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& city_info_rsp::title() const {
  return *title_;
}
inline void city_info_rsp::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void city_info_rsp::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void city_info_rsp::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* city_info_rsp::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* city_info_rsp::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void city_info_rsp::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// city_mod_title_req

// required string city_title = 1;
inline bool city_mod_title_req::has_city_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_mod_title_req::set_has_city_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_mod_title_req::clear_has_city_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_mod_title_req::clear_city_title() {
  if (city_title_ != &::google::protobuf::internal::kEmptyString) {
    city_title_->clear();
  }
  clear_has_city_title();
}
inline const ::std::string& city_mod_title_req::city_title() const {
  return *city_title_;
}
inline void city_mod_title_req::set_city_title(const ::std::string& value) {
  set_has_city_title();
  if (city_title_ == &::google::protobuf::internal::kEmptyString) {
    city_title_ = new ::std::string;
  }
  city_title_->assign(value);
}
inline void city_mod_title_req::set_city_title(const char* value) {
  set_has_city_title();
  if (city_title_ == &::google::protobuf::internal::kEmptyString) {
    city_title_ = new ::std::string;
  }
  city_title_->assign(value);
}
inline void city_mod_title_req::set_city_title(const char* value, size_t size) {
  set_has_city_title();
  if (city_title_ == &::google::protobuf::internal::kEmptyString) {
    city_title_ = new ::std::string;
  }
  city_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* city_mod_title_req::mutable_city_title() {
  set_has_city_title();
  if (city_title_ == &::google::protobuf::internal::kEmptyString) {
    city_title_ = new ::std::string;
  }
  return city_title_;
}
inline ::std::string* city_mod_title_req::release_city_title() {
  clear_has_city_title();
  if (city_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_title_;
    city_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void city_mod_title_req::set_allocated_city_title(::std::string* city_title) {
  if (city_title_ != &::google::protobuf::internal::kEmptyString) {
    delete city_title_;
  }
  if (city_title) {
    set_has_city_title();
    city_title_ = city_title;
  } else {
    clear_has_city_title();
    city_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .client.server_head svr_head = 1000;
inline bool city_mod_title_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_mod_title_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_mod_title_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_mod_title_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& city_mod_title_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* city_mod_title_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* city_mod_title_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void city_mod_title_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// city_mod_title_rsp

// required .client.CITY_OPT_ERR_NO_E err_no = 1;
inline bool city_mod_title_rsp::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_mod_title_rsp::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_mod_title_rsp::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_mod_title_rsp::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::client::CITY_OPT_ERR_NO_E city_mod_title_rsp::err_no() const {
  return static_cast< ::client::CITY_OPT_ERR_NO_E >(err_no_);
}
inline void city_mod_title_rsp::set_err_no(::client::CITY_OPT_ERR_NO_E value) {
  assert(::client::CITY_OPT_ERR_NO_E_IsValid(value));
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// city_welfare_info_req

// required uint32 role_id = 1;
inline bool city_welfare_info_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_welfare_info_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_welfare_info_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_welfare_info_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 city_welfare_info_req::role_id() const {
  return role_id_;
}
inline void city_welfare_info_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool city_welfare_info_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_welfare_info_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_welfare_info_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_welfare_info_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& city_welfare_info_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* city_welfare_info_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* city_welfare_info_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void city_welfare_info_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// city_pos_reward

// required uint32 pos = 1;
inline bool city_pos_reward::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_pos_reward::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_pos_reward::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_pos_reward::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 city_pos_reward::pos() const {
  return pos_;
}
inline void city_pos_reward::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// required uint32 id = 2;
inline bool city_pos_reward::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_pos_reward::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_pos_reward::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_pos_reward::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 city_pos_reward::id() const {
  return id_;
}
inline void city_pos_reward::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 num = 3;
inline bool city_pos_reward::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_pos_reward::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_pos_reward::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_pos_reward::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 city_pos_reward::num() const {
  return num_;
}
inline void city_pos_reward::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// city_welfare_info_rsp

// required uint32 pos = 1;
inline bool city_welfare_info_rsp::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_welfare_info_rsp::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_welfare_info_rsp::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_welfare_info_rsp::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 city_welfare_info_rsp::pos() const {
  return pos_;
}
inline void city_welfare_info_rsp::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// repeated .client.city_pos_reward cpr = 2;
inline int city_welfare_info_rsp::cpr_size() const {
  return cpr_.size();
}
inline void city_welfare_info_rsp::clear_cpr() {
  cpr_.Clear();
}
inline const ::client::city_pos_reward& city_welfare_info_rsp::cpr(int index) const {
  return cpr_.Get(index);
}
inline ::client::city_pos_reward* city_welfare_info_rsp::mutable_cpr(int index) {
  return cpr_.Mutable(index);
}
inline ::client::city_pos_reward* city_welfare_info_rsp::add_cpr() {
  return cpr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::city_pos_reward >&
city_welfare_info_rsp::cpr() const {
  return cpr_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::city_pos_reward >*
city_welfare_info_rsp::mutable_cpr() {
  return &cpr_;
}

// optional uint32 status = 3;
inline bool city_welfare_info_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_welfare_info_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_welfare_info_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_welfare_info_rsp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 city_welfare_info_rsp::status() const {
  return status_;
}
inline void city_welfare_info_rsp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// city_welfare_get_req

// required uint32 role_id = 1;
inline bool city_welfare_get_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_welfare_get_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_welfare_get_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_welfare_get_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 city_welfare_get_req::role_id() const {
  return role_id_;
}
inline void city_welfare_get_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool city_welfare_get_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_welfare_get_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_welfare_get_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_welfare_get_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& city_welfare_get_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* city_welfare_get_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* city_welfare_get_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void city_welfare_get_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// city_welfare_get_rsp

// required .client.CITY_OPT_ERR_NO_E err_no = 1;
inline bool city_welfare_get_rsp::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_welfare_get_rsp::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_welfare_get_rsp::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_welfare_get_rsp::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::client::CITY_OPT_ERR_NO_E city_welfare_get_rsp::err_no() const {
  return static_cast< ::client::CITY_OPT_ERR_NO_E >(err_no_);
}
inline void city_welfare_get_rsp::set_err_no(::client::CITY_OPT_ERR_NO_E value) {
  assert(::client::CITY_OPT_ERR_NO_E_IsValid(value));
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// city_welfare_get_notify

// required uint32 role_id = 1;
inline bool city_welfare_get_notify::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_welfare_get_notify::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_welfare_get_notify::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_welfare_get_notify::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 city_welfare_get_notify::role_id() const {
  return role_id_;
}
inline void city_welfare_get_notify::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required uint32 props_id = 2;
inline bool city_welfare_get_notify::has_props_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_welfare_get_notify::set_has_props_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_welfare_get_notify::clear_has_props_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_welfare_get_notify::clear_props_id() {
  props_id_ = 0u;
  clear_has_props_id();
}
inline ::google::protobuf::uint32 city_welfare_get_notify::props_id() const {
  return props_id_;
}
inline void city_welfare_get_notify::set_props_id(::google::protobuf::uint32 value) {
  set_has_props_id();
  props_id_ = value;
}

// required int32 num = 3;
inline bool city_welfare_get_notify::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_welfare_get_notify::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_welfare_get_notify::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_welfare_get_notify::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 city_welfare_get_notify::num() const {
  return num_;
}
inline void city_welfare_get_notify::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// siege_enter_req

// required uint32 unixtime = 1;
inline bool siege_enter_req::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_enter_req::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_enter_req::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_enter_req::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 siege_enter_req::unixtime() const {
  return unixtime_;
}
inline void siege_enter_req::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool siege_enter_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_enter_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_enter_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_enter_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& siege_enter_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* siege_enter_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* siege_enter_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void siege_enter_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// siege_enter_rsp

// required .client.siege_enter_rsp.RET ret = 1;
inline bool siege_enter_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_enter_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_enter_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_enter_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::siege_enter_rsp_RET siege_enter_rsp::ret() const {
  return static_cast< ::client::siege_enter_rsp_RET >(ret_);
}
inline void siege_enter_rsp::set_ret(::client::siege_enter_rsp_RET value) {
  assert(::client::siege_enter_rsp_RET_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// siege_enter_field

// required uint32 role_id = 1;
inline bool siege_enter_field::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_enter_field::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_enter_field::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_enter_field::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 siege_enter_field::role_id() const {
  return role_id_;
}
inline void siege_enter_field::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// -------------------------------------------------------------------

// siege_scene_camp_req

// required uint32 time = 1;
inline bool siege_scene_camp_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_scene_camp_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_scene_camp_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_scene_camp_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 siege_scene_camp_req::time() const {
  return time_;
}
inline void siege_scene_camp_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool siege_scene_camp_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_scene_camp_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_scene_camp_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_scene_camp_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& siege_scene_camp_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* siege_scene_camp_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* siege_scene_camp_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void siege_scene_camp_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// siege_scene_camp

// required uint32 camp = 1;
inline bool siege_scene_camp::has_camp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_scene_camp::set_has_camp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_scene_camp::clear_has_camp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_scene_camp::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 siege_scene_camp::camp() const {
  return camp_;
}
inline void siege_scene_camp::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
}

// required uint32 open_time = 2;
inline bool siege_scene_camp::has_open_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_scene_camp::set_has_open_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_scene_camp::clear_has_open_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_scene_camp::clear_open_time() {
  open_time_ = 0u;
  clear_has_open_time();
}
inline ::google::protobuf::uint32 siege_scene_camp::open_time() const {
  return open_time_;
}
inline void siege_scene_camp::set_open_time(::google::protobuf::uint32 value) {
  set_has_open_time();
  open_time_ = value;
}

// optional string family_name = 3;
inline bool siege_scene_camp::has_family_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void siege_scene_camp::set_has_family_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void siege_scene_camp::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void siege_scene_camp::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& siege_scene_camp::family_name() const {
  return *family_name_;
}
inline void siege_scene_camp::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void siege_scene_camp::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void siege_scene_camp::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* siege_scene_camp::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* siege_scene_camp::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void siege_scene_camp::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_name = 4;
inline bool siege_scene_camp::has_user_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void siege_scene_camp::set_has_user_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void siege_scene_camp::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void siege_scene_camp::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& siege_scene_camp::user_name() const {
  return *user_name_;
}
inline void siege_scene_camp::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void siege_scene_camp::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void siege_scene_camp::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* siege_scene_camp::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* siege_scene_camp::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void siege_scene_camp::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 occupy_time = 5;
inline bool siege_scene_camp::has_occupy_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void siege_scene_camp::set_has_occupy_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void siege_scene_camp::clear_has_occupy_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void siege_scene_camp::clear_occupy_time() {
  occupy_time_ = 0u;
  clear_has_occupy_time();
}
inline ::google::protobuf::uint32 siege_scene_camp::occupy_time() const {
  return occupy_time_;
}
inline void siege_scene_camp::set_occupy_time(::google::protobuf::uint32 value) {
  set_has_occupy_time();
  occupy_time_ = value;
}

// -------------------------------------------------------------------

// siege_dead_msg_rsp

// required string user_name = 1;
inline bool siege_dead_msg_rsp::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_dead_msg_rsp::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_dead_msg_rsp::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_dead_msg_rsp::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& siege_dead_msg_rsp::user_name() const {
  return *user_name_;
}
inline void siege_dead_msg_rsp::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void siege_dead_msg_rsp::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void siege_dead_msg_rsp::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* siege_dead_msg_rsp::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* siege_dead_msg_rsp::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void siege_dead_msg_rsp::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string family_name = 2;
inline bool siege_dead_msg_rsp::has_family_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_dead_msg_rsp::set_has_family_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_dead_msg_rsp::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_dead_msg_rsp::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& siege_dead_msg_rsp::family_name() const {
  return *family_name_;
}
inline void siege_dead_msg_rsp::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void siege_dead_msg_rsp::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void siege_dead_msg_rsp::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* siege_dead_msg_rsp::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* siege_dead_msg_rsp::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void siege_dead_msg_rsp::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// siege_revive_req

// required uint32 unixtime = 1;
inline bool siege_revive_req::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_revive_req::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_revive_req::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_revive_req::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 siege_revive_req::unixtime() const {
  return unixtime_;
}
inline void siege_revive_req::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool siege_revive_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_revive_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_revive_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_revive_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& siege_revive_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* siege_revive_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* siege_revive_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void siege_revive_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// siege_revive_rsp

// required uint32 unixtime = 1;
inline bool siege_revive_rsp::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_revive_rsp::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_revive_rsp::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_revive_rsp::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 siege_revive_rsp::unixtime() const {
  return unixtime_;
}
inline void siege_revive_rsp::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// -------------------------------------------------------------------

// siege_status

// required uint32 role_id = 1;
inline bool siege_status::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_status::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_status::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_status::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 siege_status::role_id() const {
  return role_id_;
}
inline void siege_status::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// -------------------------------------------------------------------

// siege_status_rsp

// required uint32 status = 1;
inline bool siege_status_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_status_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_status_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_status_rsp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 siege_status_rsp::status() const {
  return status_;
}
inline void siege_status_rsp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// siege_personal_info

// required uint32 role_id = 1;
inline bool siege_personal_info::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_personal_info::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_personal_info::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_personal_info::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 siege_personal_info::role_id() const {
  return role_id_;
}
inline void siege_personal_info::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required string user_name = 2;
inline bool siege_personal_info::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_personal_info::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_personal_info::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_personal_info::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& siege_personal_info::user_name() const {
  return *user_name_;
}
inline void siege_personal_info::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void siege_personal_info::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void siege_personal_info::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* siege_personal_info::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* siege_personal_info::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void siege_personal_info::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 tick = 3;
inline bool siege_personal_info::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void siege_personal_info::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void siege_personal_info::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void siege_personal_info::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 siege_personal_info::tick() const {
  return tick_;
}
inline void siege_personal_info::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// required uint32 cur_combo = 4;
inline bool siege_personal_info::has_cur_combo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void siege_personal_info::set_has_cur_combo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void siege_personal_info::clear_has_cur_combo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void siege_personal_info::clear_cur_combo() {
  cur_combo_ = 0u;
  clear_has_cur_combo();
}
inline ::google::protobuf::uint32 siege_personal_info::cur_combo() const {
  return cur_combo_;
}
inline void siege_personal_info::set_cur_combo(::google::protobuf::uint32 value) {
  set_has_cur_combo();
  cur_combo_ = value;
}

// required uint32 exp = 5 [default = 0];
inline bool siege_personal_info::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void siege_personal_info::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void siege_personal_info::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void siege_personal_info::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 siege_personal_info::exp() const {
  return exp_;
}
inline void siege_personal_info::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 region = 6;
inline bool siege_personal_info::has_region() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void siege_personal_info::set_has_region() {
  _has_bits_[0] |= 0x00000020u;
}
inline void siege_personal_info::clear_has_region() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void siege_personal_info::clear_region() {
  region_ = 0u;
  clear_has_region();
}
inline ::google::protobuf::uint32 siege_personal_info::region() const {
  return region_;
}
inline void siege_personal_info::set_region(::google::protobuf::uint32 value) {
  set_has_region();
  region_ = value;
}

// required uint32 timelong = 7 [default = 0];
inline bool siege_personal_info::has_timelong() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void siege_personal_info::set_has_timelong() {
  _has_bits_[0] |= 0x00000040u;
}
inline void siege_personal_info::clear_has_timelong() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void siege_personal_info::clear_timelong() {
  timelong_ = 0u;
  clear_has_timelong();
}
inline ::google::protobuf::uint32 siege_personal_info::timelong() const {
  return timelong_;
}
inline void siege_personal_info::set_timelong(::google::protobuf::uint32 value) {
  set_has_timelong();
  timelong_ = value;
}

// -------------------------------------------------------------------

// siege_over

// required uint32 family_id = 1;
inline bool siege_over::has_family_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_over::set_has_family_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_over::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_over::clear_family_id() {
  family_id_ = 0u;
  clear_has_family_id();
}
inline ::google::protobuf::uint32 siege_over::family_id() const {
  return family_id_;
}
inline void siege_over::set_family_id(::google::protobuf::uint32 value) {
  set_has_family_id();
  family_id_ = value;
}

// required uint32 msg_id = 2;
inline bool siege_over::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_over::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_over::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_over::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 siege_over::msg_id() const {
  return msg_id_;
}
inline void siege_over::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// repeated uint32 role = 3;
inline int siege_over::role_size() const {
  return role_.size();
}
inline void siege_over::clear_role() {
  role_.Clear();
}
inline ::google::protobuf::uint32 siege_over::role(int index) const {
  return role_.Get(index);
}
inline void siege_over::set_role(int index, ::google::protobuf::uint32 value) {
  role_.Set(index, value);
}
inline void siege_over::add_role(::google::protobuf::uint32 value) {
  role_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
siege_over::role() const {
  return role_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
siege_over::mutable_role() {
  return &role_;
}

// -------------------------------------------------------------------

// siege_skill_modify

// required uint32 role_id = 1;
inline bool siege_skill_modify::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_skill_modify::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_skill_modify::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_skill_modify::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 siege_skill_modify::role_id() const {
  return role_id_;
}
inline void siege_skill_modify::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// repeated uint32 id = 2;
inline int siege_skill_modify::id_size() const {
  return id_.size();
}
inline void siege_skill_modify::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::uint32 siege_skill_modify::id(int index) const {
  return id_.Get(index);
}
inline void siege_skill_modify::set_id(int index, ::google::protobuf::uint32 value) {
  id_.Set(index, value);
}
inline void siege_skill_modify::add_id(::google::protobuf::uint32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
siege_skill_modify::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
siege_skill_modify::mutable_id() {
  return &id_;
}

// required uint32 op = 3;
inline bool siege_skill_modify::has_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void siege_skill_modify::set_has_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void siege_skill_modify::clear_has_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void siege_skill_modify::clear_op() {
  op_ = 0u;
  clear_has_op();
}
inline ::google::protobuf::uint32 siege_skill_modify::op() const {
  return op_;
}
inline void siege_skill_modify::set_op(::google::protobuf::uint32 value) {
  set_has_op();
  op_ = value;
}

// -------------------------------------------------------------------

// king_skill_add

// required uint32 role_id = 1;
inline bool king_skill_add::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_skill_add::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_skill_add::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_skill_add::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 king_skill_add::role_id() const {
  return role_id_;
}
inline void king_skill_add::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required uint32 family_id = 2;
inline bool king_skill_add::has_family_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_skill_add::set_has_family_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_skill_add::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_skill_add::clear_family_id() {
  family_id_ = 0u;
  clear_has_family_id();
}
inline ::google::protobuf::uint32 king_skill_add::family_id() const {
  return family_id_;
}
inline void king_skill_add::set_family_id(::google::protobuf::uint32 value) {
  set_has_family_id();
  family_id_ = value;
}

// -------------------------------------------------------------------

// siege_random_trans

// required uint32 unixtime = 1;
inline bool siege_random_trans::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_random_trans::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_random_trans::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_random_trans::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 siege_random_trans::unixtime() const {
  return unixtime_;
}
inline void siege_random_trans::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// -------------------------------------------------------------------

// siege_flag_occupy

// required uint32 old_family_id = 1;
inline bool siege_flag_occupy::has_old_family_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_flag_occupy::set_has_old_family_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_flag_occupy::clear_has_old_family_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_flag_occupy::clear_old_family_id() {
  old_family_id_ = 0u;
  clear_has_old_family_id();
}
inline ::google::protobuf::uint32 siege_flag_occupy::old_family_id() const {
  return old_family_id_;
}
inline void siege_flag_occupy::set_old_family_id(::google::protobuf::uint32 value) {
  set_has_old_family_id();
  old_family_id_ = value;
}

// required uint32 new_family_id = 2;
inline bool siege_flag_occupy::has_new_family_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_flag_occupy::set_has_new_family_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_flag_occupy::clear_has_new_family_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_flag_occupy::clear_new_family_id() {
  new_family_id_ = 0u;
  clear_has_new_family_id();
}
inline ::google::protobuf::uint32 siege_flag_occupy::new_family_id() const {
  return new_family_id_;
}
inline void siege_flag_occupy::set_new_family_id(::google::protobuf::uint32 value) {
  set_has_new_family_id();
  new_family_id_ = value;
}

// -------------------------------------------------------------------

// city_welfare_get_confirm

// required uint32 role_id = 1;
inline bool city_welfare_get_confirm::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_welfare_get_confirm::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_welfare_get_confirm::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_welfare_get_confirm::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 city_welfare_get_confirm::role_id() const {
  return role_id_;
}
inline void city_welfare_get_confirm::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// -------------------------------------------------------------------

// siege_call_info

// required uint32 family_id = 1;
inline bool siege_call_info::has_family_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_call_info::set_has_family_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_call_info::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_call_info::clear_family_id() {
  family_id_ = 0u;
  clear_has_family_id();
}
inline ::google::protobuf::uint32 siege_call_info::family_id() const {
  return family_id_;
}
inline void siege_call_info::set_family_id(::google::protobuf::uint32 value) {
  set_has_family_id();
  family_id_ = value;
}

// -------------------------------------------------------------------

// siege_call_req

// required uint32 time = 1;
inline bool siege_call_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_call_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_call_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_call_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 siege_call_req::time() const {
  return time_;
}
inline void siege_call_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool siege_call_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_call_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_call_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_call_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& siege_call_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* siege_call_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* siege_call_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void siege_call_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// siege_call_rsp

// required .client.CITY_OPT_ERR_NO_E err_no = 1;
inline bool siege_call_rsp::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_call_rsp::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_call_rsp::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_call_rsp::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::client::CITY_OPT_ERR_NO_E siege_call_rsp::err_no() const {
  return static_cast< ::client::CITY_OPT_ERR_NO_E >(err_no_);
}
inline void siege_call_rsp::set_err_no(::client::CITY_OPT_ERR_NO_E value) {
  assert(::client::CITY_OPT_ERR_NO_E_IsValid(value));
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// siege_call_accept_req

// required uint32 family_id = 1;
inline bool siege_call_accept_req::has_family_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_call_accept_req::set_has_family_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_call_accept_req::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_call_accept_req::clear_family_id() {
  family_id_ = 0u;
  clear_has_family_id();
}
inline ::google::protobuf::uint32 siege_call_accept_req::family_id() const {
  return family_id_;
}
inline void siege_call_accept_req::set_family_id(::google::protobuf::uint32 value) {
  set_has_family_id();
  family_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool siege_call_accept_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_call_accept_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_call_accept_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_call_accept_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& siege_call_accept_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* siege_call_accept_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* siege_call_accept_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void siege_call_accept_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// siege_call

// required uint32 role_id = 1;
inline bool siege_call::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_call::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_call::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_call::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 siege_call::role_id() const {
  return role_id_;
}
inline void siege_call::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required uint32 chief = 2;
inline bool siege_call::has_chief() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_call::set_has_chief() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_call::clear_has_chief() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_call::clear_chief() {
  chief_ = 0u;
  clear_has_chief();
}
inline ::google::protobuf::uint32 siege_call::chief() const {
  return chief_;
}
inline void siege_call::set_chief(::google::protobuf::uint32 value) {
  set_has_chief();
  chief_ = value;
}

// -------------------------------------------------------------------

// siege_call_accept_rsp

// required .client.siege_call_accept_rsp.RET ret = 1;
inline bool siege_call_accept_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_call_accept_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_call_accept_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_call_accept_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::siege_call_accept_rsp_RET siege_call_accept_rsp::ret() const {
  return static_cast< ::client::siege_call_accept_rsp_RET >(ret_);
}
inline void siege_call_accept_rsp::set_ret(::client::siege_call_accept_rsp_RET value) {
  assert(::client::siege_call_accept_rsp_RET_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// siege_call_status

// required uint32 time = 2;
inline bool siege_call_status::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_call_status::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_call_status::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_call_status::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 siege_call_status::time() const {
  return time_;
}
inline void siege_call_status::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// siege_personal_info_req

// required uint32 role_id = 1;
inline bool siege_personal_info_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_personal_info_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_personal_info_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_personal_info_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 siege_personal_info_req::role_id() const {
  return role_id_;
}
inline void siege_personal_info_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool siege_personal_info_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_personal_info_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_personal_info_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_personal_info_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& siege_personal_info_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* siege_personal_info_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* siege_personal_info_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void siege_personal_info_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// siege_personal_info_rsp

// required uint32 region = 1;
inline bool siege_personal_info_rsp::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_personal_info_rsp::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_personal_info_rsp::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_personal_info_rsp::clear_region() {
  region_ = 0u;
  clear_has_region();
}
inline ::google::protobuf::uint32 siege_personal_info_rsp::region() const {
  return region_;
}
inline void siege_personal_info_rsp::set_region(::google::protobuf::uint32 value) {
  set_has_region();
  region_ = value;
}

// required uint32 exp = 2;
inline bool siege_personal_info_rsp::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_personal_info_rsp::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_personal_info_rsp::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_personal_info_rsp::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 siege_personal_info_rsp::exp() const {
  return exp_;
}
inline void siege_personal_info_rsp::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 time = 3;
inline bool siege_personal_info_rsp::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void siege_personal_info_rsp::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void siege_personal_info_rsp::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void siege_personal_info_rsp::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 siege_personal_info_rsp::time() const {
  return time_;
}
inline void siege_personal_info_rsp::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 add = 4;
inline bool siege_personal_info_rsp::has_add() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void siege_personal_info_rsp::set_has_add() {
  _has_bits_[0] |= 0x00000008u;
}
inline void siege_personal_info_rsp::clear_has_add() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void siege_personal_info_rsp::clear_add() {
  add_ = 0u;
  clear_has_add();
}
inline ::google::protobuf::uint32 siege_personal_info_rsp::add() const {
  return add_;
}
inline void siege_personal_info_rsp::set_add(::google::protobuf::uint32 value) {
  set_has_add();
  add_ = value;
}

// -------------------------------------------------------------------

// siege_field_open

// required uint32 time = 1;
inline bool siege_field_open::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_field_open::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_field_open::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_field_open::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 siege_field_open::time() const {
  return time_;
}
inline void siege_field_open::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// siege_start

// required uint32 open_time = 1;
inline bool siege_start::has_open_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_start::set_has_open_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_start::clear_has_open_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_start::clear_open_time() {
  open_time_ = 0u;
  clear_has_open_time();
}
inline ::google::protobuf::uint32 siege_start::open_time() const {
  return open_time_;
}
inline void siege_start::set_open_time(::google::protobuf::uint32 value) {
  set_has_open_time();
  open_time_ = value;
}

// required uint32 close_time = 2;
inline bool siege_start::has_close_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void siege_start::set_has_close_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void siege_start::clear_has_close_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void siege_start::clear_close_time() {
  close_time_ = 0u;
  clear_has_close_time();
}
inline ::google::protobuf::uint32 siege_start::close_time() const {
  return close_time_;
}
inline void siege_start::set_close_time(::google::protobuf::uint32 value) {
  set_has_close_time();
  close_time_ = value;
}

// optional uint32 family_id = 3;
inline bool siege_start::has_family_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void siege_start::set_has_family_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void siege_start::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void siege_start::clear_family_id() {
  family_id_ = 0u;
  clear_has_family_id();
}
inline ::google::protobuf::uint32 siege_start::family_id() const {
  return family_id_;
}
inline void siege_start::set_family_id(::google::protobuf::uint32 value) {
  set_has_family_id();
  family_id_ = value;
}

// optional uint32 occupy_time = 4;
inline bool siege_start::has_occupy_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void siege_start::set_has_occupy_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void siege_start::clear_has_occupy_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void siege_start::clear_occupy_time() {
  occupy_time_ = 0u;
  clear_has_occupy_time();
}
inline ::google::protobuf::uint32 siege_start::occupy_time() const {
  return occupy_time_;
}
inline void siege_start::set_occupy_time(::google::protobuf::uint32 value) {
  set_has_occupy_time();
  occupy_time_ = value;
}

// repeated .client.family_simple_info fsi = 5;
inline int siege_start::fsi_size() const {
  return fsi_.size();
}
inline void siege_start::clear_fsi() {
  fsi_.Clear();
}
inline const ::client::family_simple_info& siege_start::fsi(int index) const {
  return fsi_.Get(index);
}
inline ::client::family_simple_info* siege_start::mutable_fsi(int index) {
  return fsi_.Mutable(index);
}
inline ::client::family_simple_info* siege_start::add_fsi() {
  return fsi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::family_simple_info >&
siege_start::fsi() const {
  return fsi_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::family_simple_info >*
siege_start::mutable_fsi() {
  return &fsi_;
}

// -------------------------------------------------------------------

// siege_broadcast_msg

// required string id = 1;
inline bool siege_broadcast_msg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void siege_broadcast_msg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void siege_broadcast_msg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void siege_broadcast_msg::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& siege_broadcast_msg::id() const {
  return *id_;
}
inline void siege_broadcast_msg::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void siege_broadcast_msg::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void siege_broadcast_msg::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* siege_broadcast_msg::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* siege_broadcast_msg::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void siege_broadcast_msg::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// update_sculpture

// required uint32 role_id = 1;
inline bool update_sculpture::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void update_sculpture::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void update_sculpture::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void update_sculpture::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 update_sculpture::role_id() const {
  return role_id_;
}
inline void update_sculpture::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required string king = 2;
inline bool update_sculpture::has_king() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void update_sculpture::set_has_king() {
  _has_bits_[0] |= 0x00000002u;
}
inline void update_sculpture::clear_has_king() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void update_sculpture::clear_king() {
  if (king_ != &::google::protobuf::internal::kEmptyString) {
    king_->clear();
  }
  clear_has_king();
}
inline const ::std::string& update_sculpture::king() const {
  return *king_;
}
inline void update_sculpture::set_king(const ::std::string& value) {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  king_->assign(value);
}
inline void update_sculpture::set_king(const char* value) {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  king_->assign(value);
}
inline void update_sculpture::set_king(const char* value, size_t size) {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  king_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* update_sculpture::mutable_king() {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  return king_;
}
inline ::std::string* update_sculpture::release_king() {
  clear_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = king_;
    king_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void update_sculpture::set_allocated_king(::std::string* king) {
  if (king_ != &::google::protobuf::internal::kEmptyString) {
    delete king_;
  }
  if (king) {
    set_has_king();
    king_ = king;
  } else {
    clear_has_king();
    king_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string title = 3;
inline bool update_sculpture::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void update_sculpture::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void update_sculpture::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void update_sculpture::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& update_sculpture::title() const {
  return *title_;
}
inline void update_sculpture::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void update_sculpture::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void update_sculpture::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* update_sculpture::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* update_sculpture::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void update_sculpture::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string family_name = 4;
inline bool update_sculpture::has_family_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void update_sculpture::set_has_family_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void update_sculpture::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void update_sculpture::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& update_sculpture::family_name() const {
  return *family_name_;
}
inline void update_sculpture::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void update_sculpture::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void update_sculpture::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* update_sculpture::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* update_sculpture::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void update_sculpture::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// kingdom_sculpture_info

// required uint32 role_id = 1;
inline bool kingdom_sculpture_info::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void kingdom_sculpture_info::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void kingdom_sculpture_info::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void kingdom_sculpture_info::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 kingdom_sculpture_info::role_id() const {
  return role_id_;
}
inline void kingdom_sculpture_info::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required string king = 2;
inline bool kingdom_sculpture_info::has_king() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void kingdom_sculpture_info::set_has_king() {
  _has_bits_[0] |= 0x00000002u;
}
inline void kingdom_sculpture_info::clear_has_king() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void kingdom_sculpture_info::clear_king() {
  if (king_ != &::google::protobuf::internal::kEmptyString) {
    king_->clear();
  }
  clear_has_king();
}
inline const ::std::string& kingdom_sculpture_info::king() const {
  return *king_;
}
inline void kingdom_sculpture_info::set_king(const ::std::string& value) {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  king_->assign(value);
}
inline void kingdom_sculpture_info::set_king(const char* value) {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  king_->assign(value);
}
inline void kingdom_sculpture_info::set_king(const char* value, size_t size) {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  king_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* kingdom_sculpture_info::mutable_king() {
  set_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    king_ = new ::std::string;
  }
  return king_;
}
inline ::std::string* kingdom_sculpture_info::release_king() {
  clear_has_king();
  if (king_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = king_;
    king_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void kingdom_sculpture_info::set_allocated_king(::std::string* king) {
  if (king_ != &::google::protobuf::internal::kEmptyString) {
    delete king_;
  }
  if (king) {
    set_has_king();
    king_ = king;
  } else {
    clear_has_king();
    king_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string title = 3;
inline bool kingdom_sculpture_info::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void kingdom_sculpture_info::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void kingdom_sculpture_info::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void kingdom_sculpture_info::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& kingdom_sculpture_info::title() const {
  return *title_;
}
inline void kingdom_sculpture_info::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void kingdom_sculpture_info::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void kingdom_sculpture_info::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* kingdom_sculpture_info::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* kingdom_sculpture_info::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void kingdom_sculpture_info::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 inst_id = 4;
inline bool kingdom_sculpture_info::has_inst_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void kingdom_sculpture_info::set_has_inst_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void kingdom_sculpture_info::clear_has_inst_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void kingdom_sculpture_info::clear_inst_id() {
  inst_id_ = GOOGLE_ULONGLONG(0);
  clear_has_inst_id();
}
inline ::google::protobuf::uint64 kingdom_sculpture_info::inst_id() const {
  return inst_id_;
}
inline void kingdom_sculpture_info::set_inst_id(::google::protobuf::uint64 value) {
  set_has_inst_id();
  inst_id_ = value;
}

// required uint32 x = 5;
inline bool kingdom_sculpture_info::has_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void kingdom_sculpture_info::set_has_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void kingdom_sculpture_info::clear_has_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void kingdom_sculpture_info::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 kingdom_sculpture_info::x() const {
  return x_;
}
inline void kingdom_sculpture_info::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// required uint32 y = 6;
inline bool kingdom_sculpture_info::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void kingdom_sculpture_info::set_has_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void kingdom_sculpture_info::clear_has_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void kingdom_sculpture_info::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 kingdom_sculpture_info::y() const {
  return y_;
}
inline void kingdom_sculpture_info::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// required string family_name = 7;
inline bool kingdom_sculpture_info::has_family_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void kingdom_sculpture_info::set_has_family_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void kingdom_sculpture_info::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void kingdom_sculpture_info::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& kingdom_sculpture_info::family_name() const {
  return *family_name_;
}
inline void kingdom_sculpture_info::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void kingdom_sculpture_info::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void kingdom_sculpture_info::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* kingdom_sculpture_info::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* kingdom_sculpture_info::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void kingdom_sculpture_info::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// kingdom_sculpture

// repeated .client.kingdom_sculpture_info ksi = 1;
inline int kingdom_sculpture::ksi_size() const {
  return ksi_.size();
}
inline void kingdom_sculpture::clear_ksi() {
  ksi_.Clear();
}
inline const ::client::kingdom_sculpture_info& kingdom_sculpture::ksi(int index) const {
  return ksi_.Get(index);
}
inline ::client::kingdom_sculpture_info* kingdom_sculpture::mutable_ksi(int index) {
  return ksi_.Mutable(index);
}
inline ::client::kingdom_sculpture_info* kingdom_sculpture::add_ksi() {
  return ksi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::kingdom_sculpture_info >&
kingdom_sculpture::ksi() const {
  return ksi_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::kingdom_sculpture_info >*
kingdom_sculpture::mutable_ksi() {
  return &ksi_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::siege_enter_rsp_RET>() {
  return ::client::siege_enter_rsp_RET_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::siege_call_accept_rsp_RET>() {
  return ::client::siege_call_accept_rsp_RET_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::CITY_OPT_ERR_NO_E>() {
  return ::client::CITY_OPT_ERR_NO_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2ecity_2eproto__INCLUDED
