// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.chat_msg.proto

#ifndef PROTOBUF_client_2echat_5fmsg_2eproto__INCLUDED
#define PROTOBUF_client_2echat_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
#include "client.role_props.pb.h"
#include "client.jump_scene.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2echat_5fmsg_2eproto();
void protobuf_AssignDesc_client_2echat_5fmsg_2eproto();
void protobuf_ShutdownFile_client_2echat_5fmsg_2eproto();

class chat_msg;
class client_chat_msg;
class update_title_info_req;
class update_title_info_rsp;

enum chat_msg_CHANNEL {
  chat_msg_CHANNEL_WORLD = 1,
  chat_msg_CHANNEL_SCENE = 2,
  chat_msg_CHANNEL_FAMILY = 3,
  chat_msg_CHANNEL_TEAM = 4,
  chat_msg_CHANNEL_PRIVATE = 5,
  chat_msg_CHANNEL_SYSTEM = 6,
  chat_msg_CHANNEL_HORN = 7,
  chat_msg_CHANNEL_FRIEND = 8,
  chat_msg_CHANNEL_ANNOUNCE = 9,
  chat_msg_CHANNEL_WINDOW = 10,
  chat_msg_CHANNEL_THREELINE = 11,
  chat_msg_CHANNEL_EXPLORE = 12,
  chat_msg_CHANNEL_KILL = 13,
  chat_msg_CHANNEL_SHOUT = 14,
  chat_msg_CHANNEL_HORN_BROADCAST = 15,
  chat_msg_CHANNEL_NPC = 16
};
bool chat_msg_CHANNEL_IsValid(int value);
const chat_msg_CHANNEL chat_msg_CHANNEL_CHANNEL_MIN = chat_msg_CHANNEL_WORLD;
const chat_msg_CHANNEL chat_msg_CHANNEL_CHANNEL_MAX = chat_msg_CHANNEL_NPC;
const int chat_msg_CHANNEL_CHANNEL_ARRAYSIZE = chat_msg_CHANNEL_CHANNEL_MAX + 1;

const ::google::protobuf::EnumDescriptor* chat_msg_CHANNEL_descriptor();
inline const ::std::string& chat_msg_CHANNEL_Name(chat_msg_CHANNEL value) {
  return ::google::protobuf::internal::NameOfEnum(
    chat_msg_CHANNEL_descriptor(), value);
}
inline bool chat_msg_CHANNEL_Parse(
    const ::std::string& name, chat_msg_CHANNEL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<chat_msg_CHANNEL>(
    chat_msg_CHANNEL_descriptor(), name, value);
}
// ===================================================================

class chat_msg : public ::google::protobuf::Message {
 public:
  chat_msg();
  virtual ~chat_msg();

  chat_msg(const chat_msg& from);

  inline chat_msg& operator=(const chat_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_msg& default_instance();

  void Swap(chat_msg* other);

  // implements Message ----------------------------------------------

  chat_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_msg& from);
  void MergeFrom(const chat_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef chat_msg_CHANNEL CHANNEL;
  static const CHANNEL WORLD = chat_msg_CHANNEL_WORLD;
  static const CHANNEL SCENE = chat_msg_CHANNEL_SCENE;
  static const CHANNEL FAMILY = chat_msg_CHANNEL_FAMILY;
  static const CHANNEL TEAM = chat_msg_CHANNEL_TEAM;
  static const CHANNEL PRIVATE = chat_msg_CHANNEL_PRIVATE;
  static const CHANNEL SYSTEM = chat_msg_CHANNEL_SYSTEM;
  static const CHANNEL HORN = chat_msg_CHANNEL_HORN;
  static const CHANNEL FRIEND = chat_msg_CHANNEL_FRIEND;
  static const CHANNEL ANNOUNCE = chat_msg_CHANNEL_ANNOUNCE;
  static const CHANNEL WINDOW = chat_msg_CHANNEL_WINDOW;
  static const CHANNEL THREELINE = chat_msg_CHANNEL_THREELINE;
  static const CHANNEL EXPLORE = chat_msg_CHANNEL_EXPLORE;
  static const CHANNEL KILL = chat_msg_CHANNEL_KILL;
  static const CHANNEL SHOUT = chat_msg_CHANNEL_SHOUT;
  static const CHANNEL HORN_BROADCAST = chat_msg_CHANNEL_HORN_BROADCAST;
  static const CHANNEL NPC = chat_msg_CHANNEL_NPC;
  static inline bool CHANNEL_IsValid(int value) {
    return chat_msg_CHANNEL_IsValid(value);
  }
  static const CHANNEL CHANNEL_MIN =
    chat_msg_CHANNEL_CHANNEL_MIN;
  static const CHANNEL CHANNEL_MAX =
    chat_msg_CHANNEL_CHANNEL_MAX;
  static const int CHANNEL_ARRAYSIZE =
    chat_msg_CHANNEL_CHANNEL_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CHANNEL_descriptor() {
    return chat_msg_CHANNEL_descriptor();
  }
  static inline const ::std::string& CHANNEL_Name(CHANNEL value) {
    return chat_msg_CHANNEL_Name(value);
  }
  static inline bool CHANNEL_Parse(const ::std::string& name,
      CHANNEL* value) {
    return chat_msg_CHANNEL_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.chat_msg.CHANNEL channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::client::chat_msg_CHANNEL channel() const;
  inline void set_channel(::client::chat_msg_CHANNEL value);

  // required uint32 src_rold_id = 2;
  inline bool has_src_rold_id() const;
  inline void clear_src_rold_id();
  static const int kSrcRoldIdFieldNumber = 2;
  inline ::google::protobuf::uint32 src_rold_id() const;
  inline void set_src_rold_id(::google::protobuf::uint32 value);

  // optional string src_role_name = 3;
  inline bool has_src_role_name() const;
  inline void clear_src_role_name();
  static const int kSrcRoleNameFieldNumber = 3;
  inline const ::std::string& src_role_name() const;
  inline void set_src_role_name(const ::std::string& value);
  inline void set_src_role_name(const char* value);
  inline void set_src_role_name(const char* value, size_t size);
  inline ::std::string* mutable_src_role_name();
  inline ::std::string* release_src_role_name();
  inline void set_allocated_src_role_name(::std::string* src_role_name);

  // optional uint32 src_vip_lvl = 4;
  inline bool has_src_vip_lvl() const;
  inline void clear_src_vip_lvl();
  static const int kSrcVipLvlFieldNumber = 4;
  inline ::google::protobuf::uint32 src_vip_lvl() const;
  inline void set_src_vip_lvl(::google::protobuf::uint32 value);

  // optional string src_title = 5;
  inline bool has_src_title() const;
  inline void clear_src_title();
  static const int kSrcTitleFieldNumber = 5;
  inline const ::std::string& src_title() const;
  inline void set_src_title(const ::std::string& value);
  inline void set_src_title(const char* value);
  inline void set_src_title(const char* value, size_t size);
  inline ::std::string* mutable_src_title();
  inline ::std::string* release_src_title();
  inline void set_allocated_src_title(::std::string* src_title);

  // optional uint32 src_profession = 6;
  inline bool has_src_profession() const;
  inline void clear_src_profession();
  static const int kSrcProfessionFieldNumber = 6;
  inline ::google::protobuf::uint32 src_profession() const;
  inline void set_src_profession(::google::protobuf::uint32 value);

  // optional uint32 src_sex = 7;
  inline bool has_src_sex() const;
  inline void clear_src_sex();
  static const int kSrcSexFieldNumber = 7;
  inline ::google::protobuf::uint32 src_sex() const;
  inline void set_src_sex(::google::protobuf::uint32 value);

  // optional bytes content = 8;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 8;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // repeated .client.props_info pi = 9;
  inline int pi_size() const;
  inline void clear_pi();
  static const int kPiFieldNumber = 9;
  inline const ::client::props_info& pi(int index) const;
  inline ::client::props_info* mutable_pi(int index);
  inline ::client::props_info* add_pi();
  inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
      pi() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
      mutable_pi();

  // optional .client.jump_scene jump = 10;
  inline bool has_jump() const;
  inline void clear_jump();
  static const int kJumpFieldNumber = 10;
  inline const ::client::jump_scene& jump() const;
  inline ::client::jump_scene* mutable_jump();
  inline ::client::jump_scene* release_jump();
  inline void set_allocated_jump(::client::jump_scene* jump);

  // optional uint32 act_type = 11;
  inline bool has_act_type() const;
  inline void clear_act_type();
  static const int kActTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 act_type() const;
  inline void set_act_type(::google::protobuf::uint32 value);

  // optional uint32 dst_role_id = 12;
  inline bool has_dst_role_id() const;
  inline void clear_dst_role_id();
  static const int kDstRoleIdFieldNumber = 12;
  inline ::google::protobuf::uint32 dst_role_id() const;
  inline void set_dst_role_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.chat_msg)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_src_rold_id();
  inline void clear_has_src_rold_id();
  inline void set_has_src_role_name();
  inline void clear_has_src_role_name();
  inline void set_has_src_vip_lvl();
  inline void clear_has_src_vip_lvl();
  inline void set_has_src_title();
  inline void clear_has_src_title();
  inline void set_has_src_profession();
  inline void clear_has_src_profession();
  inline void set_has_src_sex();
  inline void clear_has_src_sex();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_jump();
  inline void clear_has_jump();
  inline void set_has_act_type();
  inline void clear_has_act_type();
  inline void set_has_dst_role_id();
  inline void clear_has_dst_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int channel_;
  ::google::protobuf::uint32 src_rold_id_;
  ::std::string* src_role_name_;
  ::std::string* src_title_;
  ::google::protobuf::uint32 src_vip_lvl_;
  ::google::protobuf::uint32 src_profession_;
  ::std::string* content_;
  ::google::protobuf::RepeatedPtrField< ::client::props_info > pi_;
  ::google::protobuf::uint32 src_sex_;
  ::google::protobuf::uint32 act_type_;
  ::client::jump_scene* jump_;
  ::google::protobuf::uint32 dst_role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_2echat_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static chat_msg* default_instance_;
};
// -------------------------------------------------------------------

class client_chat_msg : public ::google::protobuf::Message {
 public:
  client_chat_msg();
  virtual ~client_chat_msg();

  client_chat_msg(const client_chat_msg& from);

  inline client_chat_msg& operator=(const client_chat_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_chat_msg& default_instance();

  void Swap(client_chat_msg* other);

  // implements Message ----------------------------------------------

  client_chat_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_chat_msg& from);
  void MergeFrom(const client_chat_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.chat_msg cm = 1;
  inline bool has_cm() const;
  inline void clear_cm();
  static const int kCmFieldNumber = 1;
  inline const ::client::chat_msg& cm() const;
  inline ::client::chat_msg* mutable_cm();
  inline ::client::chat_msg* release_cm();
  inline void set_allocated_cm(::client::chat_msg* cm);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.client_chat_msg)
 private:
  inline void set_has_cm();
  inline void clear_has_cm();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::chat_msg* cm_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_2echat_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static client_chat_msg* default_instance_;
};
// -------------------------------------------------------------------

class update_title_info_req : public ::google::protobuf::Message {
 public:
  update_title_info_req();
  virtual ~update_title_info_req();

  update_title_info_req(const update_title_info_req& from);

  inline update_title_info_req& operator=(const update_title_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const update_title_info_req& default_instance();

  void Swap(update_title_info_req* other);

  // implements Message ----------------------------------------------

  update_title_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const update_title_info_req& from);
  void MergeFrom(const update_title_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.update_title_info_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_2echat_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static update_title_info_req* default_instance_;
};
// -------------------------------------------------------------------

class update_title_info_rsp : public ::google::protobuf::Message {
 public:
  update_title_info_rsp();
  virtual ~update_title_info_rsp();

  update_title_info_rsp(const update_title_info_rsp& from);

  inline update_title_info_rsp& operator=(const update_title_info_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const update_title_info_rsp& default_instance();

  void Swap(update_title_info_rsp* other);

  // implements Message ----------------------------------------------

  update_title_info_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const update_title_info_rsp& from);
  void MergeFrom(const update_title_info_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional uint32 family_title = 2;
  inline bool has_family_title() const;
  inline void clear_family_title();
  static const int kFamilyTitleFieldNumber = 2;
  inline ::google::protobuf::uint32 family_title() const;
  inline void set_family_title(::google::protobuf::uint32 value);

  // optional string family_name = 3;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 3;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional bool is_siege = 4;
  inline bool has_is_siege() const;
  inline void clear_is_siege();
  static const int kIsSiegeFieldNumber = 4;
  inline bool is_siege() const;
  inline void set_is_siege(bool value);

  // @@protoc_insertion_point(class_scope:client.update_title_info_rsp)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_family_title();
  inline void clear_has_family_title();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_is_siege();
  inline void clear_has_is_siege();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 family_title_;
  ::std::string* family_name_;
  bool is_siege_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_2echat_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_2echat_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static update_title_info_rsp* default_instance_;
};
// ===================================================================


// ===================================================================

// chat_msg

// required .client.chat_msg.CHANNEL channel = 1;
inline bool chat_msg::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_msg::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_msg::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_msg::clear_channel() {
  channel_ = 1;
  clear_has_channel();
}
inline ::client::chat_msg_CHANNEL chat_msg::channel() const {
  return static_cast< ::client::chat_msg_CHANNEL >(channel_);
}
inline void chat_msg::set_channel(::client::chat_msg_CHANNEL value) {
  assert(::client::chat_msg_CHANNEL_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// required uint32 src_rold_id = 2;
inline bool chat_msg::has_src_rold_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat_msg::set_has_src_rold_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat_msg::clear_has_src_rold_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat_msg::clear_src_rold_id() {
  src_rold_id_ = 0u;
  clear_has_src_rold_id();
}
inline ::google::protobuf::uint32 chat_msg::src_rold_id() const {
  return src_rold_id_;
}
inline void chat_msg::set_src_rold_id(::google::protobuf::uint32 value) {
  set_has_src_rold_id();
  src_rold_id_ = value;
}

// optional string src_role_name = 3;
inline bool chat_msg::has_src_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void chat_msg::set_has_src_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void chat_msg::clear_has_src_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void chat_msg::clear_src_role_name() {
  if (src_role_name_ != &::google::protobuf::internal::kEmptyString) {
    src_role_name_->clear();
  }
  clear_has_src_role_name();
}
inline const ::std::string& chat_msg::src_role_name() const {
  return *src_role_name_;
}
inline void chat_msg::set_src_role_name(const ::std::string& value) {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  src_role_name_->assign(value);
}
inline void chat_msg::set_src_role_name(const char* value) {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  src_role_name_->assign(value);
}
inline void chat_msg::set_src_role_name(const char* value, size_t size) {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  src_role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_msg::mutable_src_role_name() {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  return src_role_name_;
}
inline ::std::string* chat_msg::release_src_role_name() {
  clear_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_role_name_;
    src_role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_msg::set_allocated_src_role_name(::std::string* src_role_name) {
  if (src_role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete src_role_name_;
  }
  if (src_role_name) {
    set_has_src_role_name();
    src_role_name_ = src_role_name;
  } else {
    clear_has_src_role_name();
    src_role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 src_vip_lvl = 4;
inline bool chat_msg::has_src_vip_lvl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void chat_msg::set_has_src_vip_lvl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void chat_msg::clear_has_src_vip_lvl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void chat_msg::clear_src_vip_lvl() {
  src_vip_lvl_ = 0u;
  clear_has_src_vip_lvl();
}
inline ::google::protobuf::uint32 chat_msg::src_vip_lvl() const {
  return src_vip_lvl_;
}
inline void chat_msg::set_src_vip_lvl(::google::protobuf::uint32 value) {
  set_has_src_vip_lvl();
  src_vip_lvl_ = value;
}

// optional string src_title = 5;
inline bool chat_msg::has_src_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void chat_msg::set_has_src_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void chat_msg::clear_has_src_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void chat_msg::clear_src_title() {
  if (src_title_ != &::google::protobuf::internal::kEmptyString) {
    src_title_->clear();
  }
  clear_has_src_title();
}
inline const ::std::string& chat_msg::src_title() const {
  return *src_title_;
}
inline void chat_msg::set_src_title(const ::std::string& value) {
  set_has_src_title();
  if (src_title_ == &::google::protobuf::internal::kEmptyString) {
    src_title_ = new ::std::string;
  }
  src_title_->assign(value);
}
inline void chat_msg::set_src_title(const char* value) {
  set_has_src_title();
  if (src_title_ == &::google::protobuf::internal::kEmptyString) {
    src_title_ = new ::std::string;
  }
  src_title_->assign(value);
}
inline void chat_msg::set_src_title(const char* value, size_t size) {
  set_has_src_title();
  if (src_title_ == &::google::protobuf::internal::kEmptyString) {
    src_title_ = new ::std::string;
  }
  src_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_msg::mutable_src_title() {
  set_has_src_title();
  if (src_title_ == &::google::protobuf::internal::kEmptyString) {
    src_title_ = new ::std::string;
  }
  return src_title_;
}
inline ::std::string* chat_msg::release_src_title() {
  clear_has_src_title();
  if (src_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_title_;
    src_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_msg::set_allocated_src_title(::std::string* src_title) {
  if (src_title_ != &::google::protobuf::internal::kEmptyString) {
    delete src_title_;
  }
  if (src_title) {
    set_has_src_title();
    src_title_ = src_title;
  } else {
    clear_has_src_title();
    src_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 src_profession = 6;
inline bool chat_msg::has_src_profession() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void chat_msg::set_has_src_profession() {
  _has_bits_[0] |= 0x00000020u;
}
inline void chat_msg::clear_has_src_profession() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void chat_msg::clear_src_profession() {
  src_profession_ = 0u;
  clear_has_src_profession();
}
inline ::google::protobuf::uint32 chat_msg::src_profession() const {
  return src_profession_;
}
inline void chat_msg::set_src_profession(::google::protobuf::uint32 value) {
  set_has_src_profession();
  src_profession_ = value;
}

// optional uint32 src_sex = 7;
inline bool chat_msg::has_src_sex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void chat_msg::set_has_src_sex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void chat_msg::clear_has_src_sex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void chat_msg::clear_src_sex() {
  src_sex_ = 0u;
  clear_has_src_sex();
}
inline ::google::protobuf::uint32 chat_msg::src_sex() const {
  return src_sex_;
}
inline void chat_msg::set_src_sex(::google::protobuf::uint32 value) {
  set_has_src_sex();
  src_sex_ = value;
}

// optional bytes content = 8;
inline bool chat_msg::has_content() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void chat_msg::set_has_content() {
  _has_bits_[0] |= 0x00000080u;
}
inline void chat_msg::clear_has_content() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void chat_msg::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& chat_msg::content() const {
  return *content_;
}
inline void chat_msg::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void chat_msg::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void chat_msg::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_msg::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* chat_msg::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_msg::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .client.props_info pi = 9;
inline int chat_msg::pi_size() const {
  return pi_.size();
}
inline void chat_msg::clear_pi() {
  pi_.Clear();
}
inline const ::client::props_info& chat_msg::pi(int index) const {
  return pi_.Get(index);
}
inline ::client::props_info* chat_msg::mutable_pi(int index) {
  return pi_.Mutable(index);
}
inline ::client::props_info* chat_msg::add_pi() {
  return pi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
chat_msg::pi() const {
  return pi_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
chat_msg::mutable_pi() {
  return &pi_;
}

// optional .client.jump_scene jump = 10;
inline bool chat_msg::has_jump() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void chat_msg::set_has_jump() {
  _has_bits_[0] |= 0x00000200u;
}
inline void chat_msg::clear_has_jump() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void chat_msg::clear_jump() {
  if (jump_ != NULL) jump_->::client::jump_scene::Clear();
  clear_has_jump();
}
inline const ::client::jump_scene& chat_msg::jump() const {
  return jump_ != NULL ? *jump_ : *default_instance_->jump_;
}
inline ::client::jump_scene* chat_msg::mutable_jump() {
  set_has_jump();
  if (jump_ == NULL) jump_ = new ::client::jump_scene;
  return jump_;
}
inline ::client::jump_scene* chat_msg::release_jump() {
  clear_has_jump();
  ::client::jump_scene* temp = jump_;
  jump_ = NULL;
  return temp;
}
inline void chat_msg::set_allocated_jump(::client::jump_scene* jump) {
  delete jump_;
  jump_ = jump;
  if (jump) {
    set_has_jump();
  } else {
    clear_has_jump();
  }
}

// optional uint32 act_type = 11;
inline bool chat_msg::has_act_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void chat_msg::set_has_act_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void chat_msg::clear_has_act_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void chat_msg::clear_act_type() {
  act_type_ = 0u;
  clear_has_act_type();
}
inline ::google::protobuf::uint32 chat_msg::act_type() const {
  return act_type_;
}
inline void chat_msg::set_act_type(::google::protobuf::uint32 value) {
  set_has_act_type();
  act_type_ = value;
}

// optional uint32 dst_role_id = 12;
inline bool chat_msg::has_dst_role_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void chat_msg::set_has_dst_role_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void chat_msg::clear_has_dst_role_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void chat_msg::clear_dst_role_id() {
  dst_role_id_ = 0u;
  clear_has_dst_role_id();
}
inline ::google::protobuf::uint32 chat_msg::dst_role_id() const {
  return dst_role_id_;
}
inline void chat_msg::set_dst_role_id(::google::protobuf::uint32 value) {
  set_has_dst_role_id();
  dst_role_id_ = value;
}

// -------------------------------------------------------------------

// client_chat_msg

// required .client.chat_msg cm = 1;
inline bool client_chat_msg::has_cm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_chat_msg::set_has_cm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_chat_msg::clear_has_cm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_chat_msg::clear_cm() {
  if (cm_ != NULL) cm_->::client::chat_msg::Clear();
  clear_has_cm();
}
inline const ::client::chat_msg& client_chat_msg::cm() const {
  return cm_ != NULL ? *cm_ : *default_instance_->cm_;
}
inline ::client::chat_msg* client_chat_msg::mutable_cm() {
  set_has_cm();
  if (cm_ == NULL) cm_ = new ::client::chat_msg;
  return cm_;
}
inline ::client::chat_msg* client_chat_msg::release_cm() {
  clear_has_cm();
  ::client::chat_msg* temp = cm_;
  cm_ = NULL;
  return temp;
}
inline void client_chat_msg::set_allocated_cm(::client::chat_msg* cm) {
  delete cm_;
  cm_ = cm;
  if (cm) {
    set_has_cm();
  } else {
    clear_has_cm();
  }
}

// optional .client.server_head svr_head = 1000;
inline bool client_chat_msg::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_chat_msg::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_chat_msg::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_chat_msg::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& client_chat_msg::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* client_chat_msg::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* client_chat_msg::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void client_chat_msg::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// update_title_info_req

// required uint32 role_id = 1;
inline bool update_title_info_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void update_title_info_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void update_title_info_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void update_title_info_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 update_title_info_req::role_id() const {
  return role_id_;
}
inline void update_title_info_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// -------------------------------------------------------------------

// update_title_info_rsp

// required uint32 role_id = 1;
inline bool update_title_info_rsp::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void update_title_info_rsp::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void update_title_info_rsp::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void update_title_info_rsp::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 update_title_info_rsp::role_id() const {
  return role_id_;
}
inline void update_title_info_rsp::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional uint32 family_title = 2;
inline bool update_title_info_rsp::has_family_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void update_title_info_rsp::set_has_family_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void update_title_info_rsp::clear_has_family_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void update_title_info_rsp::clear_family_title() {
  family_title_ = 0u;
  clear_has_family_title();
}
inline ::google::protobuf::uint32 update_title_info_rsp::family_title() const {
  return family_title_;
}
inline void update_title_info_rsp::set_family_title(::google::protobuf::uint32 value) {
  set_has_family_title();
  family_title_ = value;
}

// optional string family_name = 3;
inline bool update_title_info_rsp::has_family_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void update_title_info_rsp::set_has_family_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void update_title_info_rsp::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void update_title_info_rsp::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& update_title_info_rsp::family_name() const {
  return *family_name_;
}
inline void update_title_info_rsp::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void update_title_info_rsp::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void update_title_info_rsp::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* update_title_info_rsp::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* update_title_info_rsp::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void update_title_info_rsp::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_siege = 4;
inline bool update_title_info_rsp::has_is_siege() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void update_title_info_rsp::set_has_is_siege() {
  _has_bits_[0] |= 0x00000008u;
}
inline void update_title_info_rsp::clear_has_is_siege() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void update_title_info_rsp::clear_is_siege() {
  is_siege_ = false;
  clear_has_is_siege();
}
inline bool update_title_info_rsp::is_siege() const {
  return is_siege_;
}
inline void update_title_info_rsp::set_is_siege(bool value) {
  set_has_is_siege();
  is_siege_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::chat_msg_CHANNEL>() {
  return ::client::chat_msg_CHANNEL_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2echat_5fmsg_2eproto__INCLUDED
