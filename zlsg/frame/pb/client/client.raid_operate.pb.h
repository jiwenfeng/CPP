// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.raid_operate.proto

#ifndef PROTOBUF_client_2eraid_5foperate_2eproto__INCLUDED
#define PROTOBUF_client_2eraid_5foperate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
#include "client.role_props.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

class raid_info;
class raid_info_msg;
class enter_raid_req;
class exit_raid_req;
class raid_open_box_req;
class raid_open_box_rsp;
class raid_result_info;
class raid_success_ic;
class raid_success_info;
class raid_failure_info;
class raid_result_msg;
class raid_npc_creazed;
class auto_raid_req;
class auto_raid_rsp;
class auto_raid_info;
class auto_raid_msg;
class mini_server_req;
class mini_server_rsp;
class mini_server_end_msg;
class raid_verify;
class reported_raid_info;
class reported_raid_req;
class create_npc_msg;
class dead_in_raid;

enum enter_raid_req_type {
  enter_raid_req_type_normal = 0,
  enter_raid_req_type_elite = 1
};
bool enter_raid_req_type_IsValid(int value);
const enter_raid_req_type enter_raid_req_type_type_MIN = enter_raid_req_type_normal;
const enter_raid_req_type enter_raid_req_type_type_MAX = enter_raid_req_type_elite;
const int enter_raid_req_type_type_ARRAYSIZE = enter_raid_req_type_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* enter_raid_req_type_descriptor();
inline const ::std::string& enter_raid_req_type_Name(enter_raid_req_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    enter_raid_req_type_descriptor(), value);
}
inline bool enter_raid_req_type_Parse(
    const ::std::string& name, enter_raid_req_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<enter_raid_req_type>(
    enter_raid_req_type_descriptor(), name, value);
}
enum raid_check_result_e {
  success = 0,
  raid_error = 1,
  vit_limit = 2,
  lvl_limit = 3,
  pet_limit = 4,
  prev_limit = 5,
  num_limit = 6,
  elite_limit = 7,
  need_reset = 8,
  main_limit = 9,
  team_not_exist = 10,
  team_full = 11,
  team_closed = 12,
  in_team = 13,
  func_closed = 14,
  invalid_id = 15,
  prize_not_get = 16,
  failed = 17
};
bool raid_check_result_e_IsValid(int value);
const raid_check_result_e raid_check_result_e_MIN = success;
const raid_check_result_e raid_check_result_e_MAX = failed;
const int raid_check_result_e_ARRAYSIZE = raid_check_result_e_MAX + 1;

const ::google::protobuf::EnumDescriptor* raid_check_result_e_descriptor();
inline const ::std::string& raid_check_result_e_Name(raid_check_result_e value) {
  return ::google::protobuf::internal::NameOfEnum(
    raid_check_result_e_descriptor(), value);
}
inline bool raid_check_result_e_Parse(
    const ::std::string& name, raid_check_result_e* value) {
  return ::google::protobuf::internal::ParseNamedEnum<raid_check_result_e>(
    raid_check_result_e_descriptor(), name, value);
}
// ===================================================================

class raid_info : public ::google::protobuf::Message {
 public:
  raid_info();
  virtual ~raid_info();

  raid_info(const raid_info& from);

  inline raid_info& operator=(const raid_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_info& default_instance();

  void Swap(raid_info* other);

  // implements Message ----------------------------------------------

  raid_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_info& from);
  void MergeFrom(const raid_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 raid_id = 1;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // required uint32 star_num = 2;
  inline bool has_star_num() const;
  inline void clear_star_num();
  static const int kStarNumFieldNumber = 2;
  inline ::google::protobuf::uint32 star_num() const;
  inline void set_star_num(::google::protobuf::uint32 value);

  // required uint32 fast_tick = 3;
  inline bool has_fast_tick() const;
  inline void clear_fast_tick();
  static const int kFastTickFieldNumber = 3;
  inline ::google::protobuf::uint32 fast_tick() const;
  inline void set_fast_tick(::google::protobuf::uint32 value);

  // required uint32 last_complete_time = 4;
  inline bool has_last_complete_time() const;
  inline void clear_last_complete_time();
  static const int kLastCompleteTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 last_complete_time() const;
  inline void set_last_complete_time(::google::protobuf::uint32 value);

  // required uint32 complete_count = 5;
  inline bool has_complete_count() const;
  inline void clear_complete_count();
  static const int kCompleteCountFieldNumber = 5;
  inline ::google::protobuf::uint32 complete_count() const;
  inline void set_complete_count(::google::protobuf::uint32 value);

  // required uint32 create_time = 6;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required uint32 auto_time = 7;
  inline bool has_auto_time() const;
  inline void clear_auto_time();
  static const int kAutoTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 auto_time() const;
  inline void set_auto_time(::google::protobuf::uint32 value);

  // required uint32 elite_star_num = 8;
  inline bool has_elite_star_num() const;
  inline void clear_elite_star_num();
  static const int kEliteStarNumFieldNumber = 8;
  inline ::google::protobuf::uint32 elite_star_num() const;
  inline void set_elite_star_num(::google::protobuf::uint32 value);

  // required uint32 elite_fast_tick = 9;
  inline bool has_elite_fast_tick() const;
  inline void clear_elite_fast_tick();
  static const int kEliteFastTickFieldNumber = 9;
  inline ::google::protobuf::uint32 elite_fast_tick() const;
  inline void set_elite_fast_tick(::google::protobuf::uint32 value);

  // required uint32 elite_last_complete_time = 10;
  inline bool has_elite_last_complete_time() const;
  inline void clear_elite_last_complete_time();
  static const int kEliteLastCompleteTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 elite_last_complete_time() const;
  inline void set_elite_last_complete_time(::google::protobuf::uint32 value);

  // required uint32 elite_complete_count = 11;
  inline bool has_elite_complete_count() const;
  inline void clear_elite_complete_count();
  static const int kEliteCompleteCountFieldNumber = 11;
  inline ::google::protobuf::uint32 elite_complete_count() const;
  inline void set_elite_complete_count(::google::protobuf::uint32 value);

  // required uint32 elite_create_time = 12;
  inline bool has_elite_create_time() const;
  inline void clear_elite_create_time();
  static const int kEliteCreateTimeFieldNumber = 12;
  inline ::google::protobuf::uint32 elite_create_time() const;
  inline void set_elite_create_time(::google::protobuf::uint32 value);

  // required uint32 elite_auto_time = 13;
  inline bool has_elite_auto_time() const;
  inline void clear_elite_auto_time();
  static const int kEliteAutoTimeFieldNumber = 13;
  inline ::google::protobuf::uint32 elite_auto_time() const;
  inline void set_elite_auto_time(::google::protobuf::uint32 value);

  // required uint32 elite_enter_count = 14;
  inline bool has_elite_enter_count() const;
  inline void clear_elite_enter_count();
  static const int kEliteEnterCountFieldNumber = 14;
  inline ::google::protobuf::uint32 elite_enter_count() const;
  inline void set_elite_enter_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.raid_info)
 private:
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_star_num();
  inline void clear_has_star_num();
  inline void set_has_fast_tick();
  inline void clear_has_fast_tick();
  inline void set_has_last_complete_time();
  inline void clear_has_last_complete_time();
  inline void set_has_complete_count();
  inline void clear_has_complete_count();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_auto_time();
  inline void clear_has_auto_time();
  inline void set_has_elite_star_num();
  inline void clear_has_elite_star_num();
  inline void set_has_elite_fast_tick();
  inline void clear_has_elite_fast_tick();
  inline void set_has_elite_last_complete_time();
  inline void clear_has_elite_last_complete_time();
  inline void set_has_elite_complete_count();
  inline void clear_has_elite_complete_count();
  inline void set_has_elite_create_time();
  inline void clear_has_elite_create_time();
  inline void set_has_elite_auto_time();
  inline void clear_has_elite_auto_time();
  inline void set_has_elite_enter_count();
  inline void clear_has_elite_enter_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 raid_id_;
  ::google::protobuf::uint32 star_num_;
  ::google::protobuf::uint32 fast_tick_;
  ::google::protobuf::uint32 last_complete_time_;
  ::google::protobuf::uint32 complete_count_;
  ::google::protobuf::uint32 create_time_;
  ::google::protobuf::uint32 auto_time_;
  ::google::protobuf::uint32 elite_star_num_;
  ::google::protobuf::uint32 elite_fast_tick_;
  ::google::protobuf::uint32 elite_last_complete_time_;
  ::google::protobuf::uint32 elite_complete_count_;
  ::google::protobuf::uint32 elite_create_time_;
  ::google::protobuf::uint32 elite_auto_time_;
  ::google::protobuf::uint32 elite_enter_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_info* default_instance_;
};
// -------------------------------------------------------------------

class raid_info_msg : public ::google::protobuf::Message {
 public:
  raid_info_msg();
  virtual ~raid_info_msg();

  raid_info_msg(const raid_info_msg& from);

  inline raid_info_msg& operator=(const raid_info_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_info_msg& default_instance();

  void Swap(raid_info_msg* other);

  // implements Message ----------------------------------------------

  raid_info_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_info_msg& from);
  void MergeFrom(const raid_info_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.raid_info ri = 1;
  inline int ri_size() const;
  inline void clear_ri();
  static const int kRiFieldNumber = 1;
  inline const ::client::raid_info& ri(int index) const;
  inline ::client::raid_info* mutable_ri(int index);
  inline ::client::raid_info* add_ri();
  inline const ::google::protobuf::RepeatedPtrField< ::client::raid_info >&
      ri() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::raid_info >*
      mutable_ri();

  // @@protoc_insertion_point(class_scope:client.raid_info_msg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::raid_info > ri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_info_msg* default_instance_;
};
// -------------------------------------------------------------------

class enter_raid_req : public ::google::protobuf::Message {
 public:
  enter_raid_req();
  virtual ~enter_raid_req();

  enter_raid_req(const enter_raid_req& from);

  inline enter_raid_req& operator=(const enter_raid_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const enter_raid_req& default_instance();

  void Swap(enter_raid_req* other);

  // implements Message ----------------------------------------------

  enter_raid_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const enter_raid_req& from);
  void MergeFrom(const enter_raid_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef enter_raid_req_type type;
  static const type normal = enter_raid_req_type_normal;
  static const type elite = enter_raid_req_type_elite;
  static inline bool type_IsValid(int value) {
    return enter_raid_req_type_IsValid(value);
  }
  static const type type_MIN =
    enter_raid_req_type_type_MIN;
  static const type type_MAX =
    enter_raid_req_type_type_MAX;
  static const int type_ARRAYSIZE =
    enter_raid_req_type_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  type_descriptor() {
    return enter_raid_req_type_descriptor();
  }
  static inline const ::std::string& type_Name(type value) {
    return enter_raid_req_type_Name(value);
  }
  static inline bool type_Parse(const ::std::string& name,
      type* value) {
    return enter_raid_req_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 raid_id = 1;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // optional uint32 t = 2;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 2;
  inline ::google::protobuf::uint32 t() const;
  inline void set_t(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.enter_raid_req)
 private:
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 raid_id_;
  ::google::protobuf::uint32 t_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static enter_raid_req* default_instance_;
};
// -------------------------------------------------------------------

class exit_raid_req : public ::google::protobuf::Message {
 public:
  exit_raid_req();
  virtual ~exit_raid_req();

  exit_raid_req(const exit_raid_req& from);

  inline exit_raid_req& operator=(const exit_raid_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exit_raid_req& default_instance();

  void Swap(exit_raid_req* other);

  // implements Message ----------------------------------------------

  exit_raid_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exit_raid_req& from);
  void MergeFrom(const exit_raid_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 raid_id = 1;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.exit_raid_req)
 private:
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 raid_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static exit_raid_req* default_instance_;
};
// -------------------------------------------------------------------

class raid_open_box_req : public ::google::protobuf::Message {
 public:
  raid_open_box_req();
  virtual ~raid_open_box_req();

  raid_open_box_req(const raid_open_box_req& from);

  inline raid_open_box_req& operator=(const raid_open_box_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_open_box_req& default_instance();

  void Swap(raid_open_box_req* other);

  // implements Message ----------------------------------------------

  raid_open_box_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_open_box_req& from);
  void MergeFrom(const raid_open_box_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.raid_open_box_req)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_open_box_req* default_instance_;
};
// -------------------------------------------------------------------

class raid_open_box_rsp : public ::google::protobuf::Message {
 public:
  raid_open_box_rsp();
  virtual ~raid_open_box_rsp();

  raid_open_box_rsp(const raid_open_box_rsp& from);

  inline raid_open_box_rsp& operator=(const raid_open_box_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_open_box_rsp& default_instance();

  void Swap(raid_open_box_rsp* other);

  // implements Message ----------------------------------------------

  raid_open_box_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_open_box_rsp& from);
  void MergeFrom(const raid_open_box_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 open_props_ids = 1;
  inline int open_props_ids_size() const;
  inline void clear_open_props_ids();
  static const int kOpenPropsIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 open_props_ids(int index) const;
  inline void set_open_props_ids(int index, ::google::protobuf::uint32 value);
  inline void add_open_props_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      open_props_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_open_props_ids();

  // repeated uint32 close_props_ids = 2;
  inline int close_props_ids_size() const;
  inline void clear_close_props_ids();
  static const int kClosePropsIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 close_props_ids(int index) const;
  inline void set_close_props_ids(int index, ::google::protobuf::uint32 value);
  inline void add_close_props_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      close_props_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_close_props_ids();

  // @@protoc_insertion_point(class_scope:client.raid_open_box_rsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > open_props_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > close_props_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_open_box_rsp* default_instance_;
};
// -------------------------------------------------------------------

class raid_result_info : public ::google::protobuf::Message {
 public:
  raid_result_info();
  virtual ~raid_result_info();

  raid_result_info(const raid_result_info& from);

  inline raid_result_info& operator=(const raid_result_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_result_info& default_instance();

  void Swap(raid_result_info* other);

  // implements Message ----------------------------------------------

  raid_result_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_result_info& from);
  void MergeFrom(const raid_result_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_data rd = 1;
  inline bool has_rd() const;
  inline void clear_rd();
  static const int kRdFieldNumber = 1;
  inline const ::client::role_data& rd() const;
  inline ::client::role_data* mutable_rd();
  inline ::client::role_data* release_rd();
  inline void set_allocated_rd(::client::role_data* rd);

  // repeated .client.props_info props = 2;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 2;
  inline const ::client::props_info& props(int index) const;
  inline ::client::props_info* mutable_props(int index);
  inline ::client::props_info* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
      mutable_props();

  // optional uint32 coin = 3 [default = 0];
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 3;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // optional uint32 exp = 4 [default = 0];
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional uint32 tao_lue = 5 [default = 0];
  inline bool has_tao_lue() const;
  inline void clear_tao_lue();
  static const int kTaoLueFieldNumber = 5;
  inline ::google::protobuf::uint32 tao_lue() const;
  inline void set_tao_lue(::google::protobuf::uint32 value);

  // optional uint32 strategy = 6 [default = 0];
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 6;
  inline ::google::protobuf::uint32 strategy() const;
  inline void set_strategy(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.raid_result_info)
 private:
  inline void set_has_rd();
  inline void clear_has_rd();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_tao_lue();
  inline void clear_has_tao_lue();
  inline void set_has_strategy();
  inline void clear_has_strategy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_data* rd_;
  ::google::protobuf::RepeatedPtrField< ::client::props_info > props_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 tao_lue_;
  ::google::protobuf::uint32 strategy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_result_info* default_instance_;
};
// -------------------------------------------------------------------

class raid_success_ic : public ::google::protobuf::Message {
 public:
  raid_success_ic();
  virtual ~raid_success_ic();

  raid_success_ic(const raid_success_ic& from);

  inline raid_success_ic& operator=(const raid_success_ic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_success_ic& default_instance();

  void Swap(raid_success_ic* other);

  // implements Message ----------------------------------------------

  raid_success_ic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_success_ic& from);
  void MergeFrom(const raid_success_ic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.raid_success_ic)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_success_ic* default_instance_;
};
// -------------------------------------------------------------------

class raid_success_info : public ::google::protobuf::Message {
 public:
  raid_success_info();
  virtual ~raid_success_info();

  raid_success_info(const raid_success_info& from);

  inline raid_success_info& operator=(const raid_success_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_success_info& default_instance();

  void Swap(raid_success_info* other);

  // implements Message ----------------------------------------------

  raid_success_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_success_info& from);
  void MergeFrom(const raid_success_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .client.raid_success_ic role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline const ::client::raid_success_ic& role() const;
  inline ::client::raid_success_ic* mutable_role();
  inline ::client::raid_success_ic* release_role();
  inline void set_allocated_role(::client::raid_success_ic* role);

  // optional .client.raid_success_ic item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::client::raid_success_ic& item() const;
  inline ::client::raid_success_ic* mutable_item();
  inline ::client::raid_success_ic* release_item();
  inline void set_allocated_item(::client::raid_success_ic* item);

  // optional .client.raid_success_ic touch = 3;
  inline bool has_touch() const;
  inline void clear_touch();
  static const int kTouchFieldNumber = 3;
  inline const ::client::raid_success_ic& touch() const;
  inline ::client::raid_success_ic* mutable_touch();
  inline ::client::raid_success_ic* release_touch();
  inline void set_allocated_touch(::client::raid_success_ic* touch);

  // optional .client.raid_success_ic pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline const ::client::raid_success_ic& pos() const;
  inline ::client::raid_success_ic* mutable_pos();
  inline ::client::raid_success_ic* release_pos();
  inline void set_allocated_pos(::client::raid_success_ic* pos);

  // optional .client.raid_success_ic block = 5;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 5;
  inline const ::client::raid_success_ic& block() const;
  inline ::client::raid_success_ic* mutable_block();
  inline ::client::raid_success_ic* release_block();
  inline void set_allocated_block(::client::raid_success_ic* block);

  // @@protoc_insertion_point(class_scope:client.raid_success_info)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_touch();
  inline void clear_has_touch();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_block();
  inline void clear_has_block();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::raid_success_ic* role_;
  ::client::raid_success_ic* item_;
  ::client::raid_success_ic* touch_;
  ::client::raid_success_ic* pos_;
  ::client::raid_success_ic* block_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_success_info* default_instance_;
};
// -------------------------------------------------------------------

class raid_failure_info : public ::google::protobuf::Message {
 public:
  raid_failure_info();
  virtual ~raid_failure_info();

  raid_failure_info(const raid_failure_info& from);

  inline raid_failure_info& operator=(const raid_failure_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_failure_info& default_instance();

  void Swap(raid_failure_info* other);

  // implements Message ----------------------------------------------

  raid_failure_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_failure_info& from);
  void MergeFrom(const raid_failure_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool hero_dead = 1;
  inline bool has_hero_dead() const;
  inline void clear_hero_dead();
  static const int kHeroDeadFieldNumber = 1;
  inline bool hero_dead() const;
  inline void set_hero_dead(bool value);

  // optional uint32 role_dead = 2;
  inline bool has_role_dead() const;
  inline void clear_role_dead();
  static const int kRoleDeadFieldNumber = 2;
  inline ::google::protobuf::uint32 role_dead() const;
  inline void set_role_dead(::google::protobuf::uint32 value);

  // optional uint32 timeout = 3;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional uint32 dead_count = 4;
  inline bool has_dead_count() const;
  inline void clear_dead_count();
  static const int kDeadCountFieldNumber = 4;
  inline ::google::protobuf::uint32 dead_count() const;
  inline void set_dead_count(::google::protobuf::uint32 value);

  // optional uint32 vip_dead = 5;
  inline bool has_vip_dead() const;
  inline void clear_vip_dead();
  static const int kVipDeadFieldNumber = 5;
  inline ::google::protobuf::uint32 vip_dead() const;
  inline void set_vip_dead(::google::protobuf::uint32 value);

  // optional uint32 monster = 6;
  inline bool has_monster() const;
  inline void clear_monster();
  static const int kMonsterFieldNumber = 6;
  inline ::google::protobuf::uint32 monster() const;
  inline void set_monster(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.raid_failure_info)
 private:
  inline void set_has_hero_dead();
  inline void clear_has_hero_dead();
  inline void set_has_role_dead();
  inline void clear_has_role_dead();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_dead_count();
  inline void clear_has_dead_count();
  inline void set_has_vip_dead();
  inline void clear_has_vip_dead();
  inline void set_has_monster();
  inline void clear_has_monster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool hero_dead_;
  ::google::protobuf::uint32 role_dead_;
  ::google::protobuf::uint32 timeout_;
  ::google::protobuf::uint32 dead_count_;
  ::google::protobuf::uint32 vip_dead_;
  ::google::protobuf::uint32 monster_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_failure_info* default_instance_;
};
// -------------------------------------------------------------------

class raid_result_msg : public ::google::protobuf::Message {
 public:
  raid_result_msg();
  virtual ~raid_result_msg();

  raid_result_msg(const raid_result_msg& from);

  inline raid_result_msg& operator=(const raid_result_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_result_msg& default_instance();

  void Swap(raid_result_msg* other);

  // implements Message ----------------------------------------------

  raid_result_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_result_msg& from);
  void MergeFrom(const raid_result_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 raid_id = 1;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // required uint32 star = 2;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 2;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // required uint32 tick = 3;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 3;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // repeated .client.raid_result_info info = 4;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 4;
  inline const ::client::raid_result_info& info(int index) const;
  inline ::client::raid_result_info* mutable_info(int index);
  inline ::client::raid_result_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >*
      mutable_info();

  // optional .client.raid_success_info success = 5;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 5;
  inline const ::client::raid_success_info& success() const;
  inline ::client::raid_success_info* mutable_success();
  inline ::client::raid_success_info* release_success();
  inline void set_allocated_success(::client::raid_success_info* success);

  // optional .client.raid_failure_info failure = 6;
  inline bool has_failure() const;
  inline void clear_failure();
  static const int kFailureFieldNumber = 6;
  inline const ::client::raid_failure_info& failure() const;
  inline ::client::raid_failure_info* mutable_failure();
  inline ::client::raid_failure_info* release_failure();
  inline void set_allocated_failure(::client::raid_failure_info* failure);

  // optional uint32 rep = 7;
  inline bool has_rep() const;
  inline void clear_rep();
  static const int kRepFieldNumber = 7;
  inline ::google::protobuf::uint32 rep() const;
  inline void set_rep(::google::protobuf::uint32 value);

  // optional .client.raid_verify verify = 8;
  inline bool has_verify() const;
  inline void clear_verify();
  static const int kVerifyFieldNumber = 8;
  inline const ::client::raid_verify& verify() const;
  inline ::client::raid_verify* mutable_verify();
  inline ::client::raid_verify* release_verify();
  inline void set_allocated_verify(::client::raid_verify* verify);

  // optional string value1 = 9;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 9;
  inline const ::std::string& value1() const;
  inline void set_value1(const ::std::string& value);
  inline void set_value1(const char* value);
  inline void set_value1(const char* value, size_t size);
  inline ::std::string* mutable_value1();
  inline ::std::string* release_value1();
  inline void set_allocated_value1(::std::string* value1);

  // optional uint32 value2 = 10;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 10;
  inline ::google::protobuf::uint32 value2() const;
  inline void set_value2(::google::protobuf::uint32 value);

  // repeated .client.raid_result_info reward1 = 11;
  inline int reward1_size() const;
  inline void clear_reward1();
  static const int kReward1FieldNumber = 11;
  inline const ::client::raid_result_info& reward1(int index) const;
  inline ::client::raid_result_info* mutable_reward1(int index);
  inline ::client::raid_result_info* add_reward1();
  inline const ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >&
      reward1() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >*
      mutable_reward1();

  // repeated .client.raid_result_info reward2 = 12;
  inline int reward2_size() const;
  inline void clear_reward2();
  static const int kReward2FieldNumber = 12;
  inline const ::client::raid_result_info& reward2(int index) const;
  inline ::client::raid_result_info* mutable_reward2(int index);
  inline ::client::raid_result_info* add_reward2();
  inline const ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >&
      reward2() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >*
      mutable_reward2();

  // @@protoc_insertion_point(class_scope:client.raid_result_msg)
 private:
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_tick();
  inline void clear_has_tick();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_failure();
  inline void clear_has_failure();
  inline void set_has_rep();
  inline void clear_has_rep();
  inline void set_has_verify();
  inline void clear_has_verify();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 raid_id_;
  ::google::protobuf::uint32 star_;
  ::google::protobuf::RepeatedPtrField< ::client::raid_result_info > info_;
  ::client::raid_success_info* success_;
  ::google::protobuf::uint32 tick_;
  ::google::protobuf::uint32 rep_;
  ::client::raid_failure_info* failure_;
  ::client::raid_verify* verify_;
  ::std::string* value1_;
  ::google::protobuf::RepeatedPtrField< ::client::raid_result_info > reward1_;
  ::google::protobuf::RepeatedPtrField< ::client::raid_result_info > reward2_;
  ::google::protobuf::uint32 value2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_result_msg* default_instance_;
};
// -------------------------------------------------------------------

class raid_npc_creazed : public ::google::protobuf::Message {
 public:
  raid_npc_creazed();
  virtual ~raid_npc_creazed();

  raid_npc_creazed(const raid_npc_creazed& from);

  inline raid_npc_creazed& operator=(const raid_npc_creazed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_npc_creazed& default_instance();

  void Swap(raid_npc_creazed* other);

  // implements Message ----------------------------------------------

  raid_npc_creazed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_npc_creazed& from);
  void MergeFrom(const raid_npc_creazed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 raid_id = 1;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.raid_npc_creazed)
 private:
  inline void set_has_raid_id();
  inline void clear_has_raid_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 raid_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_npc_creazed* default_instance_;
};
// -------------------------------------------------------------------

class auto_raid_req : public ::google::protobuf::Message {
 public:
  auto_raid_req();
  virtual ~auto_raid_req();

  auto_raid_req(const auto_raid_req& from);

  inline auto_raid_req& operator=(const auto_raid_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auto_raid_req& default_instance();

  void Swap(auto_raid_req* other);

  // implements Message ----------------------------------------------

  auto_raid_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auto_raid_req& from);
  void MergeFrom(const auto_raid_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 t = 3;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 3;
  inline ::google::protobuf::uint32 t() const;
  inline void set_t(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.auto_raid_req)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;
  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 t_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static auto_raid_req* default_instance_;
};
// -------------------------------------------------------------------

class auto_raid_rsp : public ::google::protobuf::Message {
 public:
  auto_raid_rsp();
  virtual ~auto_raid_rsp();

  auto_raid_rsp(const auto_raid_rsp& from);

  inline auto_raid_rsp& operator=(const auto_raid_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auto_raid_rsp& default_instance();

  void Swap(auto_raid_rsp* other);

  // implements Message ----------------------------------------------

  auto_raid_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auto_raid_rsp& from);
  void MergeFrom(const auto_raid_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.auto_raid_rsp)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static auto_raid_rsp* default_instance_;
};
// -------------------------------------------------------------------

class auto_raid_info : public ::google::protobuf::Message {
 public:
  auto_raid_info();
  virtual ~auto_raid_info();

  auto_raid_info(const auto_raid_info& from);

  inline auto_raid_info& operator=(const auto_raid_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auto_raid_info& default_instance();

  void Swap(auto_raid_info* other);

  // implements Message ----------------------------------------------

  auto_raid_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auto_raid_info& from);
  void MergeFrom(const auto_raid_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // required uint32 need_time = 4;
  inline bool has_need_time() const;
  inline void clear_need_time();
  static const int kNeedTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 need_time() const;
  inline void set_need_time(::google::protobuf::uint32 value);

  // required uint32 frozen_silver = 5;
  inline bool has_frozen_silver() const;
  inline void clear_frozen_silver();
  static const int kFrozenSilverFieldNumber = 5;
  inline ::google::protobuf::uint32 frozen_silver() const;
  inline void set_frozen_silver(::google::protobuf::uint32 value);

  // required uint32 frozen_physical_power = 6;
  inline bool has_frozen_physical_power() const;
  inline void clear_frozen_physical_power();
  static const int kFrozenPhysicalPowerFieldNumber = 6;
  inline ::google::protobuf::uint32 frozen_physical_power() const;
  inline void set_frozen_physical_power(::google::protobuf::uint32 value);

  // required uint32 count = 7;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 7;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 monster = 8;
  inline bool has_monster() const;
  inline void clear_monster();
  static const int kMonsterFieldNumber = 8;
  inline ::google::protobuf::uint32 monster() const;
  inline void set_monster(::google::protobuf::uint32 value);

  // required uint32 exp = 9;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 9;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // required uint32 coin = 10;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 10;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // required uint32 military_strategy = 11;
  inline bool has_military_strategy() const;
  inline void clear_military_strategy();
  static const int kMilitaryStrategyFieldNumber = 11;
  inline ::google::protobuf::uint32 military_strategy() const;
  inline void set_military_strategy(::google::protobuf::uint32 value);

  // repeated .client.props_info props = 12;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 12;
  inline const ::client::props_info& props(int index) const;
  inline ::client::props_info* mutable_props(int index);
  inline ::client::props_info* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
      mutable_props();

  // @@protoc_insertion_point(class_scope:client.auto_raid_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_need_time();
  inline void clear_has_need_time();
  inline void set_has_frozen_silver();
  inline void clear_has_frozen_silver();
  inline void set_has_frozen_physical_power();
  inline void clear_has_frozen_physical_power();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_monster();
  inline void clear_has_monster();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_military_strategy();
  inline void clear_has_military_strategy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 need_time_;
  ::google::protobuf::uint32 frozen_silver_;
  ::google::protobuf::uint32 frozen_physical_power_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 monster_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::RepeatedPtrField< ::client::props_info > props_;
  ::google::protobuf::uint32 military_strategy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static auto_raid_info* default_instance_;
};
// -------------------------------------------------------------------

class auto_raid_msg : public ::google::protobuf::Message {
 public:
  auto_raid_msg();
  virtual ~auto_raid_msg();

  auto_raid_msg(const auto_raid_msg& from);

  inline auto_raid_msg& operator=(const auto_raid_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auto_raid_msg& default_instance();

  void Swap(auto_raid_msg* other);

  // implements Message ----------------------------------------------

  auto_raid_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auto_raid_msg& from);
  void MergeFrom(const auto_raid_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.auto_raid_info info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::client::auto_raid_info& info() const;
  inline ::client::auto_raid_info* mutable_info();
  inline ::client::auto_raid_info* release_info();
  inline void set_allocated_info(::client::auto_raid_info* info);

  // @@protoc_insertion_point(class_scope:client.auto_raid_msg)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::auto_raid_info* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static auto_raid_msg* default_instance_;
};
// -------------------------------------------------------------------

class mini_server_req : public ::google::protobuf::Message {
 public:
  mini_server_req();
  virtual ~mini_server_req();

  mini_server_req(const mini_server_req& from);

  inline mini_server_req& operator=(const mini_server_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mini_server_req& default_instance();

  void Swap(mini_server_req* other);

  // implements Message ----------------------------------------------

  mini_server_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mini_server_req& from);
  void MergeFrom(const mini_server_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::google::protobuf::uint32 op() const;
  inline void set_op(::google::protobuf::uint32 value);

  // required uint32 raid_id = 2;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 2;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // optional uint32 raid_type = 3;
  inline bool has_raid_type() const;
  inline void clear_raid_type();
  static const int kRaidTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 raid_type() const;
  inline void set_raid_type(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.mini_server_req)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_raid_type();
  inline void clear_has_raid_type();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 op_;
  ::google::protobuf::uint32 raid_id_;
  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 raid_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static mini_server_req* default_instance_;
};
// -------------------------------------------------------------------

class mini_server_rsp : public ::google::protobuf::Message {
 public:
  mini_server_rsp();
  virtual ~mini_server_rsp();

  mini_server_rsp(const mini_server_rsp& from);

  inline mini_server_rsp& operator=(const mini_server_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mini_server_rsp& default_instance();

  void Swap(mini_server_rsp* other);

  // implements Message ----------------------------------------------

  mini_server_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mini_server_rsp& from);
  void MergeFrom(const mini_server_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::google::protobuf::uint32 op() const;
  inline void set_op(::google::protobuf::uint32 value);

  // required uint32 raid_id = 2;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 2;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // optional uint32 raid_type = 3;
  inline bool has_raid_type() const;
  inline void clear_raid_type();
  static const int kRaidTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 raid_type() const;
  inline void set_raid_type(::google::protobuf::uint32 value);

  // required uint32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 ret = 5;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 5;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.mini_server_rsp)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_raid_type();
  inline void clear_has_raid_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 op_;
  ::google::protobuf::uint32 raid_id_;
  ::google::protobuf::uint32 raid_type_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static mini_server_rsp* default_instance_;
};
// -------------------------------------------------------------------

class mini_server_end_msg : public ::google::protobuf::Message {
 public:
  mini_server_end_msg();
  virtual ~mini_server_end_msg();

  mini_server_end_msg(const mini_server_end_msg& from);

  inline mini_server_end_msg& operator=(const mini_server_end_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mini_server_end_msg& default_instance();

  void Swap(mini_server_end_msg* other);

  // implements Message ----------------------------------------------

  mini_server_end_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mini_server_end_msg& from);
  void MergeFrom(const mini_server_end_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.raid_result_msg msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::client::raid_result_msg& msg() const;
  inline ::client::raid_result_msg* mutable_msg();
  inline ::client::raid_result_msg* release_msg();
  inline void set_allocated_msg(::client::raid_result_msg* msg);

  // optional uint32 rep = 2;
  inline bool has_rep() const;
  inline void clear_rep();
  static const int kRepFieldNumber = 2;
  inline ::google::protobuf::uint32 rep() const;
  inline void set_rep(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.mini_server_end_msg)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_rep();
  inline void clear_has_rep();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::raid_result_msg* msg_;
  ::google::protobuf::uint32 rep_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static mini_server_end_msg* default_instance_;
};
// -------------------------------------------------------------------

class raid_verify : public ::google::protobuf::Message {
 public:
  raid_verify();
  virtual ~raid_verify();

  raid_verify(const raid_verify& from);

  inline raid_verify& operator=(const raid_verify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const raid_verify& default_instance();

  void Swap(raid_verify* other);

  // implements Message ----------------------------------------------

  raid_verify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const raid_verify& from);
  void MergeFrom(const raid_verify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 max_hp = 1;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 1;
  inline ::google::protobuf::uint32 max_hp() const;
  inline void set_max_hp(::google::protobuf::uint32 value);

  // required uint32 max_atk = 2;
  inline bool has_max_atk() const;
  inline void clear_max_atk();
  static const int kMaxAtkFieldNumber = 2;
  inline ::google::protobuf::uint32 max_atk() const;
  inline void set_max_atk(::google::protobuf::uint32 value);

  // required uint32 max_def = 3;
  inline bool has_max_def() const;
  inline void clear_max_def();
  static const int kMaxDefFieldNumber = 3;
  inline ::google::protobuf::uint32 max_def() const;
  inline void set_max_def(::google::protobuf::uint32 value);

  // required uint32 bow_index = 4;
  inline bool has_bow_index() const;
  inline void clear_bow_index();
  static const int kBowIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 bow_index() const;
  inline void set_bow_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.raid_verify)
 private:
  inline void set_has_max_hp();
  inline void clear_has_max_hp();
  inline void set_has_max_atk();
  inline void clear_has_max_atk();
  inline void set_has_max_def();
  inline void clear_has_max_def();
  inline void set_has_bow_index();
  inline void clear_has_bow_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 max_hp_;
  ::google::protobuf::uint32 max_atk_;
  ::google::protobuf::uint32 max_def_;
  ::google::protobuf::uint32 bow_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static raid_verify* default_instance_;
};
// -------------------------------------------------------------------

class reported_raid_info : public ::google::protobuf::Message {
 public:
  reported_raid_info();
  virtual ~reported_raid_info();

  reported_raid_info(const reported_raid_info& from);

  inline reported_raid_info& operator=(const reported_raid_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reported_raid_info& default_instance();

  void Swap(reported_raid_info* other);

  // implements Message ----------------------------------------------

  reported_raid_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reported_raid_info& from);
  void MergeFrom(const reported_raid_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 star = 2;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 2;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // required uint32 used_tick = 3;
  inline bool has_used_tick() const;
  inline void clear_used_tick();
  static const int kUsedTickFieldNumber = 3;
  inline ::google::protobuf::uint32 used_tick() const;
  inline void set_used_tick(::google::protobuf::uint32 value);

  // required uint32 complete_time = 4;
  inline bool has_complete_time() const;
  inline void clear_complete_time();
  static const int kCompleteTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 complete_time() const;
  inline void set_complete_time(::google::protobuf::uint32 value);

  // required uint32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required string key = 7;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 7;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .client.raid_success_info success = 8;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 8;
  inline const ::client::raid_success_info& success() const;
  inline ::client::raid_success_info* mutable_success();
  inline ::client::raid_success_info* release_success();
  inline void set_allocated_success(::client::raid_success_info* success);

  // optional .client.raid_failure_info failure = 9;
  inline bool has_failure() const;
  inline void clear_failure();
  static const int kFailureFieldNumber = 9;
  inline const ::client::raid_failure_info& failure() const;
  inline ::client::raid_failure_info* mutable_failure();
  inline ::client::raid_failure_info* release_failure();
  inline void set_allocated_failure(::client::raid_failure_info* failure);

  // required .client.raid_verify verify = 10;
  inline bool has_verify() const;
  inline void clear_verify();
  static const int kVerifyFieldNumber = 10;
  inline const ::client::raid_verify& verify() const;
  inline ::client::raid_verify* mutable_verify();
  inline ::client::raid_verify* release_verify();
  inline void set_allocated_verify(::client::raid_verify* verify);

  // @@protoc_insertion_point(class_scope:client.reported_raid_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_used_tick();
  inline void clear_has_used_tick();
  inline void set_has_complete_time();
  inline void clear_has_complete_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_failure();
  inline void clear_has_failure();
  inline void set_has_verify();
  inline void clear_has_verify();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 star_;
  ::google::protobuf::uint32 used_tick_;
  ::google::protobuf::uint32 complete_time_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 time_;
  ::std::string* key_;
  ::client::raid_success_info* success_;
  ::client::raid_failure_info* failure_;
  ::client::raid_verify* verify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static reported_raid_info* default_instance_;
};
// -------------------------------------------------------------------

class reported_raid_req : public ::google::protobuf::Message {
 public:
  reported_raid_req();
  virtual ~reported_raid_req();

  reported_raid_req(const reported_raid_req& from);

  inline reported_raid_req& operator=(const reported_raid_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reported_raid_req& default_instance();

  void Swap(reported_raid_req* other);

  // implements Message ----------------------------------------------

  reported_raid_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reported_raid_req& from);
  void MergeFrom(const reported_raid_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.reported_raid_info rri = 1;
  inline int rri_size() const;
  inline void clear_rri();
  static const int kRriFieldNumber = 1;
  inline const ::client::reported_raid_info& rri(int index) const;
  inline ::client::reported_raid_info* mutable_rri(int index);
  inline ::client::reported_raid_info* add_rri();
  inline const ::google::protobuf::RepeatedPtrField< ::client::reported_raid_info >&
      rri() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::reported_raid_info >*
      mutable_rri();

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.reported_raid_req)
 private:
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::reported_raid_info > rri_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static reported_raid_req* default_instance_;
};
// -------------------------------------------------------------------

class create_npc_msg : public ::google::protobuf::Message {
 public:
  create_npc_msg();
  virtual ~create_npc_msg();

  create_npc_msg(const create_npc_msg& from);

  inline create_npc_msg& operator=(const create_npc_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const create_npc_msg& default_instance();

  void Swap(create_npc_msg* other);

  // implements Message ----------------------------------------------

  create_npc_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const create_npc_msg& from);
  void MergeFrom(const create_npc_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required uint32 delay = 2;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 2;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // required uint32 show = 3;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 3;
  inline ::google::protobuf::uint32 show() const;
  inline void set_show(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.create_npc_msg)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_show();
  inline void clear_has_show();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::google::protobuf::uint32 delay_;
  ::google::protobuf::uint32 show_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static create_npc_msg* default_instance_;
};
// -------------------------------------------------------------------

class dead_in_raid : public ::google::protobuf::Message {
 public:
  dead_in_raid();
  virtual ~dead_in_raid();

  dead_in_raid(const dead_in_raid& from);

  inline dead_in_raid& operator=(const dead_in_raid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dead_in_raid& default_instance();

  void Swap(dead_in_raid* other);

  // implements Message ----------------------------------------------

  dead_in_raid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dead_in_raid& from);
  void MergeFrom(const dead_in_raid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.dead_in_raid)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_AssignDesc_client_2eraid_5foperate_2eproto();
  friend void protobuf_ShutdownFile_client_2eraid_5foperate_2eproto();

  void InitAsDefaultInstance();
  static dead_in_raid* default_instance_;
};
// ===================================================================


// ===================================================================

// raid_info

// required uint32 raid_id = 1;
inline bool raid_info::has_raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_info::set_has_raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_info::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_info::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 raid_info::raid_id() const {
  return raid_id_;
}
inline void raid_info::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// required uint32 star_num = 2;
inline bool raid_info::has_star_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void raid_info::set_has_star_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void raid_info::clear_has_star_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void raid_info::clear_star_num() {
  star_num_ = 0u;
  clear_has_star_num();
}
inline ::google::protobuf::uint32 raid_info::star_num() const {
  return star_num_;
}
inline void raid_info::set_star_num(::google::protobuf::uint32 value) {
  set_has_star_num();
  star_num_ = value;
}

// required uint32 fast_tick = 3;
inline bool raid_info::has_fast_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void raid_info::set_has_fast_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void raid_info::clear_has_fast_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void raid_info::clear_fast_tick() {
  fast_tick_ = 0u;
  clear_has_fast_tick();
}
inline ::google::protobuf::uint32 raid_info::fast_tick() const {
  return fast_tick_;
}
inline void raid_info::set_fast_tick(::google::protobuf::uint32 value) {
  set_has_fast_tick();
  fast_tick_ = value;
}

// required uint32 last_complete_time = 4;
inline bool raid_info::has_last_complete_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void raid_info::set_has_last_complete_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void raid_info::clear_has_last_complete_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void raid_info::clear_last_complete_time() {
  last_complete_time_ = 0u;
  clear_has_last_complete_time();
}
inline ::google::protobuf::uint32 raid_info::last_complete_time() const {
  return last_complete_time_;
}
inline void raid_info::set_last_complete_time(::google::protobuf::uint32 value) {
  set_has_last_complete_time();
  last_complete_time_ = value;
}

// required uint32 complete_count = 5;
inline bool raid_info::has_complete_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void raid_info::set_has_complete_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void raid_info::clear_has_complete_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void raid_info::clear_complete_count() {
  complete_count_ = 0u;
  clear_has_complete_count();
}
inline ::google::protobuf::uint32 raid_info::complete_count() const {
  return complete_count_;
}
inline void raid_info::set_complete_count(::google::protobuf::uint32 value) {
  set_has_complete_count();
  complete_count_ = value;
}

// required uint32 create_time = 6;
inline bool raid_info::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void raid_info::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void raid_info::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void raid_info::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 raid_info::create_time() const {
  return create_time_;
}
inline void raid_info::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
}

// required uint32 auto_time = 7;
inline bool raid_info::has_auto_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void raid_info::set_has_auto_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void raid_info::clear_has_auto_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void raid_info::clear_auto_time() {
  auto_time_ = 0u;
  clear_has_auto_time();
}
inline ::google::protobuf::uint32 raid_info::auto_time() const {
  return auto_time_;
}
inline void raid_info::set_auto_time(::google::protobuf::uint32 value) {
  set_has_auto_time();
  auto_time_ = value;
}

// required uint32 elite_star_num = 8;
inline bool raid_info::has_elite_star_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void raid_info::set_has_elite_star_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void raid_info::clear_has_elite_star_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void raid_info::clear_elite_star_num() {
  elite_star_num_ = 0u;
  clear_has_elite_star_num();
}
inline ::google::protobuf::uint32 raid_info::elite_star_num() const {
  return elite_star_num_;
}
inline void raid_info::set_elite_star_num(::google::protobuf::uint32 value) {
  set_has_elite_star_num();
  elite_star_num_ = value;
}

// required uint32 elite_fast_tick = 9;
inline bool raid_info::has_elite_fast_tick() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void raid_info::set_has_elite_fast_tick() {
  _has_bits_[0] |= 0x00000100u;
}
inline void raid_info::clear_has_elite_fast_tick() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void raid_info::clear_elite_fast_tick() {
  elite_fast_tick_ = 0u;
  clear_has_elite_fast_tick();
}
inline ::google::protobuf::uint32 raid_info::elite_fast_tick() const {
  return elite_fast_tick_;
}
inline void raid_info::set_elite_fast_tick(::google::protobuf::uint32 value) {
  set_has_elite_fast_tick();
  elite_fast_tick_ = value;
}

// required uint32 elite_last_complete_time = 10;
inline bool raid_info::has_elite_last_complete_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void raid_info::set_has_elite_last_complete_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void raid_info::clear_has_elite_last_complete_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void raid_info::clear_elite_last_complete_time() {
  elite_last_complete_time_ = 0u;
  clear_has_elite_last_complete_time();
}
inline ::google::protobuf::uint32 raid_info::elite_last_complete_time() const {
  return elite_last_complete_time_;
}
inline void raid_info::set_elite_last_complete_time(::google::protobuf::uint32 value) {
  set_has_elite_last_complete_time();
  elite_last_complete_time_ = value;
}

// required uint32 elite_complete_count = 11;
inline bool raid_info::has_elite_complete_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void raid_info::set_has_elite_complete_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void raid_info::clear_has_elite_complete_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void raid_info::clear_elite_complete_count() {
  elite_complete_count_ = 0u;
  clear_has_elite_complete_count();
}
inline ::google::protobuf::uint32 raid_info::elite_complete_count() const {
  return elite_complete_count_;
}
inline void raid_info::set_elite_complete_count(::google::protobuf::uint32 value) {
  set_has_elite_complete_count();
  elite_complete_count_ = value;
}

// required uint32 elite_create_time = 12;
inline bool raid_info::has_elite_create_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void raid_info::set_has_elite_create_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void raid_info::clear_has_elite_create_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void raid_info::clear_elite_create_time() {
  elite_create_time_ = 0u;
  clear_has_elite_create_time();
}
inline ::google::protobuf::uint32 raid_info::elite_create_time() const {
  return elite_create_time_;
}
inline void raid_info::set_elite_create_time(::google::protobuf::uint32 value) {
  set_has_elite_create_time();
  elite_create_time_ = value;
}

// required uint32 elite_auto_time = 13;
inline bool raid_info::has_elite_auto_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void raid_info::set_has_elite_auto_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void raid_info::clear_has_elite_auto_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void raid_info::clear_elite_auto_time() {
  elite_auto_time_ = 0u;
  clear_has_elite_auto_time();
}
inline ::google::protobuf::uint32 raid_info::elite_auto_time() const {
  return elite_auto_time_;
}
inline void raid_info::set_elite_auto_time(::google::protobuf::uint32 value) {
  set_has_elite_auto_time();
  elite_auto_time_ = value;
}

// required uint32 elite_enter_count = 14;
inline bool raid_info::has_elite_enter_count() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void raid_info::set_has_elite_enter_count() {
  _has_bits_[0] |= 0x00002000u;
}
inline void raid_info::clear_has_elite_enter_count() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void raid_info::clear_elite_enter_count() {
  elite_enter_count_ = 0u;
  clear_has_elite_enter_count();
}
inline ::google::protobuf::uint32 raid_info::elite_enter_count() const {
  return elite_enter_count_;
}
inline void raid_info::set_elite_enter_count(::google::protobuf::uint32 value) {
  set_has_elite_enter_count();
  elite_enter_count_ = value;
}

// -------------------------------------------------------------------

// raid_info_msg

// repeated .client.raid_info ri = 1;
inline int raid_info_msg::ri_size() const {
  return ri_.size();
}
inline void raid_info_msg::clear_ri() {
  ri_.Clear();
}
inline const ::client::raid_info& raid_info_msg::ri(int index) const {
  return ri_.Get(index);
}
inline ::client::raid_info* raid_info_msg::mutable_ri(int index) {
  return ri_.Mutable(index);
}
inline ::client::raid_info* raid_info_msg::add_ri() {
  return ri_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::raid_info >&
raid_info_msg::ri() const {
  return ri_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::raid_info >*
raid_info_msg::mutable_ri() {
  return &ri_;
}

// -------------------------------------------------------------------

// enter_raid_req

// required uint32 raid_id = 1;
inline bool enter_raid_req::has_raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enter_raid_req::set_has_raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enter_raid_req::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enter_raid_req::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 enter_raid_req::raid_id() const {
  return raid_id_;
}
inline void enter_raid_req::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// optional uint32 t = 2;
inline bool enter_raid_req::has_t() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void enter_raid_req::set_has_t() {
  _has_bits_[0] |= 0x00000002u;
}
inline void enter_raid_req::clear_has_t() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void enter_raid_req::clear_t() {
  t_ = 0u;
  clear_has_t();
}
inline ::google::protobuf::uint32 enter_raid_req::t() const {
  return t_;
}
inline void enter_raid_req::set_t(::google::protobuf::uint32 value) {
  set_has_t();
  t_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool enter_raid_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void enter_raid_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void enter_raid_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void enter_raid_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& enter_raid_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* enter_raid_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* enter_raid_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void enter_raid_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// exit_raid_req

// required uint32 raid_id = 1;
inline bool exit_raid_req::has_raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exit_raid_req::set_has_raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exit_raid_req::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exit_raid_req::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 exit_raid_req::raid_id() const {
  return raid_id_;
}
inline void exit_raid_req::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool exit_raid_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exit_raid_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exit_raid_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exit_raid_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& exit_raid_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* exit_raid_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* exit_raid_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void exit_raid_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// raid_open_box_req

// required uint32 unixtime = 1;
inline bool raid_open_box_req::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_open_box_req::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_open_box_req::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_open_box_req::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 raid_open_box_req::unixtime() const {
  return unixtime_;
}
inline void raid_open_box_req::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool raid_open_box_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void raid_open_box_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void raid_open_box_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void raid_open_box_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& raid_open_box_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* raid_open_box_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* raid_open_box_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void raid_open_box_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// raid_open_box_rsp

// repeated uint32 open_props_ids = 1;
inline int raid_open_box_rsp::open_props_ids_size() const {
  return open_props_ids_.size();
}
inline void raid_open_box_rsp::clear_open_props_ids() {
  open_props_ids_.Clear();
}
inline ::google::protobuf::uint32 raid_open_box_rsp::open_props_ids(int index) const {
  return open_props_ids_.Get(index);
}
inline void raid_open_box_rsp::set_open_props_ids(int index, ::google::protobuf::uint32 value) {
  open_props_ids_.Set(index, value);
}
inline void raid_open_box_rsp::add_open_props_ids(::google::protobuf::uint32 value) {
  open_props_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
raid_open_box_rsp::open_props_ids() const {
  return open_props_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
raid_open_box_rsp::mutable_open_props_ids() {
  return &open_props_ids_;
}

// repeated uint32 close_props_ids = 2;
inline int raid_open_box_rsp::close_props_ids_size() const {
  return close_props_ids_.size();
}
inline void raid_open_box_rsp::clear_close_props_ids() {
  close_props_ids_.Clear();
}
inline ::google::protobuf::uint32 raid_open_box_rsp::close_props_ids(int index) const {
  return close_props_ids_.Get(index);
}
inline void raid_open_box_rsp::set_close_props_ids(int index, ::google::protobuf::uint32 value) {
  close_props_ids_.Set(index, value);
}
inline void raid_open_box_rsp::add_close_props_ids(::google::protobuf::uint32 value) {
  close_props_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
raid_open_box_rsp::close_props_ids() const {
  return close_props_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
raid_open_box_rsp::mutable_close_props_ids() {
  return &close_props_ids_;
}

// -------------------------------------------------------------------

// raid_result_info

// required .client.role_data rd = 1;
inline bool raid_result_info::has_rd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_result_info::set_has_rd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_result_info::clear_has_rd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_result_info::clear_rd() {
  if (rd_ != NULL) rd_->::client::role_data::Clear();
  clear_has_rd();
}
inline const ::client::role_data& raid_result_info::rd() const {
  return rd_ != NULL ? *rd_ : *default_instance_->rd_;
}
inline ::client::role_data* raid_result_info::mutable_rd() {
  set_has_rd();
  if (rd_ == NULL) rd_ = new ::client::role_data;
  return rd_;
}
inline ::client::role_data* raid_result_info::release_rd() {
  clear_has_rd();
  ::client::role_data* temp = rd_;
  rd_ = NULL;
  return temp;
}
inline void raid_result_info::set_allocated_rd(::client::role_data* rd) {
  delete rd_;
  rd_ = rd;
  if (rd) {
    set_has_rd();
  } else {
    clear_has_rd();
  }
}

// repeated .client.props_info props = 2;
inline int raid_result_info::props_size() const {
  return props_.size();
}
inline void raid_result_info::clear_props() {
  props_.Clear();
}
inline const ::client::props_info& raid_result_info::props(int index) const {
  return props_.Get(index);
}
inline ::client::props_info* raid_result_info::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::client::props_info* raid_result_info::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
raid_result_info::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
raid_result_info::mutable_props() {
  return &props_;
}

// optional uint32 coin = 3 [default = 0];
inline bool raid_result_info::has_coin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void raid_result_info::set_has_coin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void raid_result_info::clear_has_coin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void raid_result_info::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 raid_result_info::coin() const {
  return coin_;
}
inline void raid_result_info::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// optional uint32 exp = 4 [default = 0];
inline bool raid_result_info::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void raid_result_info::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void raid_result_info::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void raid_result_info::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 raid_result_info::exp() const {
  return exp_;
}
inline void raid_result_info::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint32 tao_lue = 5 [default = 0];
inline bool raid_result_info::has_tao_lue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void raid_result_info::set_has_tao_lue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void raid_result_info::clear_has_tao_lue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void raid_result_info::clear_tao_lue() {
  tao_lue_ = 0u;
  clear_has_tao_lue();
}
inline ::google::protobuf::uint32 raid_result_info::tao_lue() const {
  return tao_lue_;
}
inline void raid_result_info::set_tao_lue(::google::protobuf::uint32 value) {
  set_has_tao_lue();
  tao_lue_ = value;
}

// optional uint32 strategy = 6 [default = 0];
inline bool raid_result_info::has_strategy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void raid_result_info::set_has_strategy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void raid_result_info::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void raid_result_info::clear_strategy() {
  strategy_ = 0u;
  clear_has_strategy();
}
inline ::google::protobuf::uint32 raid_result_info::strategy() const {
  return strategy_;
}
inline void raid_result_info::set_strategy(::google::protobuf::uint32 value) {
  set_has_strategy();
  strategy_ = value;
}

// -------------------------------------------------------------------

// raid_success_ic

// required uint32 id = 1;
inline bool raid_success_ic::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_success_ic::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_success_ic::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_success_ic::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 raid_success_ic::id() const {
  return id_;
}
inline void raid_success_ic::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 count = 2;
inline bool raid_success_ic::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void raid_success_ic::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void raid_success_ic::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void raid_success_ic::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 raid_success_ic::count() const {
  return count_;
}
inline void raid_success_ic::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// raid_success_info

// optional .client.raid_success_ic role = 1;
inline bool raid_success_info::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_success_info::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_success_info::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_success_info::clear_role() {
  if (role_ != NULL) role_->::client::raid_success_ic::Clear();
  clear_has_role();
}
inline const ::client::raid_success_ic& raid_success_info::role() const {
  return role_ != NULL ? *role_ : *default_instance_->role_;
}
inline ::client::raid_success_ic* raid_success_info::mutable_role() {
  set_has_role();
  if (role_ == NULL) role_ = new ::client::raid_success_ic;
  return role_;
}
inline ::client::raid_success_ic* raid_success_info::release_role() {
  clear_has_role();
  ::client::raid_success_ic* temp = role_;
  role_ = NULL;
  return temp;
}
inline void raid_success_info::set_allocated_role(::client::raid_success_ic* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
}

// optional .client.raid_success_ic item = 2;
inline bool raid_success_info::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void raid_success_info::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void raid_success_info::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void raid_success_info::clear_item() {
  if (item_ != NULL) item_->::client::raid_success_ic::Clear();
  clear_has_item();
}
inline const ::client::raid_success_ic& raid_success_info::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::client::raid_success_ic* raid_success_info::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::client::raid_success_ic;
  return item_;
}
inline ::client::raid_success_ic* raid_success_info::release_item() {
  clear_has_item();
  ::client::raid_success_ic* temp = item_;
  item_ = NULL;
  return temp;
}
inline void raid_success_info::set_allocated_item(::client::raid_success_ic* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// optional .client.raid_success_ic touch = 3;
inline bool raid_success_info::has_touch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void raid_success_info::set_has_touch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void raid_success_info::clear_has_touch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void raid_success_info::clear_touch() {
  if (touch_ != NULL) touch_->::client::raid_success_ic::Clear();
  clear_has_touch();
}
inline const ::client::raid_success_ic& raid_success_info::touch() const {
  return touch_ != NULL ? *touch_ : *default_instance_->touch_;
}
inline ::client::raid_success_ic* raid_success_info::mutable_touch() {
  set_has_touch();
  if (touch_ == NULL) touch_ = new ::client::raid_success_ic;
  return touch_;
}
inline ::client::raid_success_ic* raid_success_info::release_touch() {
  clear_has_touch();
  ::client::raid_success_ic* temp = touch_;
  touch_ = NULL;
  return temp;
}
inline void raid_success_info::set_allocated_touch(::client::raid_success_ic* touch) {
  delete touch_;
  touch_ = touch;
  if (touch) {
    set_has_touch();
  } else {
    clear_has_touch();
  }
}

// optional .client.raid_success_ic pos = 4;
inline bool raid_success_info::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void raid_success_info::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void raid_success_info::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void raid_success_info::clear_pos() {
  if (pos_ != NULL) pos_->::client::raid_success_ic::Clear();
  clear_has_pos();
}
inline const ::client::raid_success_ic& raid_success_info::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::client::raid_success_ic* raid_success_info::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::client::raid_success_ic;
  return pos_;
}
inline ::client::raid_success_ic* raid_success_info::release_pos() {
  clear_has_pos();
  ::client::raid_success_ic* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void raid_success_info::set_allocated_pos(::client::raid_success_ic* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional .client.raid_success_ic block = 5;
inline bool raid_success_info::has_block() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void raid_success_info::set_has_block() {
  _has_bits_[0] |= 0x00000010u;
}
inline void raid_success_info::clear_has_block() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void raid_success_info::clear_block() {
  if (block_ != NULL) block_->::client::raid_success_ic::Clear();
  clear_has_block();
}
inline const ::client::raid_success_ic& raid_success_info::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::client::raid_success_ic* raid_success_info::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::client::raid_success_ic;
  return block_;
}
inline ::client::raid_success_ic* raid_success_info::release_block() {
  clear_has_block();
  ::client::raid_success_ic* temp = block_;
  block_ = NULL;
  return temp;
}
inline void raid_success_info::set_allocated_block(::client::raid_success_ic* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// -------------------------------------------------------------------

// raid_failure_info

// optional bool hero_dead = 1;
inline bool raid_failure_info::has_hero_dead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_failure_info::set_has_hero_dead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_failure_info::clear_has_hero_dead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_failure_info::clear_hero_dead() {
  hero_dead_ = false;
  clear_has_hero_dead();
}
inline bool raid_failure_info::hero_dead() const {
  return hero_dead_;
}
inline void raid_failure_info::set_hero_dead(bool value) {
  set_has_hero_dead();
  hero_dead_ = value;
}

// optional uint32 role_dead = 2;
inline bool raid_failure_info::has_role_dead() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void raid_failure_info::set_has_role_dead() {
  _has_bits_[0] |= 0x00000002u;
}
inline void raid_failure_info::clear_has_role_dead() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void raid_failure_info::clear_role_dead() {
  role_dead_ = 0u;
  clear_has_role_dead();
}
inline ::google::protobuf::uint32 raid_failure_info::role_dead() const {
  return role_dead_;
}
inline void raid_failure_info::set_role_dead(::google::protobuf::uint32 value) {
  set_has_role_dead();
  role_dead_ = value;
}

// optional uint32 timeout = 3;
inline bool raid_failure_info::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void raid_failure_info::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void raid_failure_info::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void raid_failure_info::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 raid_failure_info::timeout() const {
  return timeout_;
}
inline void raid_failure_info::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional uint32 dead_count = 4;
inline bool raid_failure_info::has_dead_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void raid_failure_info::set_has_dead_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void raid_failure_info::clear_has_dead_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void raid_failure_info::clear_dead_count() {
  dead_count_ = 0u;
  clear_has_dead_count();
}
inline ::google::protobuf::uint32 raid_failure_info::dead_count() const {
  return dead_count_;
}
inline void raid_failure_info::set_dead_count(::google::protobuf::uint32 value) {
  set_has_dead_count();
  dead_count_ = value;
}

// optional uint32 vip_dead = 5;
inline bool raid_failure_info::has_vip_dead() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void raid_failure_info::set_has_vip_dead() {
  _has_bits_[0] |= 0x00000010u;
}
inline void raid_failure_info::clear_has_vip_dead() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void raid_failure_info::clear_vip_dead() {
  vip_dead_ = 0u;
  clear_has_vip_dead();
}
inline ::google::protobuf::uint32 raid_failure_info::vip_dead() const {
  return vip_dead_;
}
inline void raid_failure_info::set_vip_dead(::google::protobuf::uint32 value) {
  set_has_vip_dead();
  vip_dead_ = value;
}

// optional uint32 monster = 6;
inline bool raid_failure_info::has_monster() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void raid_failure_info::set_has_monster() {
  _has_bits_[0] |= 0x00000020u;
}
inline void raid_failure_info::clear_has_monster() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void raid_failure_info::clear_monster() {
  monster_ = 0u;
  clear_has_monster();
}
inline ::google::protobuf::uint32 raid_failure_info::monster() const {
  return monster_;
}
inline void raid_failure_info::set_monster(::google::protobuf::uint32 value) {
  set_has_monster();
  monster_ = value;
}

// -------------------------------------------------------------------

// raid_result_msg

// required uint32 raid_id = 1;
inline bool raid_result_msg::has_raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_result_msg::set_has_raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_result_msg::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_result_msg::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 raid_result_msg::raid_id() const {
  return raid_id_;
}
inline void raid_result_msg::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// required uint32 star = 2;
inline bool raid_result_msg::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void raid_result_msg::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void raid_result_msg::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void raid_result_msg::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 raid_result_msg::star() const {
  return star_;
}
inline void raid_result_msg::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// required uint32 tick = 3;
inline bool raid_result_msg::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void raid_result_msg::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void raid_result_msg::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void raid_result_msg::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 raid_result_msg::tick() const {
  return tick_;
}
inline void raid_result_msg::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// repeated .client.raid_result_info info = 4;
inline int raid_result_msg::info_size() const {
  return info_.size();
}
inline void raid_result_msg::clear_info() {
  info_.Clear();
}
inline const ::client::raid_result_info& raid_result_msg::info(int index) const {
  return info_.Get(index);
}
inline ::client::raid_result_info* raid_result_msg::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::client::raid_result_info* raid_result_msg::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >&
raid_result_msg::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >*
raid_result_msg::mutable_info() {
  return &info_;
}

// optional .client.raid_success_info success = 5;
inline bool raid_result_msg::has_success() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void raid_result_msg::set_has_success() {
  _has_bits_[0] |= 0x00000010u;
}
inline void raid_result_msg::clear_has_success() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void raid_result_msg::clear_success() {
  if (success_ != NULL) success_->::client::raid_success_info::Clear();
  clear_has_success();
}
inline const ::client::raid_success_info& raid_result_msg::success() const {
  return success_ != NULL ? *success_ : *default_instance_->success_;
}
inline ::client::raid_success_info* raid_result_msg::mutable_success() {
  set_has_success();
  if (success_ == NULL) success_ = new ::client::raid_success_info;
  return success_;
}
inline ::client::raid_success_info* raid_result_msg::release_success() {
  clear_has_success();
  ::client::raid_success_info* temp = success_;
  success_ = NULL;
  return temp;
}
inline void raid_result_msg::set_allocated_success(::client::raid_success_info* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
}

// optional .client.raid_failure_info failure = 6;
inline bool raid_result_msg::has_failure() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void raid_result_msg::set_has_failure() {
  _has_bits_[0] |= 0x00000020u;
}
inline void raid_result_msg::clear_has_failure() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void raid_result_msg::clear_failure() {
  if (failure_ != NULL) failure_->::client::raid_failure_info::Clear();
  clear_has_failure();
}
inline const ::client::raid_failure_info& raid_result_msg::failure() const {
  return failure_ != NULL ? *failure_ : *default_instance_->failure_;
}
inline ::client::raid_failure_info* raid_result_msg::mutable_failure() {
  set_has_failure();
  if (failure_ == NULL) failure_ = new ::client::raid_failure_info;
  return failure_;
}
inline ::client::raid_failure_info* raid_result_msg::release_failure() {
  clear_has_failure();
  ::client::raid_failure_info* temp = failure_;
  failure_ = NULL;
  return temp;
}
inline void raid_result_msg::set_allocated_failure(::client::raid_failure_info* failure) {
  delete failure_;
  failure_ = failure;
  if (failure) {
    set_has_failure();
  } else {
    clear_has_failure();
  }
}

// optional uint32 rep = 7;
inline bool raid_result_msg::has_rep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void raid_result_msg::set_has_rep() {
  _has_bits_[0] |= 0x00000040u;
}
inline void raid_result_msg::clear_has_rep() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void raid_result_msg::clear_rep() {
  rep_ = 0u;
  clear_has_rep();
}
inline ::google::protobuf::uint32 raid_result_msg::rep() const {
  return rep_;
}
inline void raid_result_msg::set_rep(::google::protobuf::uint32 value) {
  set_has_rep();
  rep_ = value;
}

// optional .client.raid_verify verify = 8;
inline bool raid_result_msg::has_verify() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void raid_result_msg::set_has_verify() {
  _has_bits_[0] |= 0x00000080u;
}
inline void raid_result_msg::clear_has_verify() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void raid_result_msg::clear_verify() {
  if (verify_ != NULL) verify_->::client::raid_verify::Clear();
  clear_has_verify();
}
inline const ::client::raid_verify& raid_result_msg::verify() const {
  return verify_ != NULL ? *verify_ : *default_instance_->verify_;
}
inline ::client::raid_verify* raid_result_msg::mutable_verify() {
  set_has_verify();
  if (verify_ == NULL) verify_ = new ::client::raid_verify;
  return verify_;
}
inline ::client::raid_verify* raid_result_msg::release_verify() {
  clear_has_verify();
  ::client::raid_verify* temp = verify_;
  verify_ = NULL;
  return temp;
}
inline void raid_result_msg::set_allocated_verify(::client::raid_verify* verify) {
  delete verify_;
  verify_ = verify;
  if (verify) {
    set_has_verify();
  } else {
    clear_has_verify();
  }
}

// optional string value1 = 9;
inline bool raid_result_msg::has_value1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void raid_result_msg::set_has_value1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void raid_result_msg::clear_has_value1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void raid_result_msg::clear_value1() {
  if (value1_ != &::google::protobuf::internal::kEmptyString) {
    value1_->clear();
  }
  clear_has_value1();
}
inline const ::std::string& raid_result_msg::value1() const {
  return *value1_;
}
inline void raid_result_msg::set_value1(const ::std::string& value) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(value);
}
inline void raid_result_msg::set_value1(const char* value) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(value);
}
inline void raid_result_msg::set_value1(const char* value, size_t size) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* raid_result_msg::mutable_value1() {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  return value1_;
}
inline ::std::string* raid_result_msg::release_value1() {
  clear_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value1_;
    value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void raid_result_msg::set_allocated_value1(::std::string* value1) {
  if (value1_ != &::google::protobuf::internal::kEmptyString) {
    delete value1_;
  }
  if (value1) {
    set_has_value1();
    value1_ = value1;
  } else {
    clear_has_value1();
    value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 value2 = 10;
inline bool raid_result_msg::has_value2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void raid_result_msg::set_has_value2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void raid_result_msg::clear_has_value2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void raid_result_msg::clear_value2() {
  value2_ = 0u;
  clear_has_value2();
}
inline ::google::protobuf::uint32 raid_result_msg::value2() const {
  return value2_;
}
inline void raid_result_msg::set_value2(::google::protobuf::uint32 value) {
  set_has_value2();
  value2_ = value;
}

// repeated .client.raid_result_info reward1 = 11;
inline int raid_result_msg::reward1_size() const {
  return reward1_.size();
}
inline void raid_result_msg::clear_reward1() {
  reward1_.Clear();
}
inline const ::client::raid_result_info& raid_result_msg::reward1(int index) const {
  return reward1_.Get(index);
}
inline ::client::raid_result_info* raid_result_msg::mutable_reward1(int index) {
  return reward1_.Mutable(index);
}
inline ::client::raid_result_info* raid_result_msg::add_reward1() {
  return reward1_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >&
raid_result_msg::reward1() const {
  return reward1_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >*
raid_result_msg::mutable_reward1() {
  return &reward1_;
}

// repeated .client.raid_result_info reward2 = 12;
inline int raid_result_msg::reward2_size() const {
  return reward2_.size();
}
inline void raid_result_msg::clear_reward2() {
  reward2_.Clear();
}
inline const ::client::raid_result_info& raid_result_msg::reward2(int index) const {
  return reward2_.Get(index);
}
inline ::client::raid_result_info* raid_result_msg::mutable_reward2(int index) {
  return reward2_.Mutable(index);
}
inline ::client::raid_result_info* raid_result_msg::add_reward2() {
  return reward2_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >&
raid_result_msg::reward2() const {
  return reward2_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::raid_result_info >*
raid_result_msg::mutable_reward2() {
  return &reward2_;
}

// -------------------------------------------------------------------

// raid_npc_creazed

// required uint32 raid_id = 1;
inline bool raid_npc_creazed::has_raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_npc_creazed::set_has_raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_npc_creazed::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_npc_creazed::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 raid_npc_creazed::raid_id() const {
  return raid_id_;
}
inline void raid_npc_creazed::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// -------------------------------------------------------------------

// auto_raid_req

// required uint32 id = 1;
inline bool auto_raid_req::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auto_raid_req::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auto_raid_req::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auto_raid_req::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 auto_raid_req::id() const {
  return id_;
}
inline void auto_raid_req::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 num = 2;
inline bool auto_raid_req::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auto_raid_req::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auto_raid_req::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auto_raid_req::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 auto_raid_req::num() const {
  return num_;
}
inline void auto_raid_req::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 t = 3;
inline bool auto_raid_req::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auto_raid_req::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auto_raid_req::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auto_raid_req::clear_t() {
  t_ = 0u;
  clear_has_t();
}
inline ::google::protobuf::uint32 auto_raid_req::t() const {
  return t_;
}
inline void auto_raid_req::set_t(::google::protobuf::uint32 value) {
  set_has_t();
  t_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool auto_raid_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void auto_raid_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void auto_raid_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void auto_raid_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& auto_raid_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* auto_raid_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* auto_raid_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void auto_raid_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// auto_raid_rsp

// required uint32 id = 1;
inline bool auto_raid_rsp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auto_raid_rsp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auto_raid_rsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auto_raid_rsp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 auto_raid_rsp::id() const {
  return id_;
}
inline void auto_raid_rsp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// auto_raid_info

// required uint32 id = 1;
inline bool auto_raid_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auto_raid_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auto_raid_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auto_raid_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 auto_raid_info::id() const {
  return id_;
}
inline void auto_raid_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 type = 2;
inline bool auto_raid_info::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auto_raid_info::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auto_raid_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auto_raid_info::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 auto_raid_info::type() const {
  return type_;
}
inline void auto_raid_info::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 start_time = 3;
inline bool auto_raid_info::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auto_raid_info::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auto_raid_info::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auto_raid_info::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 auto_raid_info::start_time() const {
  return start_time_;
}
inline void auto_raid_info::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// required uint32 need_time = 4;
inline bool auto_raid_info::has_need_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void auto_raid_info::set_has_need_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void auto_raid_info::clear_has_need_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void auto_raid_info::clear_need_time() {
  need_time_ = 0u;
  clear_has_need_time();
}
inline ::google::protobuf::uint32 auto_raid_info::need_time() const {
  return need_time_;
}
inline void auto_raid_info::set_need_time(::google::protobuf::uint32 value) {
  set_has_need_time();
  need_time_ = value;
}

// required uint32 frozen_silver = 5;
inline bool auto_raid_info::has_frozen_silver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void auto_raid_info::set_has_frozen_silver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void auto_raid_info::clear_has_frozen_silver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void auto_raid_info::clear_frozen_silver() {
  frozen_silver_ = 0u;
  clear_has_frozen_silver();
}
inline ::google::protobuf::uint32 auto_raid_info::frozen_silver() const {
  return frozen_silver_;
}
inline void auto_raid_info::set_frozen_silver(::google::protobuf::uint32 value) {
  set_has_frozen_silver();
  frozen_silver_ = value;
}

// required uint32 frozen_physical_power = 6;
inline bool auto_raid_info::has_frozen_physical_power() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void auto_raid_info::set_has_frozen_physical_power() {
  _has_bits_[0] |= 0x00000020u;
}
inline void auto_raid_info::clear_has_frozen_physical_power() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void auto_raid_info::clear_frozen_physical_power() {
  frozen_physical_power_ = 0u;
  clear_has_frozen_physical_power();
}
inline ::google::protobuf::uint32 auto_raid_info::frozen_physical_power() const {
  return frozen_physical_power_;
}
inline void auto_raid_info::set_frozen_physical_power(::google::protobuf::uint32 value) {
  set_has_frozen_physical_power();
  frozen_physical_power_ = value;
}

// required uint32 count = 7;
inline bool auto_raid_info::has_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void auto_raid_info::set_has_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void auto_raid_info::clear_has_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void auto_raid_info::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 auto_raid_info::count() const {
  return count_;
}
inline void auto_raid_info::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 monster = 8;
inline bool auto_raid_info::has_monster() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void auto_raid_info::set_has_monster() {
  _has_bits_[0] |= 0x00000080u;
}
inline void auto_raid_info::clear_has_monster() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void auto_raid_info::clear_monster() {
  monster_ = 0u;
  clear_has_monster();
}
inline ::google::protobuf::uint32 auto_raid_info::monster() const {
  return monster_;
}
inline void auto_raid_info::set_monster(::google::protobuf::uint32 value) {
  set_has_monster();
  monster_ = value;
}

// required uint32 exp = 9;
inline bool auto_raid_info::has_exp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void auto_raid_info::set_has_exp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void auto_raid_info::clear_has_exp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void auto_raid_info::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 auto_raid_info::exp() const {
  return exp_;
}
inline void auto_raid_info::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 coin = 10;
inline bool auto_raid_info::has_coin() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void auto_raid_info::set_has_coin() {
  _has_bits_[0] |= 0x00000200u;
}
inline void auto_raid_info::clear_has_coin() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void auto_raid_info::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 auto_raid_info::coin() const {
  return coin_;
}
inline void auto_raid_info::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// required uint32 military_strategy = 11;
inline bool auto_raid_info::has_military_strategy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void auto_raid_info::set_has_military_strategy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void auto_raid_info::clear_has_military_strategy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void auto_raid_info::clear_military_strategy() {
  military_strategy_ = 0u;
  clear_has_military_strategy();
}
inline ::google::protobuf::uint32 auto_raid_info::military_strategy() const {
  return military_strategy_;
}
inline void auto_raid_info::set_military_strategy(::google::protobuf::uint32 value) {
  set_has_military_strategy();
  military_strategy_ = value;
}

// repeated .client.props_info props = 12;
inline int auto_raid_info::props_size() const {
  return props_.size();
}
inline void auto_raid_info::clear_props() {
  props_.Clear();
}
inline const ::client::props_info& auto_raid_info::props(int index) const {
  return props_.Get(index);
}
inline ::client::props_info* auto_raid_info::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::client::props_info* auto_raid_info::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::props_info >&
auto_raid_info::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::props_info >*
auto_raid_info::mutable_props() {
  return &props_;
}

// -------------------------------------------------------------------

// auto_raid_msg

// required .client.auto_raid_info info = 1;
inline bool auto_raid_msg::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auto_raid_msg::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auto_raid_msg::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auto_raid_msg::clear_info() {
  if (info_ != NULL) info_->::client::auto_raid_info::Clear();
  clear_has_info();
}
inline const ::client::auto_raid_info& auto_raid_msg::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::client::auto_raid_info* auto_raid_msg::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::client::auto_raid_info;
  return info_;
}
inline ::client::auto_raid_info* auto_raid_msg::release_info() {
  clear_has_info();
  ::client::auto_raid_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void auto_raid_msg::set_allocated_info(::client::auto_raid_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// mini_server_req

// required uint32 op = 1;
inline bool mini_server_req::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mini_server_req::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mini_server_req::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mini_server_req::clear_op() {
  op_ = 0u;
  clear_has_op();
}
inline ::google::protobuf::uint32 mini_server_req::op() const {
  return op_;
}
inline void mini_server_req::set_op(::google::protobuf::uint32 value) {
  set_has_op();
  op_ = value;
}

// required uint32 raid_id = 2;
inline bool mini_server_req::has_raid_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mini_server_req::set_has_raid_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mini_server_req::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mini_server_req::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 mini_server_req::raid_id() const {
  return raid_id_;
}
inline void mini_server_req::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// optional uint32 raid_type = 3;
inline bool mini_server_req::has_raid_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mini_server_req::set_has_raid_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mini_server_req::clear_has_raid_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mini_server_req::clear_raid_type() {
  raid_type_ = 0u;
  clear_has_raid_type();
}
inline ::google::protobuf::uint32 mini_server_req::raid_type() const {
  return raid_type_;
}
inline void mini_server_req::set_raid_type(::google::protobuf::uint32 value) {
  set_has_raid_type();
  raid_type_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool mini_server_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mini_server_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mini_server_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mini_server_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& mini_server_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* mini_server_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* mini_server_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void mini_server_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// mini_server_rsp

// required uint32 op = 1;
inline bool mini_server_rsp::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mini_server_rsp::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mini_server_rsp::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mini_server_rsp::clear_op() {
  op_ = 0u;
  clear_has_op();
}
inline ::google::protobuf::uint32 mini_server_rsp::op() const {
  return op_;
}
inline void mini_server_rsp::set_op(::google::protobuf::uint32 value) {
  set_has_op();
  op_ = value;
}

// required uint32 raid_id = 2;
inline bool mini_server_rsp::has_raid_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mini_server_rsp::set_has_raid_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mini_server_rsp::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mini_server_rsp::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 mini_server_rsp::raid_id() const {
  return raid_id_;
}
inline void mini_server_rsp::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// optional uint32 raid_type = 3;
inline bool mini_server_rsp::has_raid_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mini_server_rsp::set_has_raid_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mini_server_rsp::clear_has_raid_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mini_server_rsp::clear_raid_type() {
  raid_type_ = 0u;
  clear_has_raid_type();
}
inline ::google::protobuf::uint32 mini_server_rsp::raid_type() const {
  return raid_type_;
}
inline void mini_server_rsp::set_raid_type(::google::protobuf::uint32 value) {
  set_has_raid_type();
  raid_type_ = value;
}

// required uint32 time = 4;
inline bool mini_server_rsp::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mini_server_rsp::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mini_server_rsp::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mini_server_rsp::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 mini_server_rsp::time() const {
  return time_;
}
inline void mini_server_rsp::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 ret = 5;
inline bool mini_server_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mini_server_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mini_server_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mini_server_rsp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 mini_server_rsp::ret() const {
  return ret_;
}
inline void mini_server_rsp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// mini_server_end_msg

// required .client.raid_result_msg msg = 1;
inline bool mini_server_end_msg::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mini_server_end_msg::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mini_server_end_msg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mini_server_end_msg::clear_msg() {
  if (msg_ != NULL) msg_->::client::raid_result_msg::Clear();
  clear_has_msg();
}
inline const ::client::raid_result_msg& mini_server_end_msg::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::client::raid_result_msg* mini_server_end_msg::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::client::raid_result_msg;
  return msg_;
}
inline ::client::raid_result_msg* mini_server_end_msg::release_msg() {
  clear_has_msg();
  ::client::raid_result_msg* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void mini_server_end_msg::set_allocated_msg(::client::raid_result_msg* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// optional uint32 rep = 2;
inline bool mini_server_end_msg::has_rep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mini_server_end_msg::set_has_rep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mini_server_end_msg::clear_has_rep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mini_server_end_msg::clear_rep() {
  rep_ = 0u;
  clear_has_rep();
}
inline ::google::protobuf::uint32 mini_server_end_msg::rep() const {
  return rep_;
}
inline void mini_server_end_msg::set_rep(::google::protobuf::uint32 value) {
  set_has_rep();
  rep_ = value;
}

// -------------------------------------------------------------------

// raid_verify

// required uint32 max_hp = 1;
inline bool raid_verify::has_max_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void raid_verify::set_has_max_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void raid_verify::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void raid_verify::clear_max_hp() {
  max_hp_ = 0u;
  clear_has_max_hp();
}
inline ::google::protobuf::uint32 raid_verify::max_hp() const {
  return max_hp_;
}
inline void raid_verify::set_max_hp(::google::protobuf::uint32 value) {
  set_has_max_hp();
  max_hp_ = value;
}

// required uint32 max_atk = 2;
inline bool raid_verify::has_max_atk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void raid_verify::set_has_max_atk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void raid_verify::clear_has_max_atk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void raid_verify::clear_max_atk() {
  max_atk_ = 0u;
  clear_has_max_atk();
}
inline ::google::protobuf::uint32 raid_verify::max_atk() const {
  return max_atk_;
}
inline void raid_verify::set_max_atk(::google::protobuf::uint32 value) {
  set_has_max_atk();
  max_atk_ = value;
}

// required uint32 max_def = 3;
inline bool raid_verify::has_max_def() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void raid_verify::set_has_max_def() {
  _has_bits_[0] |= 0x00000004u;
}
inline void raid_verify::clear_has_max_def() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void raid_verify::clear_max_def() {
  max_def_ = 0u;
  clear_has_max_def();
}
inline ::google::protobuf::uint32 raid_verify::max_def() const {
  return max_def_;
}
inline void raid_verify::set_max_def(::google::protobuf::uint32 value) {
  set_has_max_def();
  max_def_ = value;
}

// required uint32 bow_index = 4;
inline bool raid_verify::has_bow_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void raid_verify::set_has_bow_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void raid_verify::clear_has_bow_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void raid_verify::clear_bow_index() {
  bow_index_ = 0u;
  clear_has_bow_index();
}
inline ::google::protobuf::uint32 raid_verify::bow_index() const {
  return bow_index_;
}
inline void raid_verify::set_bow_index(::google::protobuf::uint32 value) {
  set_has_bow_index();
  bow_index_ = value;
}

// -------------------------------------------------------------------

// reported_raid_info

// required uint32 id = 1;
inline bool reported_raid_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reported_raid_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reported_raid_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reported_raid_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 reported_raid_info::id() const {
  return id_;
}
inline void reported_raid_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 star = 2;
inline bool reported_raid_info::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reported_raid_info::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reported_raid_info::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reported_raid_info::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 reported_raid_info::star() const {
  return star_;
}
inline void reported_raid_info::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// required uint32 used_tick = 3;
inline bool reported_raid_info::has_used_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void reported_raid_info::set_has_used_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void reported_raid_info::clear_has_used_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void reported_raid_info::clear_used_tick() {
  used_tick_ = 0u;
  clear_has_used_tick();
}
inline ::google::protobuf::uint32 reported_raid_info::used_tick() const {
  return used_tick_;
}
inline void reported_raid_info::set_used_tick(::google::protobuf::uint32 value) {
  set_has_used_tick();
  used_tick_ = value;
}

// required uint32 complete_time = 4;
inline bool reported_raid_info::has_complete_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void reported_raid_info::set_has_complete_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void reported_raid_info::clear_has_complete_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void reported_raid_info::clear_complete_time() {
  complete_time_ = 0u;
  clear_has_complete_time();
}
inline ::google::protobuf::uint32 reported_raid_info::complete_time() const {
  return complete_time_;
}
inline void reported_raid_info::set_complete_time(::google::protobuf::uint32 value) {
  set_has_complete_time();
  complete_time_ = value;
}

// required uint32 type = 5;
inline bool reported_raid_info::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void reported_raid_info::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void reported_raid_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void reported_raid_info::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 reported_raid_info::type() const {
  return type_;
}
inline void reported_raid_info::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 time = 6;
inline bool reported_raid_info::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void reported_raid_info::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void reported_raid_info::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void reported_raid_info::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 reported_raid_info::time() const {
  return time_;
}
inline void reported_raid_info::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required string key = 7;
inline bool reported_raid_info::has_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void reported_raid_info::set_has_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void reported_raid_info::clear_has_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void reported_raid_info::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& reported_raid_info::key() const {
  return *key_;
}
inline void reported_raid_info::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void reported_raid_info::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void reported_raid_info::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* reported_raid_info::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* reported_raid_info::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void reported_raid_info::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .client.raid_success_info success = 8;
inline bool reported_raid_info::has_success() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void reported_raid_info::set_has_success() {
  _has_bits_[0] |= 0x00000080u;
}
inline void reported_raid_info::clear_has_success() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void reported_raid_info::clear_success() {
  if (success_ != NULL) success_->::client::raid_success_info::Clear();
  clear_has_success();
}
inline const ::client::raid_success_info& reported_raid_info::success() const {
  return success_ != NULL ? *success_ : *default_instance_->success_;
}
inline ::client::raid_success_info* reported_raid_info::mutable_success() {
  set_has_success();
  if (success_ == NULL) success_ = new ::client::raid_success_info;
  return success_;
}
inline ::client::raid_success_info* reported_raid_info::release_success() {
  clear_has_success();
  ::client::raid_success_info* temp = success_;
  success_ = NULL;
  return temp;
}
inline void reported_raid_info::set_allocated_success(::client::raid_success_info* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
}

// optional .client.raid_failure_info failure = 9;
inline bool reported_raid_info::has_failure() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void reported_raid_info::set_has_failure() {
  _has_bits_[0] |= 0x00000100u;
}
inline void reported_raid_info::clear_has_failure() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void reported_raid_info::clear_failure() {
  if (failure_ != NULL) failure_->::client::raid_failure_info::Clear();
  clear_has_failure();
}
inline const ::client::raid_failure_info& reported_raid_info::failure() const {
  return failure_ != NULL ? *failure_ : *default_instance_->failure_;
}
inline ::client::raid_failure_info* reported_raid_info::mutable_failure() {
  set_has_failure();
  if (failure_ == NULL) failure_ = new ::client::raid_failure_info;
  return failure_;
}
inline ::client::raid_failure_info* reported_raid_info::release_failure() {
  clear_has_failure();
  ::client::raid_failure_info* temp = failure_;
  failure_ = NULL;
  return temp;
}
inline void reported_raid_info::set_allocated_failure(::client::raid_failure_info* failure) {
  delete failure_;
  failure_ = failure;
  if (failure) {
    set_has_failure();
  } else {
    clear_has_failure();
  }
}

// required .client.raid_verify verify = 10;
inline bool reported_raid_info::has_verify() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void reported_raid_info::set_has_verify() {
  _has_bits_[0] |= 0x00000200u;
}
inline void reported_raid_info::clear_has_verify() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void reported_raid_info::clear_verify() {
  if (verify_ != NULL) verify_->::client::raid_verify::Clear();
  clear_has_verify();
}
inline const ::client::raid_verify& reported_raid_info::verify() const {
  return verify_ != NULL ? *verify_ : *default_instance_->verify_;
}
inline ::client::raid_verify* reported_raid_info::mutable_verify() {
  set_has_verify();
  if (verify_ == NULL) verify_ = new ::client::raid_verify;
  return verify_;
}
inline ::client::raid_verify* reported_raid_info::release_verify() {
  clear_has_verify();
  ::client::raid_verify* temp = verify_;
  verify_ = NULL;
  return temp;
}
inline void reported_raid_info::set_allocated_verify(::client::raid_verify* verify) {
  delete verify_;
  verify_ = verify;
  if (verify) {
    set_has_verify();
  } else {
    clear_has_verify();
  }
}

// -------------------------------------------------------------------

// reported_raid_req

// repeated .client.reported_raid_info rri = 1;
inline int reported_raid_req::rri_size() const {
  return rri_.size();
}
inline void reported_raid_req::clear_rri() {
  rri_.Clear();
}
inline const ::client::reported_raid_info& reported_raid_req::rri(int index) const {
  return rri_.Get(index);
}
inline ::client::reported_raid_info* reported_raid_req::mutable_rri(int index) {
  return rri_.Mutable(index);
}
inline ::client::reported_raid_info* reported_raid_req::add_rri() {
  return rri_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::reported_raid_info >&
reported_raid_req::rri() const {
  return rri_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::reported_raid_info >*
reported_raid_req::mutable_rri() {
  return &rri_;
}

// optional .client.server_head svr_head = 1000;
inline bool reported_raid_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reported_raid_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reported_raid_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reported_raid_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& reported_raid_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* reported_raid_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* reported_raid_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void reported_raid_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// create_npc_msg

// required string content = 1;
inline bool create_npc_msg::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void create_npc_msg::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void create_npc_msg::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void create_npc_msg::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& create_npc_msg::content() const {
  return *content_;
}
inline void create_npc_msg::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void create_npc_msg::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void create_npc_msg::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* create_npc_msg::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* create_npc_msg::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void create_npc_msg::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 delay = 2;
inline bool create_npc_msg::has_delay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void create_npc_msg::set_has_delay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void create_npc_msg::clear_has_delay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void create_npc_msg::clear_delay() {
  delay_ = 0u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 create_npc_msg::delay() const {
  return delay_;
}
inline void create_npc_msg::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
}

// required uint32 show = 3;
inline bool create_npc_msg::has_show() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void create_npc_msg::set_has_show() {
  _has_bits_[0] |= 0x00000004u;
}
inline void create_npc_msg::clear_has_show() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void create_npc_msg::clear_show() {
  show_ = 0u;
  clear_has_show();
}
inline ::google::protobuf::uint32 create_npc_msg::show() const {
  return show_;
}
inline void create_npc_msg::set_show(::google::protobuf::uint32 value) {
  set_has_show();
  show_ = value;
}

// -------------------------------------------------------------------

// dead_in_raid

// required uint32 time = 1;
inline bool dead_in_raid::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dead_in_raid::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dead_in_raid::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dead_in_raid::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 dead_in_raid::time() const {
  return time_;
}
inline void dead_in_raid::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::enter_raid_req_type>() {
  return ::client::enter_raid_req_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::raid_check_result_e>() {
  return ::client::raid_check_result_e_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eraid_5foperate_2eproto__INCLUDED
