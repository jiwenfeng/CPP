// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.vip.proto

#ifndef PROTOBUF_client_2evip_2eproto__INCLUDED
#define PROTOBUF_client_2evip_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2evip_2eproto();
void protobuf_AssignDesc_client_2evip_2eproto();
void protobuf_ShutdownFile_client_2evip_2eproto();

class recharge_info;
class vip_buy_info_req;
class vip_buy_info_rsp;
class vip_exp_req;
class vip_exp_rsp;
class vip_op_times_req;
class vip_op_times_rsp;
class vip_op_req;
class vip_op_rsp;
class vip_op_info;
class vip_op;

enum vip_op_rsp_op_e {
  vip_op_rsp_op_e_SUCCESS = 0,
  vip_op_rsp_op_e_VIP_LIMIT = 1,
  vip_op_rsp_op_e_TIMES_LIMIT = 2,
  vip_op_rsp_op_e_INGOT_LIMIT = 3,
  vip_op_rsp_op_e_FAILED = 4
};
bool vip_op_rsp_op_e_IsValid(int value);
const vip_op_rsp_op_e vip_op_rsp_op_e_op_e_MIN = vip_op_rsp_op_e_SUCCESS;
const vip_op_rsp_op_e vip_op_rsp_op_e_op_e_MAX = vip_op_rsp_op_e_FAILED;
const int vip_op_rsp_op_e_op_e_ARRAYSIZE = vip_op_rsp_op_e_op_e_MAX + 1;

const ::google::protobuf::EnumDescriptor* vip_op_rsp_op_e_descriptor();
inline const ::std::string& vip_op_rsp_op_e_Name(vip_op_rsp_op_e value) {
  return ::google::protobuf::internal::NameOfEnum(
    vip_op_rsp_op_e_descriptor(), value);
}
inline bool vip_op_rsp_op_e_Parse(
    const ::std::string& name, vip_op_rsp_op_e* value) {
  return ::google::protobuf::internal::ParseNamedEnum<vip_op_rsp_op_e>(
    vip_op_rsp_op_e_descriptor(), name, value);
}
enum OP_CODE {
  OP_BUY_PHYSICAL = 1,
  OP_BUY_COPPER = 2,
  OP_BUY_CARBON2_TIMES = 3,
  OP_BUY_CHALLANGE_TIMES = 4,
  OP_BUY_SKILL_POINT = 5,
  OP_RESET_MOUNT_TIMES = 6,
  OP_RESET_CYCLE_LEVEL = 7,
  OP_RESET_DEVIL_LEVEL = 8,
  OP_END = 9
};
bool OP_CODE_IsValid(int value);
const OP_CODE OP_CODE_MIN = OP_BUY_PHYSICAL;
const OP_CODE OP_CODE_MAX = OP_END;
const int OP_CODE_ARRAYSIZE = OP_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* OP_CODE_descriptor();
inline const ::std::string& OP_CODE_Name(OP_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    OP_CODE_descriptor(), value);
}
inline bool OP_CODE_Parse(
    const ::std::string& name, OP_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OP_CODE>(
    OP_CODE_descriptor(), name, value);
}
// ===================================================================

class recharge_info : public ::google::protobuf::Message {
 public:
  recharge_info();
  virtual ~recharge_info();

  recharge_info(const recharge_info& from);

  inline recharge_info& operator=(const recharge_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recharge_info& default_instance();

  void Swap(recharge_info* other);

  // implements Message ----------------------------------------------

  recharge_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const recharge_info& from);
  void MergeFrom(const recharge_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.recharge_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static recharge_info* default_instance_;
};
// -------------------------------------------------------------------

class vip_buy_info_req : public ::google::protobuf::Message {
 public:
  vip_buy_info_req();
  virtual ~vip_buy_info_req();

  vip_buy_info_req(const vip_buy_info_req& from);

  inline vip_buy_info_req& operator=(const vip_buy_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_buy_info_req& default_instance();

  void Swap(vip_buy_info_req* other);

  // implements Message ----------------------------------------------

  vip_buy_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_buy_info_req& from);
  void MergeFrom(const vip_buy_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.vip_buy_info_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_buy_info_req* default_instance_;
};
// -------------------------------------------------------------------

class vip_buy_info_rsp : public ::google::protobuf::Message {
 public:
  vip_buy_info_rsp();
  virtual ~vip_buy_info_rsp();

  vip_buy_info_rsp(const vip_buy_info_rsp& from);

  inline vip_buy_info_rsp& operator=(const vip_buy_info_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_buy_info_rsp& default_instance();

  void Swap(vip_buy_info_rsp* other);

  // implements Message ----------------------------------------------

  vip_buy_info_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_buy_info_rsp& from);
  void MergeFrom(const vip_buy_info_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.recharge_info ri = 1;
  inline int ri_size() const;
  inline void clear_ri();
  static const int kRiFieldNumber = 1;
  inline const ::client::recharge_info& ri(int index) const;
  inline ::client::recharge_info* mutable_ri(int index);
  inline ::client::recharge_info* add_ri();
  inline const ::google::protobuf::RepeatedPtrField< ::client::recharge_info >&
      ri() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::recharge_info >*
      mutable_ri();

  // required uint32 tick = 2;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 2;
  inline ::google::protobuf::uint32 tick() const;
  inline void set_tick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.vip_buy_info_rsp)
 private:
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::recharge_info > ri_;
  ::google::protobuf::uint32 tick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_buy_info_rsp* default_instance_;
};
// -------------------------------------------------------------------

class vip_exp_req : public ::google::protobuf::Message {
 public:
  vip_exp_req();
  virtual ~vip_exp_req();

  vip_exp_req(const vip_exp_req& from);

  inline vip_exp_req& operator=(const vip_exp_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_exp_req& default_instance();

  void Swap(vip_exp_req* other);

  // implements Message ----------------------------------------------

  vip_exp_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_exp_req& from);
  void MergeFrom(const vip_exp_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.vip_exp_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_exp_req* default_instance_;
};
// -------------------------------------------------------------------

class vip_exp_rsp : public ::google::protobuf::Message {
 public:
  vip_exp_rsp();
  virtual ~vip_exp_rsp();

  vip_exp_rsp(const vip_exp_rsp& from);

  inline vip_exp_rsp& operator=(const vip_exp_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_exp_rsp& default_instance();

  void Swap(vip_exp_rsp* other);

  // implements Message ----------------------------------------------

  vip_exp_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_exp_rsp& from);
  void MergeFrom(const vip_exp_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 exp = 1;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 1;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.vip_exp_rsp)
 private:
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_exp_rsp* default_instance_;
};
// -------------------------------------------------------------------

class vip_op_times_req : public ::google::protobuf::Message {
 public:
  vip_op_times_req();
  virtual ~vip_op_times_req();

  vip_op_times_req(const vip_op_times_req& from);

  inline vip_op_times_req& operator=(const vip_op_times_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_op_times_req& default_instance();

  void Swap(vip_op_times_req* other);

  // implements Message ----------------------------------------------

  vip_op_times_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_op_times_req& from);
  void MergeFrom(const vip_op_times_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.OP_CODE op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::client::OP_CODE op() const;
  inline void set_op(::client::OP_CODE value);

  // required uint32 raid_id = 2;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 2;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.vip_op_times_req)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int op_;
  ::google::protobuf::uint32 raid_id_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_op_times_req* default_instance_;
};
// -------------------------------------------------------------------

class vip_op_times_rsp : public ::google::protobuf::Message {
 public:
  vip_op_times_rsp();
  virtual ~vip_op_times_rsp();

  vip_op_times_rsp(const vip_op_times_rsp& from);

  inline vip_op_times_rsp& operator=(const vip_op_times_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_op_times_rsp& default_instance();

  void Swap(vip_op_times_rsp* other);

  // implements Message ----------------------------------------------

  vip_op_times_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_op_times_rsp& from);
  void MergeFrom(const vip_op_times_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::google::protobuf::uint32 op() const;
  inline void set_op(::google::protobuf::uint32 value);

  // required uint32 times = 2;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::uint32 times() const;
  inline void set_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.vip_op_times_rsp)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 op_;
  ::google::protobuf::uint32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_op_times_rsp* default_instance_;
};
// -------------------------------------------------------------------

class vip_op_req : public ::google::protobuf::Message {
 public:
  vip_op_req();
  virtual ~vip_op_req();

  vip_op_req(const vip_op_req& from);

  inline vip_op_req& operator=(const vip_op_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_op_req& default_instance();

  void Swap(vip_op_req* other);

  // implements Message ----------------------------------------------

  vip_op_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_op_req& from);
  void MergeFrom(const vip_op_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.OP_CODE op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::client::OP_CODE op() const;
  inline void set_op(::client::OP_CODE value);

  // optional uint32 raid_id = 2;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 2;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.vip_op_req)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int op_;
  ::google::protobuf::uint32 raid_id_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_op_req* default_instance_;
};
// -------------------------------------------------------------------

class vip_op_rsp : public ::google::protobuf::Message {
 public:
  vip_op_rsp();
  virtual ~vip_op_rsp();

  vip_op_rsp(const vip_op_rsp& from);

  inline vip_op_rsp& operator=(const vip_op_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_op_rsp& default_instance();

  void Swap(vip_op_rsp* other);

  // implements Message ----------------------------------------------

  vip_op_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_op_rsp& from);
  void MergeFrom(const vip_op_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef vip_op_rsp_op_e op_e;
  static const op_e SUCCESS = vip_op_rsp_op_e_SUCCESS;
  static const op_e VIP_LIMIT = vip_op_rsp_op_e_VIP_LIMIT;
  static const op_e TIMES_LIMIT = vip_op_rsp_op_e_TIMES_LIMIT;
  static const op_e INGOT_LIMIT = vip_op_rsp_op_e_INGOT_LIMIT;
  static const op_e FAILED = vip_op_rsp_op_e_FAILED;
  static inline bool op_e_IsValid(int value) {
    return vip_op_rsp_op_e_IsValid(value);
  }
  static const op_e op_e_MIN =
    vip_op_rsp_op_e_op_e_MIN;
  static const op_e op_e_MAX =
    vip_op_rsp_op_e_op_e_MAX;
  static const int op_e_ARRAYSIZE =
    vip_op_rsp_op_e_op_e_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  op_e_descriptor() {
    return vip_op_rsp_op_e_descriptor();
  }
  static inline const ::std::string& op_e_Name(op_e value) {
    return vip_op_rsp_op_e_Name(value);
  }
  static inline bool op_e_Parse(const ::std::string& name,
      op_e* value) {
    return vip_op_rsp_op_e_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.vip_op_rsp.op_e ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::vip_op_rsp_op_e ret() const;
  inline void set_ret(::client::vip_op_rsp_op_e value);

  // required .client.OP_CODE op = 2;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 2;
  inline ::client::OP_CODE op() const;
  inline void set_op(::client::OP_CODE value);

  // @@protoc_insertion_point(class_scope:client.vip_op_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_op();
  inline void clear_has_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;
  int op_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_op_rsp* default_instance_;
};
// -------------------------------------------------------------------

class vip_op_info : public ::google::protobuf::Message {
 public:
  vip_op_info();
  virtual ~vip_op_info();

  vip_op_info(const vip_op_info& from);

  inline vip_op_info& operator=(const vip_op_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_op_info& default_instance();

  void Swap(vip_op_info* other);

  // implements Message ----------------------------------------------

  vip_op_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_op_info& from);
  void MergeFrom(const vip_op_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::google::protobuf::uint32 op() const;
  inline void set_op(::google::protobuf::uint32 value);

  // repeated .client.vip_op vo = 2;
  inline int vo_size() const;
  inline void clear_vo();
  static const int kVoFieldNumber = 2;
  inline const ::client::vip_op& vo(int index) const;
  inline ::client::vip_op* mutable_vo(int index);
  inline ::client::vip_op* add_vo();
  inline const ::google::protobuf::RepeatedPtrField< ::client::vip_op >&
      vo() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::vip_op >*
      mutable_vo();

  // @@protoc_insertion_point(class_scope:client.vip_op_info)
 private:
  inline void set_has_op();
  inline void clear_has_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::vip_op > vo_;
  ::google::protobuf::uint32 op_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_op_info* default_instance_;
};
// -------------------------------------------------------------------

class vip_op : public ::google::protobuf::Message {
 public:
  vip_op();
  virtual ~vip_op();

  vip_op(const vip_op& from);

  inline vip_op& operator=(const vip_op& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vip_op& default_instance();

  void Swap(vip_op* other);

  // implements Message ----------------------------------------------

  vip_op* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vip_op& from);
  void MergeFrom(const vip_op& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 id = 2 [default = 1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.vip_op)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2evip_2eproto();
  friend void protobuf_AssignDesc_client_2evip_2eproto();
  friend void protobuf_ShutdownFile_client_2evip_2eproto();

  void InitAsDefaultInstance();
  static vip_op* default_instance_;
};
// ===================================================================


// ===================================================================

// recharge_info

// required uint32 id = 1;
inline bool recharge_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void recharge_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void recharge_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void recharge_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 recharge_info::id() const {
  return id_;
}
inline void recharge_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 num = 2;
inline bool recharge_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void recharge_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void recharge_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void recharge_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 recharge_info::num() const {
  return num_;
}
inline void recharge_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// vip_buy_info_req

// required uint32 role_id = 1;
inline bool vip_buy_info_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_buy_info_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_buy_info_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_buy_info_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 vip_buy_info_req::role_id() const {
  return role_id_;
}
inline void vip_buy_info_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool vip_buy_info_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_buy_info_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_buy_info_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_buy_info_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& vip_buy_info_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* vip_buy_info_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* vip_buy_info_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void vip_buy_info_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// vip_buy_info_rsp

// repeated .client.recharge_info ri = 1;
inline int vip_buy_info_rsp::ri_size() const {
  return ri_.size();
}
inline void vip_buy_info_rsp::clear_ri() {
  ri_.Clear();
}
inline const ::client::recharge_info& vip_buy_info_rsp::ri(int index) const {
  return ri_.Get(index);
}
inline ::client::recharge_info* vip_buy_info_rsp::mutable_ri(int index) {
  return ri_.Mutable(index);
}
inline ::client::recharge_info* vip_buy_info_rsp::add_ri() {
  return ri_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::recharge_info >&
vip_buy_info_rsp::ri() const {
  return ri_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::recharge_info >*
vip_buy_info_rsp::mutable_ri() {
  return &ri_;
}

// required uint32 tick = 2;
inline bool vip_buy_info_rsp::has_tick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_buy_info_rsp::set_has_tick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_buy_info_rsp::clear_has_tick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_buy_info_rsp::clear_tick() {
  tick_ = 0u;
  clear_has_tick();
}
inline ::google::protobuf::uint32 vip_buy_info_rsp::tick() const {
  return tick_;
}
inline void vip_buy_info_rsp::set_tick(::google::protobuf::uint32 value) {
  set_has_tick();
  tick_ = value;
}

// -------------------------------------------------------------------

// vip_exp_req

// required uint32 role_id = 1;
inline bool vip_exp_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_exp_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_exp_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_exp_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 vip_exp_req::role_id() const {
  return role_id_;
}
inline void vip_exp_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool vip_exp_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_exp_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_exp_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_exp_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& vip_exp_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* vip_exp_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* vip_exp_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void vip_exp_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// vip_exp_rsp

// required uint32 exp = 1;
inline bool vip_exp_rsp::has_exp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_exp_rsp::set_has_exp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_exp_rsp::clear_has_exp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_exp_rsp::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 vip_exp_rsp::exp() const {
  return exp_;
}
inline void vip_exp_rsp::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// vip_op_times_req

// required .client.OP_CODE op = 1;
inline bool vip_op_times_req::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_op_times_req::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_op_times_req::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_op_times_req::clear_op() {
  op_ = 1;
  clear_has_op();
}
inline ::client::OP_CODE vip_op_times_req::op() const {
  return static_cast< ::client::OP_CODE >(op_);
}
inline void vip_op_times_req::set_op(::client::OP_CODE value) {
  assert(::client::OP_CODE_IsValid(value));
  set_has_op();
  op_ = value;
}

// required uint32 raid_id = 2;
inline bool vip_op_times_req::has_raid_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_op_times_req::set_has_raid_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_op_times_req::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_op_times_req::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 vip_op_times_req::raid_id() const {
  return raid_id_;
}
inline void vip_op_times_req::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool vip_op_times_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void vip_op_times_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void vip_op_times_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void vip_op_times_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& vip_op_times_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* vip_op_times_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* vip_op_times_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void vip_op_times_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// vip_op_times_rsp

// required uint32 op = 1;
inline bool vip_op_times_rsp::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_op_times_rsp::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_op_times_rsp::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_op_times_rsp::clear_op() {
  op_ = 0u;
  clear_has_op();
}
inline ::google::protobuf::uint32 vip_op_times_rsp::op() const {
  return op_;
}
inline void vip_op_times_rsp::set_op(::google::protobuf::uint32 value) {
  set_has_op();
  op_ = value;
}

// required uint32 times = 2;
inline bool vip_op_times_rsp::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_op_times_rsp::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_op_times_rsp::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_op_times_rsp::clear_times() {
  times_ = 0u;
  clear_has_times();
}
inline ::google::protobuf::uint32 vip_op_times_rsp::times() const {
  return times_;
}
inline void vip_op_times_rsp::set_times(::google::protobuf::uint32 value) {
  set_has_times();
  times_ = value;
}

// -------------------------------------------------------------------

// vip_op_req

// required .client.OP_CODE op = 1;
inline bool vip_op_req::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_op_req::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_op_req::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_op_req::clear_op() {
  op_ = 1;
  clear_has_op();
}
inline ::client::OP_CODE vip_op_req::op() const {
  return static_cast< ::client::OP_CODE >(op_);
}
inline void vip_op_req::set_op(::client::OP_CODE value) {
  assert(::client::OP_CODE_IsValid(value));
  set_has_op();
  op_ = value;
}

// optional uint32 raid_id = 2;
inline bool vip_op_req::has_raid_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_op_req::set_has_raid_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_op_req::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_op_req::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 vip_op_req::raid_id() const {
  return raid_id_;
}
inline void vip_op_req::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool vip_op_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void vip_op_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void vip_op_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void vip_op_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& vip_op_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* vip_op_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* vip_op_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void vip_op_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// vip_op_rsp

// required .client.vip_op_rsp.op_e ret = 1;
inline bool vip_op_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_op_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_op_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_op_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::vip_op_rsp_op_e vip_op_rsp::ret() const {
  return static_cast< ::client::vip_op_rsp_op_e >(ret_);
}
inline void vip_op_rsp::set_ret(::client::vip_op_rsp_op_e value) {
  assert(::client::vip_op_rsp_op_e_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// required .client.OP_CODE op = 2;
inline bool vip_op_rsp::has_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_op_rsp::set_has_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_op_rsp::clear_has_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_op_rsp::clear_op() {
  op_ = 1;
  clear_has_op();
}
inline ::client::OP_CODE vip_op_rsp::op() const {
  return static_cast< ::client::OP_CODE >(op_);
}
inline void vip_op_rsp::set_op(::client::OP_CODE value) {
  assert(::client::OP_CODE_IsValid(value));
  set_has_op();
  op_ = value;
}

// -------------------------------------------------------------------

// vip_op_info

// required uint32 op = 1;
inline bool vip_op_info::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_op_info::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_op_info::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_op_info::clear_op() {
  op_ = 0u;
  clear_has_op();
}
inline ::google::protobuf::uint32 vip_op_info::op() const {
  return op_;
}
inline void vip_op_info::set_op(::google::protobuf::uint32 value) {
  set_has_op();
  op_ = value;
}

// repeated .client.vip_op vo = 2;
inline int vip_op_info::vo_size() const {
  return vo_.size();
}
inline void vip_op_info::clear_vo() {
  vo_.Clear();
}
inline const ::client::vip_op& vip_op_info::vo(int index) const {
  return vo_.Get(index);
}
inline ::client::vip_op* vip_op_info::mutable_vo(int index) {
  return vo_.Mutable(index);
}
inline ::client::vip_op* vip_op_info::add_vo() {
  return vo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::vip_op >&
vip_op_info::vo() const {
  return vo_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::vip_op >*
vip_op_info::mutable_vo() {
  return &vo_;
}

// -------------------------------------------------------------------

// vip_op

// required uint32 count = 1;
inline bool vip_op::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vip_op::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vip_op::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vip_op::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 vip_op::count() const {
  return count_;
}
inline void vip_op::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 id = 2 [default = 1];
inline bool vip_op::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vip_op::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vip_op::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vip_op::clear_id() {
  id_ = 1u;
  clear_has_id();
}
inline ::google::protobuf::uint32 vip_op::id() const {
  return id_;
}
inline void vip_op::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::vip_op_rsp_op_e>() {
  return ::client::vip_op_rsp_op_e_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::OP_CODE>() {
  return ::client::OP_CODE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2evip_2eproto__INCLUDED
