// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.auth.proto

#ifndef PROTOBUF_client_2eauth_2eproto__INCLUDED
#define PROTOBUF_client_2eauth_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.create_role.pb.h"
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2eauth_2eproto();
void protobuf_AssignDesc_client_2eauth_2eproto();
void protobuf_ShutdownFile_client_2eauth_2eproto();

class auth_req;
class auth_rsp;

enum AUTH_RET_E {
  ARE_SUCCESS = 1,
  ARE_LOCKED = 2,
  ARE_WALLOW = 3,
  ARE_NOPASS = 4,
  ARE_SYSTEM_ERR = 5
};
bool AUTH_RET_E_IsValid(int value);
const AUTH_RET_E AUTH_RET_E_MIN = ARE_SUCCESS;
const AUTH_RET_E AUTH_RET_E_MAX = ARE_SYSTEM_ERR;
const int AUTH_RET_E_ARRAYSIZE = AUTH_RET_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* AUTH_RET_E_descriptor();
inline const ::std::string& AUTH_RET_E_Name(AUTH_RET_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    AUTH_RET_E_descriptor(), value);
}
inline bool AUTH_RET_E_Parse(
    const ::std::string& name, AUTH_RET_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AUTH_RET_E>(
    AUTH_RET_E_descriptor(), name, value);
}
// ===================================================================

class auth_req : public ::google::protobuf::Message {
 public:
  auth_req();
  virtual ~auth_req();

  auth_req(const auth_req& from);

  inline auth_req& operator=(const auth_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auth_req& default_instance();

  void Swap(auth_req* other);

  // implements Message ----------------------------------------------

  auth_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auth_req& from);
  void MergeFrom(const auth_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string openid = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required string openkey = 2;
  inline bool has_openkey() const;
  inline void clear_openkey();
  static const int kOpenkeyFieldNumber = 2;
  inline const ::std::string& openkey() const;
  inline void set_openkey(const ::std::string& value);
  inline void set_openkey(const char* value);
  inline void set_openkey(const char* value, size_t size);
  inline ::std::string* mutable_openkey();
  inline ::std::string* release_openkey();
  inline void set_allocated_openkey(::std::string* openkey);

  // required uint32 yel_vip = 3;
  inline bool has_yel_vip() const;
  inline void clear_yel_vip();
  static const int kYelVipFieldNumber = 3;
  inline ::google::protobuf::uint32 yel_vip() const;
  inline void set_yel_vip(::google::protobuf::uint32 value);

  // required string sign = 4;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 4;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // required uint32 svr_id = 5;
  inline bool has_svr_id() const;
  inline void clear_svr_id();
  static const int kSvrIdFieldNumber = 5;
  inline ::google::protobuf::uint32 svr_id() const;
  inline void set_svr_id(::google::protobuf::uint32 value);

  // optional uint32 effect_time = 6;
  inline bool has_effect_time() const;
  inline void clear_effect_time();
  static const int kEffectTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 effect_time() const;
  inline void set_effect_time(::google::protobuf::uint32 value);

  // optional string pf = 7;
  inline bool has_pf() const;
  inline void clear_pf();
  static const int kPfFieldNumber = 7;
  inline const ::std::string& pf() const;
  inline void set_pf(const ::std::string& value);
  inline void set_pf(const char* value);
  inline void set_pf(const char* value, size_t size);
  inline ::std::string* mutable_pf();
  inline ::std::string* release_pf();
  inline void set_allocated_pf(::std::string* pf);

  // optional uint32 platform_id = 8 [default = 0];
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 8;
  inline ::google::protobuf::uint32 platform_id() const;
  inline void set_platform_id(::google::protobuf::uint32 value);

  // optional string sid = 9;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 9;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // optional string did = 10;
  inline bool has_did() const;
  inline void clear_did();
  static const int kDidFieldNumber = 10;
  inline const ::std::string& did() const;
  inline void set_did(const ::std::string& value);
  inline void set_did(const char* value);
  inline void set_did(const char* value, size_t size);
  inline ::std::string* mutable_did();
  inline ::std::string* release_did();
  inline void set_allocated_did(::std::string* did);

  // optional string channel_id = 11;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 11;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // optional string app_version = 12;
  inline bool has_app_version() const;
  inline void clear_app_version();
  static const int kAppVersionFieldNumber = 12;
  inline const ::std::string& app_version() const;
  inline void set_app_version(const ::std::string& value);
  inline void set_app_version(const char* value);
  inline void set_app_version(const char* value, size_t size);
  inline ::std::string* mutable_app_version();
  inline ::std::string* release_app_version();
  inline void set_allocated_app_version(::std::string* app_version);

  // optional string app_type = 13;
  inline bool has_app_type() const;
  inline void clear_app_type();
  static const int kAppTypeFieldNumber = 13;
  inline const ::std::string& app_type() const;
  inline void set_app_type(const ::std::string& value);
  inline void set_app_type(const char* value);
  inline void set_app_type(const char* value, size_t size);
  inline ::std::string* mutable_app_type();
  inline ::std::string* release_app_type();
  inline void set_allocated_app_type(::std::string* app_type);

  // optional string device = 14;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 14;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string nm = 15;
  inline bool has_nm() const;
  inline void clear_nm();
  static const int kNmFieldNumber = 15;
  inline const ::std::string& nm() const;
  inline void set_nm(const ::std::string& value);
  inline void set_nm(const char* value);
  inline void set_nm(const char* value, size_t size);
  inline ::std::string* mutable_nm();
  inline ::std::string* release_nm();
  inline void set_allocated_nm(::std::string* nm);

  // optional string mno = 16;
  inline bool has_mno() const;
  inline void clear_mno();
  static const int kMnoFieldNumber = 16;
  inline const ::std::string& mno() const;
  inline void set_mno(const ::std::string& value);
  inline void set_mno(const char* value);
  inline void set_mno(const char* value, size_t size);
  inline ::std::string* mutable_mno();
  inline ::std::string* release_mno();
  inline void set_allocated_mno(::std::string* mno);

  // optional string screen = 17;
  inline bool has_screen() const;
  inline void clear_screen();
  static const int kScreenFieldNumber = 17;
  inline const ::std::string& screen() const;
  inline void set_screen(const ::std::string& value);
  inline void set_screen(const char* value);
  inline void set_screen(const char* value, size_t size);
  inline ::std::string* mutable_screen();
  inline ::std::string* release_screen();
  inline void set_allocated_screen(::std::string* screen);

  // optional string os = 18;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 18;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string mac = 19;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 19;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.auth_req)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_openkey();
  inline void clear_has_openkey();
  inline void set_has_yel_vip();
  inline void clear_has_yel_vip();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_svr_id();
  inline void clear_has_svr_id();
  inline void set_has_effect_time();
  inline void clear_has_effect_time();
  inline void set_has_pf();
  inline void clear_has_pf();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_did();
  inline void clear_has_did();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_app_version();
  inline void clear_has_app_version();
  inline void set_has_app_type();
  inline void clear_has_app_type();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_nm();
  inline void clear_has_nm();
  inline void set_has_mno();
  inline void clear_has_mno();
  inline void set_has_screen();
  inline void clear_has_screen();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* openid_;
  ::std::string* openkey_;
  ::std::string* sign_;
  ::google::protobuf::uint32 yel_vip_;
  ::google::protobuf::uint32 svr_id_;
  ::google::protobuf::uint32 effect_time_;
  ::google::protobuf::uint32 platform_id_;
  ::std::string* pf_;
  ::std::string* sid_;
  ::std::string* did_;
  ::std::string* channel_id_;
  ::std::string* app_version_;
  ::std::string* app_type_;
  ::std::string* device_;
  ::std::string* nm_;
  ::std::string* mno_;
  ::std::string* screen_;
  ::std::string* os_;
  ::std::string* mac_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eauth_2eproto();
  friend void protobuf_AssignDesc_client_2eauth_2eproto();
  friend void protobuf_ShutdownFile_client_2eauth_2eproto();

  void InitAsDefaultInstance();
  static auth_req* default_instance_;
};
// -------------------------------------------------------------------

class auth_rsp : public ::google::protobuf::Message {
 public:
  auth_rsp();
  virtual ~auth_rsp();

  auth_rsp(const auth_rsp& from);

  inline auth_rsp& operator=(const auth_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auth_rsp& default_instance();

  void Swap(auth_rsp* other);

  // implements Message ----------------------------------------------

  auth_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auth_rsp& from);
  void MergeFrom(const auth_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .client.AUTH_RET_E ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::client::AUTH_RET_E ret() const;
  inline void set_ret(::client::AUTH_RET_E value);

  // required uint32 svrtime = 3;
  inline bool has_svrtime() const;
  inline void clear_svrtime();
  static const int kSvrtimeFieldNumber = 3;
  inline ::google::protobuf::uint32 svrtime() const;
  inline void set_svrtime(::google::protobuf::uint32 value);

  // repeated .client.role_info_rsp role_info = 4;
  inline int role_info_size() const;
  inline void clear_role_info();
  static const int kRoleInfoFieldNumber = 4;
  inline const ::client::role_info_rsp& role_info(int index) const;
  inline ::client::role_info_rsp* mutable_role_info(int index);
  inline ::client::role_info_rsp* add_role_info();
  inline const ::google::protobuf::RepeatedPtrField< ::client::role_info_rsp >&
      role_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::role_info_rsp >*
      mutable_role_info();

  // @@protoc_insertion_point(class_scope:client.auth_rsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_svrtime();
  inline void clear_has_svrtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 user_id_;
  int ret_;
  ::google::protobuf::RepeatedPtrField< ::client::role_info_rsp > role_info_;
  ::google::protobuf::uint32 svrtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eauth_2eproto();
  friend void protobuf_AssignDesc_client_2eauth_2eproto();
  friend void protobuf_ShutdownFile_client_2eauth_2eproto();

  void InitAsDefaultInstance();
  static auth_rsp* default_instance_;
};
// ===================================================================


// ===================================================================

// auth_req

// required string openid = 1;
inline bool auth_req::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auth_req::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auth_req::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auth_req::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& auth_req::openid() const {
  return *openid_;
}
inline void auth_req::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void auth_req::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void auth_req::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* auth_req::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string openkey = 2;
inline bool auth_req::has_openkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auth_req::set_has_openkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auth_req::clear_has_openkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auth_req::clear_openkey() {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    openkey_->clear();
  }
  clear_has_openkey();
}
inline const ::std::string& auth_req::openkey() const {
  return *openkey_;
}
inline void auth_req::set_openkey(const ::std::string& value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void auth_req::set_openkey(const char* value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void auth_req::set_openkey(const char* value, size_t size) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_openkey() {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  return openkey_;
}
inline ::std::string* auth_req::release_openkey() {
  clear_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openkey_;
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_openkey(::std::string* openkey) {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  if (openkey) {
    set_has_openkey();
    openkey_ = openkey;
  } else {
    clear_has_openkey();
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 yel_vip = 3;
inline bool auth_req::has_yel_vip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auth_req::set_has_yel_vip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auth_req::clear_has_yel_vip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auth_req::clear_yel_vip() {
  yel_vip_ = 0u;
  clear_has_yel_vip();
}
inline ::google::protobuf::uint32 auth_req::yel_vip() const {
  return yel_vip_;
}
inline void auth_req::set_yel_vip(::google::protobuf::uint32 value) {
  set_has_yel_vip();
  yel_vip_ = value;
}

// required string sign = 4;
inline bool auth_req::has_sign() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void auth_req::set_has_sign() {
  _has_bits_[0] |= 0x00000008u;
}
inline void auth_req::clear_has_sign() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void auth_req::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& auth_req::sign() const {
  return *sign_;
}
inline void auth_req::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void auth_req::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void auth_req::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* auth_req::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 svr_id = 5;
inline bool auth_req::has_svr_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void auth_req::set_has_svr_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void auth_req::clear_has_svr_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void auth_req::clear_svr_id() {
  svr_id_ = 0u;
  clear_has_svr_id();
}
inline ::google::protobuf::uint32 auth_req::svr_id() const {
  return svr_id_;
}
inline void auth_req::set_svr_id(::google::protobuf::uint32 value) {
  set_has_svr_id();
  svr_id_ = value;
}

// optional uint32 effect_time = 6;
inline bool auth_req::has_effect_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void auth_req::set_has_effect_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void auth_req::clear_has_effect_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void auth_req::clear_effect_time() {
  effect_time_ = 0u;
  clear_has_effect_time();
}
inline ::google::protobuf::uint32 auth_req::effect_time() const {
  return effect_time_;
}
inline void auth_req::set_effect_time(::google::protobuf::uint32 value) {
  set_has_effect_time();
  effect_time_ = value;
}

// optional string pf = 7;
inline bool auth_req::has_pf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void auth_req::set_has_pf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void auth_req::clear_has_pf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void auth_req::clear_pf() {
  if (pf_ != &::google::protobuf::internal::kEmptyString) {
    pf_->clear();
  }
  clear_has_pf();
}
inline const ::std::string& auth_req::pf() const {
  return *pf_;
}
inline void auth_req::set_pf(const ::std::string& value) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(value);
}
inline void auth_req::set_pf(const char* value) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(value);
}
inline void auth_req::set_pf(const char* value, size_t size) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_pf() {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  return pf_;
}
inline ::std::string* auth_req::release_pf() {
  clear_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pf_;
    pf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_pf(::std::string* pf) {
  if (pf_ != &::google::protobuf::internal::kEmptyString) {
    delete pf_;
  }
  if (pf) {
    set_has_pf();
    pf_ = pf;
  } else {
    clear_has_pf();
    pf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform_id = 8 [default = 0];
inline bool auth_req::has_platform_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void auth_req::set_has_platform_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void auth_req::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void auth_req::clear_platform_id() {
  platform_id_ = 0u;
  clear_has_platform_id();
}
inline ::google::protobuf::uint32 auth_req::platform_id() const {
  return platform_id_;
}
inline void auth_req::set_platform_id(::google::protobuf::uint32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// optional string sid = 9;
inline bool auth_req::has_sid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void auth_req::set_has_sid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void auth_req::clear_has_sid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void auth_req::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& auth_req::sid() const {
  return *sid_;
}
inline void auth_req::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void auth_req::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void auth_req::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* auth_req::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string did = 10;
inline bool auth_req::has_did() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void auth_req::set_has_did() {
  _has_bits_[0] |= 0x00000200u;
}
inline void auth_req::clear_has_did() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void auth_req::clear_did() {
  if (did_ != &::google::protobuf::internal::kEmptyString) {
    did_->clear();
  }
  clear_has_did();
}
inline const ::std::string& auth_req::did() const {
  return *did_;
}
inline void auth_req::set_did(const ::std::string& value) {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  did_->assign(value);
}
inline void auth_req::set_did(const char* value) {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  did_->assign(value);
}
inline void auth_req::set_did(const char* value, size_t size) {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  did_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_did() {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  return did_;
}
inline ::std::string* auth_req::release_did() {
  clear_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = did_;
    did_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_did(::std::string* did) {
  if (did_ != &::google::protobuf::internal::kEmptyString) {
    delete did_;
  }
  if (did) {
    set_has_did();
    did_ = did;
  } else {
    clear_has_did();
    did_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel_id = 11;
inline bool auth_req::has_channel_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void auth_req::set_has_channel_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void auth_req::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void auth_req::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& auth_req::channel_id() const {
  return *channel_id_;
}
inline void auth_req::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void auth_req::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void auth_req::set_channel_id(const char* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* auth_req::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string app_version = 12;
inline bool auth_req::has_app_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void auth_req::set_has_app_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void auth_req::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void auth_req::clear_app_version() {
  if (app_version_ != &::google::protobuf::internal::kEmptyString) {
    app_version_->clear();
  }
  clear_has_app_version();
}
inline const ::std::string& auth_req::app_version() const {
  return *app_version_;
}
inline void auth_req::set_app_version(const ::std::string& value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
}
inline void auth_req::set_app_version(const char* value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
}
inline void auth_req::set_app_version(const char* value, size_t size) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_app_version() {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  return app_version_;
}
inline ::std::string* auth_req::release_app_version() {
  clear_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_version_;
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_app_version(::std::string* app_version) {
  if (app_version_ != &::google::protobuf::internal::kEmptyString) {
    delete app_version_;
  }
  if (app_version) {
    set_has_app_version();
    app_version_ = app_version;
  } else {
    clear_has_app_version();
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string app_type = 13;
inline bool auth_req::has_app_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void auth_req::set_has_app_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void auth_req::clear_has_app_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void auth_req::clear_app_type() {
  if (app_type_ != &::google::protobuf::internal::kEmptyString) {
    app_type_->clear();
  }
  clear_has_app_type();
}
inline const ::std::string& auth_req::app_type() const {
  return *app_type_;
}
inline void auth_req::set_app_type(const ::std::string& value) {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  app_type_->assign(value);
}
inline void auth_req::set_app_type(const char* value) {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  app_type_->assign(value);
}
inline void auth_req::set_app_type(const char* value, size_t size) {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  app_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_app_type() {
  set_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    app_type_ = new ::std::string;
  }
  return app_type_;
}
inline ::std::string* auth_req::release_app_type() {
  clear_has_app_type();
  if (app_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_type_;
    app_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_app_type(::std::string* app_type) {
  if (app_type_ != &::google::protobuf::internal::kEmptyString) {
    delete app_type_;
  }
  if (app_type) {
    set_has_app_type();
    app_type_ = app_type;
  } else {
    clear_has_app_type();
    app_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 14;
inline bool auth_req::has_device() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void auth_req::set_has_device() {
  _has_bits_[0] |= 0x00002000u;
}
inline void auth_req::clear_has_device() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void auth_req::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& auth_req::device() const {
  return *device_;
}
inline void auth_req::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void auth_req::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void auth_req::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* auth_req::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nm = 15;
inline bool auth_req::has_nm() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void auth_req::set_has_nm() {
  _has_bits_[0] |= 0x00004000u;
}
inline void auth_req::clear_has_nm() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void auth_req::clear_nm() {
  if (nm_ != &::google::protobuf::internal::kEmptyString) {
    nm_->clear();
  }
  clear_has_nm();
}
inline const ::std::string& auth_req::nm() const {
  return *nm_;
}
inline void auth_req::set_nm(const ::std::string& value) {
  set_has_nm();
  if (nm_ == &::google::protobuf::internal::kEmptyString) {
    nm_ = new ::std::string;
  }
  nm_->assign(value);
}
inline void auth_req::set_nm(const char* value) {
  set_has_nm();
  if (nm_ == &::google::protobuf::internal::kEmptyString) {
    nm_ = new ::std::string;
  }
  nm_->assign(value);
}
inline void auth_req::set_nm(const char* value, size_t size) {
  set_has_nm();
  if (nm_ == &::google::protobuf::internal::kEmptyString) {
    nm_ = new ::std::string;
  }
  nm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_nm() {
  set_has_nm();
  if (nm_ == &::google::protobuf::internal::kEmptyString) {
    nm_ = new ::std::string;
  }
  return nm_;
}
inline ::std::string* auth_req::release_nm() {
  clear_has_nm();
  if (nm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nm_;
    nm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_nm(::std::string* nm) {
  if (nm_ != &::google::protobuf::internal::kEmptyString) {
    delete nm_;
  }
  if (nm) {
    set_has_nm();
    nm_ = nm;
  } else {
    clear_has_nm();
    nm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mno = 16;
inline bool auth_req::has_mno() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void auth_req::set_has_mno() {
  _has_bits_[0] |= 0x00008000u;
}
inline void auth_req::clear_has_mno() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void auth_req::clear_mno() {
  if (mno_ != &::google::protobuf::internal::kEmptyString) {
    mno_->clear();
  }
  clear_has_mno();
}
inline const ::std::string& auth_req::mno() const {
  return *mno_;
}
inline void auth_req::set_mno(const ::std::string& value) {
  set_has_mno();
  if (mno_ == &::google::protobuf::internal::kEmptyString) {
    mno_ = new ::std::string;
  }
  mno_->assign(value);
}
inline void auth_req::set_mno(const char* value) {
  set_has_mno();
  if (mno_ == &::google::protobuf::internal::kEmptyString) {
    mno_ = new ::std::string;
  }
  mno_->assign(value);
}
inline void auth_req::set_mno(const char* value, size_t size) {
  set_has_mno();
  if (mno_ == &::google::protobuf::internal::kEmptyString) {
    mno_ = new ::std::string;
  }
  mno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_mno() {
  set_has_mno();
  if (mno_ == &::google::protobuf::internal::kEmptyString) {
    mno_ = new ::std::string;
  }
  return mno_;
}
inline ::std::string* auth_req::release_mno() {
  clear_has_mno();
  if (mno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mno_;
    mno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_mno(::std::string* mno) {
  if (mno_ != &::google::protobuf::internal::kEmptyString) {
    delete mno_;
  }
  if (mno) {
    set_has_mno();
    mno_ = mno;
  } else {
    clear_has_mno();
    mno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string screen = 17;
inline bool auth_req::has_screen() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void auth_req::set_has_screen() {
  _has_bits_[0] |= 0x00010000u;
}
inline void auth_req::clear_has_screen() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void auth_req::clear_screen() {
  if (screen_ != &::google::protobuf::internal::kEmptyString) {
    screen_->clear();
  }
  clear_has_screen();
}
inline const ::std::string& auth_req::screen() const {
  return *screen_;
}
inline void auth_req::set_screen(const ::std::string& value) {
  set_has_screen();
  if (screen_ == &::google::protobuf::internal::kEmptyString) {
    screen_ = new ::std::string;
  }
  screen_->assign(value);
}
inline void auth_req::set_screen(const char* value) {
  set_has_screen();
  if (screen_ == &::google::protobuf::internal::kEmptyString) {
    screen_ = new ::std::string;
  }
  screen_->assign(value);
}
inline void auth_req::set_screen(const char* value, size_t size) {
  set_has_screen();
  if (screen_ == &::google::protobuf::internal::kEmptyString) {
    screen_ = new ::std::string;
  }
  screen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_screen() {
  set_has_screen();
  if (screen_ == &::google::protobuf::internal::kEmptyString) {
    screen_ = new ::std::string;
  }
  return screen_;
}
inline ::std::string* auth_req::release_screen() {
  clear_has_screen();
  if (screen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = screen_;
    screen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_screen(::std::string* screen) {
  if (screen_ != &::google::protobuf::internal::kEmptyString) {
    delete screen_;
  }
  if (screen) {
    set_has_screen();
    screen_ = screen;
  } else {
    clear_has_screen();
    screen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 18;
inline bool auth_req::has_os() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void auth_req::set_has_os() {
  _has_bits_[0] |= 0x00020000u;
}
inline void auth_req::clear_has_os() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void auth_req::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& auth_req::os() const {
  return *os_;
}
inline void auth_req::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void auth_req::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void auth_req::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* auth_req::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mac = 19;
inline bool auth_req::has_mac() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void auth_req::set_has_mac() {
  _has_bits_[0] |= 0x00040000u;
}
inline void auth_req::clear_has_mac() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void auth_req::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& auth_req::mac() const {
  return *mac_;
}
inline void auth_req::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void auth_req::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void auth_req::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* auth_req::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* auth_req::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void auth_req::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .client.server_head svr_head = 1000;
inline bool auth_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void auth_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00080000u;
}
inline void auth_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void auth_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& auth_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* auth_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* auth_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void auth_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// auth_rsp

// required uint32 user_id = 1;
inline bool auth_rsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auth_rsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auth_rsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auth_rsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 auth_rsp::user_id() const {
  return user_id_;
}
inline void auth_rsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .client.AUTH_RET_E ret = 2;
inline bool auth_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auth_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auth_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auth_rsp::clear_ret() {
  ret_ = 1;
  clear_has_ret();
}
inline ::client::AUTH_RET_E auth_rsp::ret() const {
  return static_cast< ::client::AUTH_RET_E >(ret_);
}
inline void auth_rsp::set_ret(::client::AUTH_RET_E value) {
  assert(::client::AUTH_RET_E_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// required uint32 svrtime = 3;
inline bool auth_rsp::has_svrtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auth_rsp::set_has_svrtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auth_rsp::clear_has_svrtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auth_rsp::clear_svrtime() {
  svrtime_ = 0u;
  clear_has_svrtime();
}
inline ::google::protobuf::uint32 auth_rsp::svrtime() const {
  return svrtime_;
}
inline void auth_rsp::set_svrtime(::google::protobuf::uint32 value) {
  set_has_svrtime();
  svrtime_ = value;
}

// repeated .client.role_info_rsp role_info = 4;
inline int auth_rsp::role_info_size() const {
  return role_info_.size();
}
inline void auth_rsp::clear_role_info() {
  role_info_.Clear();
}
inline const ::client::role_info_rsp& auth_rsp::role_info(int index) const {
  return role_info_.Get(index);
}
inline ::client::role_info_rsp* auth_rsp::mutable_role_info(int index) {
  return role_info_.Mutable(index);
}
inline ::client::role_info_rsp* auth_rsp::add_role_info() {
  return role_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::role_info_rsp >&
auth_rsp::role_info() const {
  return role_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::role_info_rsp >*
auth_rsp::mutable_role_info() {
  return &role_info_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::AUTH_RET_E>() {
  return ::client::AUTH_RET_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eauth_2eproto__INCLUDED
