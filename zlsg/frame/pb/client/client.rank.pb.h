// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.rank.proto

#ifndef PROTOBUF_client_2erank_2eproto__INCLUDED
#define PROTOBUF_client_2erank_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2erank_2eproto();
void protobuf_AssignDesc_client_2erank_2eproto();
void protobuf_ShutdownFile_client_2erank_2eproto();

class rank_rule;
class rank_data;
class rank_item;
class rank_list_req;
class rank_list_rsp;
class rank_add_data;
class act_rank_add_data;

enum RANK_TYPE {
  RANK_PERSONAL_POWER = 0,
  RANK_PERSONAL_LEVEL = 1,
  RANK_MOUNT = 2,
  RANK_POTENTIAL = 3,
  RANK_BOWS = 4,
  RANK_GEMS = 5,
  RANK_EQUIP_POWER = 6,
  RANK_GEMS_INTEGRAL = 7,
  RANK_COUNT = 18
};
bool RANK_TYPE_IsValid(int value);
const RANK_TYPE RANK_TYPE_MIN = RANK_PERSONAL_POWER;
const RANK_TYPE RANK_TYPE_MAX = RANK_COUNT;
const int RANK_TYPE_ARRAYSIZE = RANK_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RANK_TYPE_descriptor();
inline const ::std::string& RANK_TYPE_Name(RANK_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RANK_TYPE_descriptor(), value);
}
inline bool RANK_TYPE_Parse(
    const ::std::string& name, RANK_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RANK_TYPE>(
    RANK_TYPE_descriptor(), name, value);
}
// ===================================================================

class rank_rule : public ::google::protobuf::Message {
 public:
  rank_rule();
  virtual ~rank_rule();

  rank_rule(const rank_rule& from);

  inline rank_rule& operator=(const rank_rule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_rule& default_instance();

  void Swap(rank_rule* other);

  // implements Message ----------------------------------------------

  rank_rule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_rule& from);
  void MergeFrom(const rank_rule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional uint32 first = 2 [default = 0];
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 2;
  inline ::google::protobuf::uint32 first() const;
  inline void set_first(::google::protobuf::uint32 value);

  // optional uint32 second = 3 [default = 0];
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 3;
  inline ::google::protobuf::uint32 second() const;
  inline void set_second(::google::protobuf::uint32 value);

  // optional uint32 third = 4 [default = 0];
  inline bool has_third() const;
  inline void clear_third();
  static const int kThirdFieldNumber = 4;
  inline ::google::protobuf::uint32 third() const;
  inline void set_third(::google::protobuf::uint32 value);

  // optional uint32 forth = 5 [default = 0];
  inline bool has_forth() const;
  inline void clear_forth();
  static const int kForthFieldNumber = 5;
  inline ::google::protobuf::uint32 forth() const;
  inline void set_forth(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.rank_rule)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_third();
  inline void clear_has_third();
  inline void set_has_forth();
  inline void clear_has_forth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 first_;
  ::google::protobuf::uint32 second_;
  ::google::protobuf::uint32 third_;
  ::google::protobuf::uint32 forth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erank_2eproto();
  friend void protobuf_AssignDesc_client_2erank_2eproto();
  friend void protobuf_ShutdownFile_client_2erank_2eproto();

  void InitAsDefaultInstance();
  static rank_rule* default_instance_;
};
// -------------------------------------------------------------------

class rank_data : public ::google::protobuf::Message {
 public:
  rank_data();
  virtual ~rank_data();

  rank_data(const rank_data& from);

  inline rank_data& operator=(const rank_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_data& default_instance();

  void Swap(rank_data* other);

  // implements Message ----------------------------------------------

  rank_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_data& from);
  void MergeFrom(const rank_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .client.rank_rule ru_show = 1;
  inline bool has_ru_show() const;
  inline void clear_ru_show();
  static const int kRuShowFieldNumber = 1;
  inline const ::client::rank_rule& ru_show() const;
  inline ::client::rank_rule* mutable_ru_show();
  inline ::client::rank_rule* release_ru_show();
  inline void set_allocated_ru_show(::client::rank_rule* ru_show);

  // optional .client.rank_rule ru_real = 2;
  inline bool has_ru_real() const;
  inline void clear_ru_real();
  static const int kRuRealFieldNumber = 2;
  inline const ::client::rank_rule& ru_real() const;
  inline ::client::rank_rule* mutable_ru_real();
  inline ::client::rank_rule* release_ru_real();
  inline void set_allocated_ru_real(::client::rank_rule* ru_real);

  // @@protoc_insertion_point(class_scope:client.rank_data)
 private:
  inline void set_has_ru_show();
  inline void clear_has_ru_show();
  inline void set_has_ru_real();
  inline void clear_has_ru_real();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::rank_rule* ru_show_;
  ::client::rank_rule* ru_real_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erank_2eproto();
  friend void protobuf_AssignDesc_client_2erank_2eproto();
  friend void protobuf_ShutdownFile_client_2erank_2eproto();

  void InitAsDefaultInstance();
  static rank_data* default_instance_;
};
// -------------------------------------------------------------------

class rank_item : public ::google::protobuf::Message {
 public:
  rank_item();
  virtual ~rank_item();

  rank_item(const rank_item& from);

  inline rank_item& operator=(const rank_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_item& default_instance();

  void Swap(rank_item* other);

  // implements Message ----------------------------------------------

  rank_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_item& from);
  void MergeFrom(const rank_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional string role_name = 3;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 vip_lv = 4;
  inline bool has_vip_lv() const;
  inline void clear_vip_lv();
  static const int kVipLvFieldNumber = 4;
  inline ::google::protobuf::uint32 vip_lv() const;
  inline void set_vip_lv(::google::protobuf::uint32 value);

  // optional uint32 profession = 5;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 5;
  inline ::google::protobuf::uint32 profession() const;
  inline void set_profession(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.rank_item)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_vip_lv();
  inline void clear_has_vip_lv();
  inline void set_has_profession();
  inline void clear_has_profession();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 value_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 vip_lv_;
  ::google::protobuf::uint32 profession_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erank_2eproto();
  friend void protobuf_AssignDesc_client_2erank_2eproto();
  friend void protobuf_ShutdownFile_client_2erank_2eproto();

  void InitAsDefaultInstance();
  static rank_item* default_instance_;
};
// -------------------------------------------------------------------

class rank_list_req : public ::google::protobuf::Message {
 public:
  rank_list_req();
  virtual ~rank_list_req();

  rank_list_req(const rank_list_req& from);

  inline rank_list_req& operator=(const rank_list_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_list_req& default_instance();

  void Swap(rank_list_req* other);

  // implements Message ----------------------------------------------

  rank_list_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_list_req& from);
  void MergeFrom(const rank_list_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.RANK_TYPE rt = 1;
  inline bool has_rt() const;
  inline void clear_rt();
  static const int kRtFieldNumber = 1;
  inline ::client::RANK_TYPE rt() const;
  inline void set_rt(::client::RANK_TYPE value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.rank_list_req)
 private:
  inline void set_has_rt();
  inline void clear_has_rt();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  int rt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erank_2eproto();
  friend void protobuf_AssignDesc_client_2erank_2eproto();
  friend void protobuf_ShutdownFile_client_2erank_2eproto();

  void InitAsDefaultInstance();
  static rank_list_req* default_instance_;
};
// -------------------------------------------------------------------

class rank_list_rsp : public ::google::protobuf::Message {
 public:
  rank_list_rsp();
  virtual ~rank_list_rsp();

  rank_list_rsp(const rank_list_rsp& from);

  inline rank_list_rsp& operator=(const rank_list_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_list_rsp& default_instance();

  void Swap(rank_list_rsp* other);

  // implements Message ----------------------------------------------

  rank_list_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_list_rsp& from);
  void MergeFrom(const rank_list_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.RANK_TYPE rt = 1;
  inline bool has_rt() const;
  inline void clear_rt();
  static const int kRtFieldNumber = 1;
  inline ::client::RANK_TYPE rt() const;
  inline void set_rt(::client::RANK_TYPE value);

  // repeated .client.rank_item ri = 2;
  inline int ri_size() const;
  inline void clear_ri();
  static const int kRiFieldNumber = 2;
  inline const ::client::rank_item& ri(int index) const;
  inline ::client::rank_item* mutable_ri(int index);
  inline ::client::rank_item* add_ri();
  inline const ::google::protobuf::RepeatedPtrField< ::client::rank_item >&
      ri() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::rank_item >*
      mutable_ri();

  // @@protoc_insertion_point(class_scope:client.rank_list_rsp)
 private:
  inline void set_has_rt();
  inline void clear_has_rt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::rank_item > ri_;
  int rt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erank_2eproto();
  friend void protobuf_AssignDesc_client_2erank_2eproto();
  friend void protobuf_ShutdownFile_client_2erank_2eproto();

  void InitAsDefaultInstance();
  static rank_list_rsp* default_instance_;
};
// -------------------------------------------------------------------

class rank_add_data : public ::google::protobuf::Message {
 public:
  rank_add_data();
  virtual ~rank_add_data();

  rank_add_data(const rank_add_data& from);

  inline rank_add_data& operator=(const rank_add_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_add_data& default_instance();

  void Swap(rank_add_data* other);

  // implements Message ----------------------------------------------

  rank_add_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_add_data& from);
  void MergeFrom(const rank_add_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.RANK_TYPE rt = 1;
  inline bool has_rt() const;
  inline void clear_rt();
  static const int kRtFieldNumber = 1;
  inline ::client::RANK_TYPE rt() const;
  inline void set_rt(::client::RANK_TYPE value);

  // required .client.rank_rule ru = 2;
  inline bool has_ru() const;
  inline void clear_ru();
  static const int kRuFieldNumber = 2;
  inline const ::client::rank_rule& ru() const;
  inline ::client::rank_rule* mutable_ru();
  inline ::client::rank_rule* release_ru();
  inline void set_allocated_ru(::client::rank_rule* ru);

  // @@protoc_insertion_point(class_scope:client.rank_add_data)
 private:
  inline void set_has_rt();
  inline void clear_has_rt();
  inline void set_has_ru();
  inline void clear_has_ru();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::rank_rule* ru_;
  int rt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erank_2eproto();
  friend void protobuf_AssignDesc_client_2erank_2eproto();
  friend void protobuf_ShutdownFile_client_2erank_2eproto();

  void InitAsDefaultInstance();
  static rank_add_data* default_instance_;
};
// -------------------------------------------------------------------

class act_rank_add_data : public ::google::protobuf::Message {
 public:
  act_rank_add_data();
  virtual ~act_rank_add_data();

  act_rank_add_data(const act_rank_add_data& from);

  inline act_rank_add_data& operator=(const act_rank_add_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const act_rank_add_data& default_instance();

  void Swap(act_rank_add_data* other);

  // implements Message ----------------------------------------------

  act_rank_add_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const act_rank_add_data& from);
  void MergeFrom(const act_rank_add_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.RANK_TYPE rt = 1;
  inline bool has_rt() const;
  inline void clear_rt();
  static const int kRtFieldNumber = 1;
  inline ::client::RANK_TYPE rt() const;
  inline void set_rt(::client::RANK_TYPE value);

  // required .client.rank_rule ru = 2;
  inline bool has_ru() const;
  inline void clear_ru();
  static const int kRuFieldNumber = 2;
  inline const ::client::rank_rule& ru() const;
  inline ::client::rank_rule* mutable_ru();
  inline ::client::rank_rule* release_ru();
  inline void set_allocated_ru(::client::rank_rule* ru);

  // required uint32 limit_value = 3;
  inline bool has_limit_value() const;
  inline void clear_limit_value();
  static const int kLimitValueFieldNumber = 3;
  inline ::google::protobuf::uint32 limit_value() const;
  inline void set_limit_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.act_rank_add_data)
 private:
  inline void set_has_rt();
  inline void clear_has_rt();
  inline void set_has_ru();
  inline void clear_has_ru();
  inline void set_has_limit_value();
  inline void clear_has_limit_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::rank_rule* ru_;
  int rt_;
  ::google::protobuf::uint32 limit_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erank_2eproto();
  friend void protobuf_AssignDesc_client_2erank_2eproto();
  friend void protobuf_ShutdownFile_client_2erank_2eproto();

  void InitAsDefaultInstance();
  static act_rank_add_data* default_instance_;
};
// ===================================================================


// ===================================================================

// rank_rule

// required uint32 role_id = 1;
inline bool rank_rule::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_rule::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_rule::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_rule::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 rank_rule::role_id() const {
  return role_id_;
}
inline void rank_rule::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional uint32 first = 2 [default = 0];
inline bool rank_rule::has_first() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_rule::set_has_first() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_rule::clear_has_first() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_rule::clear_first() {
  first_ = 0u;
  clear_has_first();
}
inline ::google::protobuf::uint32 rank_rule::first() const {
  return first_;
}
inline void rank_rule::set_first(::google::protobuf::uint32 value) {
  set_has_first();
  first_ = value;
}

// optional uint32 second = 3 [default = 0];
inline bool rank_rule::has_second() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rank_rule::set_has_second() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rank_rule::clear_has_second() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rank_rule::clear_second() {
  second_ = 0u;
  clear_has_second();
}
inline ::google::protobuf::uint32 rank_rule::second() const {
  return second_;
}
inline void rank_rule::set_second(::google::protobuf::uint32 value) {
  set_has_second();
  second_ = value;
}

// optional uint32 third = 4 [default = 0];
inline bool rank_rule::has_third() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void rank_rule::set_has_third() {
  _has_bits_[0] |= 0x00000008u;
}
inline void rank_rule::clear_has_third() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void rank_rule::clear_third() {
  third_ = 0u;
  clear_has_third();
}
inline ::google::protobuf::uint32 rank_rule::third() const {
  return third_;
}
inline void rank_rule::set_third(::google::protobuf::uint32 value) {
  set_has_third();
  third_ = value;
}

// optional uint32 forth = 5 [default = 0];
inline bool rank_rule::has_forth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void rank_rule::set_has_forth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void rank_rule::clear_has_forth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void rank_rule::clear_forth() {
  forth_ = 0u;
  clear_has_forth();
}
inline ::google::protobuf::uint32 rank_rule::forth() const {
  return forth_;
}
inline void rank_rule::set_forth(::google::protobuf::uint32 value) {
  set_has_forth();
  forth_ = value;
}

// -------------------------------------------------------------------

// rank_data

// optional .client.rank_rule ru_show = 1;
inline bool rank_data::has_ru_show() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_data::set_has_ru_show() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_data::clear_has_ru_show() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_data::clear_ru_show() {
  if (ru_show_ != NULL) ru_show_->::client::rank_rule::Clear();
  clear_has_ru_show();
}
inline const ::client::rank_rule& rank_data::ru_show() const {
  return ru_show_ != NULL ? *ru_show_ : *default_instance_->ru_show_;
}
inline ::client::rank_rule* rank_data::mutable_ru_show() {
  set_has_ru_show();
  if (ru_show_ == NULL) ru_show_ = new ::client::rank_rule;
  return ru_show_;
}
inline ::client::rank_rule* rank_data::release_ru_show() {
  clear_has_ru_show();
  ::client::rank_rule* temp = ru_show_;
  ru_show_ = NULL;
  return temp;
}
inline void rank_data::set_allocated_ru_show(::client::rank_rule* ru_show) {
  delete ru_show_;
  ru_show_ = ru_show;
  if (ru_show) {
    set_has_ru_show();
  } else {
    clear_has_ru_show();
  }
}

// optional .client.rank_rule ru_real = 2;
inline bool rank_data::has_ru_real() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_data::set_has_ru_real() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_data::clear_has_ru_real() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_data::clear_ru_real() {
  if (ru_real_ != NULL) ru_real_->::client::rank_rule::Clear();
  clear_has_ru_real();
}
inline const ::client::rank_rule& rank_data::ru_real() const {
  return ru_real_ != NULL ? *ru_real_ : *default_instance_->ru_real_;
}
inline ::client::rank_rule* rank_data::mutable_ru_real() {
  set_has_ru_real();
  if (ru_real_ == NULL) ru_real_ = new ::client::rank_rule;
  return ru_real_;
}
inline ::client::rank_rule* rank_data::release_ru_real() {
  clear_has_ru_real();
  ::client::rank_rule* temp = ru_real_;
  ru_real_ = NULL;
  return temp;
}
inline void rank_data::set_allocated_ru_real(::client::rank_rule* ru_real) {
  delete ru_real_;
  ru_real_ = ru_real;
  if (ru_real) {
    set_has_ru_real();
  } else {
    clear_has_ru_real();
  }
}

// -------------------------------------------------------------------

// rank_item

// required uint32 role_id = 1;
inline bool rank_item::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_item::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_item::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_item::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 rank_item::role_id() const {
  return role_id_;
}
inline void rank_item::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required uint32 value = 2;
inline bool rank_item::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_item::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_item::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_item::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 rank_item::value() const {
  return value_;
}
inline void rank_item::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// optional string role_name = 3;
inline bool rank_item::has_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rank_item::set_has_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rank_item::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rank_item::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& rank_item::role_name() const {
  return *role_name_;
}
inline void rank_item::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void rank_item::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void rank_item::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rank_item::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* rank_item::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rank_item::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 vip_lv = 4;
inline bool rank_item::has_vip_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void rank_item::set_has_vip_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void rank_item::clear_has_vip_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void rank_item::clear_vip_lv() {
  vip_lv_ = 0u;
  clear_has_vip_lv();
}
inline ::google::protobuf::uint32 rank_item::vip_lv() const {
  return vip_lv_;
}
inline void rank_item::set_vip_lv(::google::protobuf::uint32 value) {
  set_has_vip_lv();
  vip_lv_ = value;
}

// optional uint32 profession = 5;
inline bool rank_item::has_profession() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void rank_item::set_has_profession() {
  _has_bits_[0] |= 0x00000010u;
}
inline void rank_item::clear_has_profession() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void rank_item::clear_profession() {
  profession_ = 0u;
  clear_has_profession();
}
inline ::google::protobuf::uint32 rank_item::profession() const {
  return profession_;
}
inline void rank_item::set_profession(::google::protobuf::uint32 value) {
  set_has_profession();
  profession_ = value;
}

// -------------------------------------------------------------------

// rank_list_req

// required .client.RANK_TYPE rt = 1;
inline bool rank_list_req::has_rt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_list_req::set_has_rt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_list_req::clear_has_rt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_list_req::clear_rt() {
  rt_ = 0;
  clear_has_rt();
}
inline ::client::RANK_TYPE rank_list_req::rt() const {
  return static_cast< ::client::RANK_TYPE >(rt_);
}
inline void rank_list_req::set_rt(::client::RANK_TYPE value) {
  assert(::client::RANK_TYPE_IsValid(value));
  set_has_rt();
  rt_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool rank_list_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_list_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_list_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_list_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& rank_list_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* rank_list_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* rank_list_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void rank_list_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// rank_list_rsp

// required .client.RANK_TYPE rt = 1;
inline bool rank_list_rsp::has_rt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_list_rsp::set_has_rt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_list_rsp::clear_has_rt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_list_rsp::clear_rt() {
  rt_ = 0;
  clear_has_rt();
}
inline ::client::RANK_TYPE rank_list_rsp::rt() const {
  return static_cast< ::client::RANK_TYPE >(rt_);
}
inline void rank_list_rsp::set_rt(::client::RANK_TYPE value) {
  assert(::client::RANK_TYPE_IsValid(value));
  set_has_rt();
  rt_ = value;
}

// repeated .client.rank_item ri = 2;
inline int rank_list_rsp::ri_size() const {
  return ri_.size();
}
inline void rank_list_rsp::clear_ri() {
  ri_.Clear();
}
inline const ::client::rank_item& rank_list_rsp::ri(int index) const {
  return ri_.Get(index);
}
inline ::client::rank_item* rank_list_rsp::mutable_ri(int index) {
  return ri_.Mutable(index);
}
inline ::client::rank_item* rank_list_rsp::add_ri() {
  return ri_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::rank_item >&
rank_list_rsp::ri() const {
  return ri_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::rank_item >*
rank_list_rsp::mutable_ri() {
  return &ri_;
}

// -------------------------------------------------------------------

// rank_add_data

// required .client.RANK_TYPE rt = 1;
inline bool rank_add_data::has_rt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_add_data::set_has_rt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_add_data::clear_has_rt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_add_data::clear_rt() {
  rt_ = 0;
  clear_has_rt();
}
inline ::client::RANK_TYPE rank_add_data::rt() const {
  return static_cast< ::client::RANK_TYPE >(rt_);
}
inline void rank_add_data::set_rt(::client::RANK_TYPE value) {
  assert(::client::RANK_TYPE_IsValid(value));
  set_has_rt();
  rt_ = value;
}

// required .client.rank_rule ru = 2;
inline bool rank_add_data::has_ru() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_add_data::set_has_ru() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_add_data::clear_has_ru() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_add_data::clear_ru() {
  if (ru_ != NULL) ru_->::client::rank_rule::Clear();
  clear_has_ru();
}
inline const ::client::rank_rule& rank_add_data::ru() const {
  return ru_ != NULL ? *ru_ : *default_instance_->ru_;
}
inline ::client::rank_rule* rank_add_data::mutable_ru() {
  set_has_ru();
  if (ru_ == NULL) ru_ = new ::client::rank_rule;
  return ru_;
}
inline ::client::rank_rule* rank_add_data::release_ru() {
  clear_has_ru();
  ::client::rank_rule* temp = ru_;
  ru_ = NULL;
  return temp;
}
inline void rank_add_data::set_allocated_ru(::client::rank_rule* ru) {
  delete ru_;
  ru_ = ru;
  if (ru) {
    set_has_ru();
  } else {
    clear_has_ru();
  }
}

// -------------------------------------------------------------------

// act_rank_add_data

// required .client.RANK_TYPE rt = 1;
inline bool act_rank_add_data::has_rt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void act_rank_add_data::set_has_rt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void act_rank_add_data::clear_has_rt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void act_rank_add_data::clear_rt() {
  rt_ = 0;
  clear_has_rt();
}
inline ::client::RANK_TYPE act_rank_add_data::rt() const {
  return static_cast< ::client::RANK_TYPE >(rt_);
}
inline void act_rank_add_data::set_rt(::client::RANK_TYPE value) {
  assert(::client::RANK_TYPE_IsValid(value));
  set_has_rt();
  rt_ = value;
}

// required .client.rank_rule ru = 2;
inline bool act_rank_add_data::has_ru() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void act_rank_add_data::set_has_ru() {
  _has_bits_[0] |= 0x00000002u;
}
inline void act_rank_add_data::clear_has_ru() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void act_rank_add_data::clear_ru() {
  if (ru_ != NULL) ru_->::client::rank_rule::Clear();
  clear_has_ru();
}
inline const ::client::rank_rule& act_rank_add_data::ru() const {
  return ru_ != NULL ? *ru_ : *default_instance_->ru_;
}
inline ::client::rank_rule* act_rank_add_data::mutable_ru() {
  set_has_ru();
  if (ru_ == NULL) ru_ = new ::client::rank_rule;
  return ru_;
}
inline ::client::rank_rule* act_rank_add_data::release_ru() {
  clear_has_ru();
  ::client::rank_rule* temp = ru_;
  ru_ = NULL;
  return temp;
}
inline void act_rank_add_data::set_allocated_ru(::client::rank_rule* ru) {
  delete ru_;
  ru_ = ru;
  if (ru) {
    set_has_ru();
  } else {
    clear_has_ru();
  }
}

// required uint32 limit_value = 3;
inline bool act_rank_add_data::has_limit_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void act_rank_add_data::set_has_limit_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void act_rank_add_data::clear_has_limit_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void act_rank_add_data::clear_limit_value() {
  limit_value_ = 0u;
  clear_has_limit_value();
}
inline ::google::protobuf::uint32 act_rank_add_data::limit_value() const {
  return limit_value_;
}
inline void act_rank_add_data::set_limit_value(::google::protobuf::uint32 value) {
  set_has_limit_value();
  limit_value_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::RANK_TYPE>() {
  return ::client::RANK_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2erank_2eproto__INCLUDED
