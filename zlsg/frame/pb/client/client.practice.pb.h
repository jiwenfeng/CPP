// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.practice.proto

#ifndef PROTOBUF_client_2epractice_2eproto__INCLUDED
#define PROTOBUF_client_2epractice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2epractice_2eproto();
void protobuf_AssignDesc_client_2epractice_2eproto();
void protobuf_ShutdownFile_client_2epractice_2eproto();

class practice_req;
class practice_rsp;
class comm_practice_req;
class comm_practice_rsp;
class comm_practice_list_req;
class comm_practice_info;
class comm_practice_list_rsp;
class comm_practice_invite;
class comm_practice_invite_result;
class auto_agree_comm_practice;
class stop_comm_practice_req;

enum PRACTICE_RESULT_E {
  PRE_SUCCESS = 0,
  PRE_OTHER_REFUSE = 1,
  PRE_OTHER_PRAED = 2,
  PRE_OTHER_LEAVE = 3,
  PRE_OTHER_CANNOT = 4,
  PRE_DISTANCE_LIMIT = 5,
  PRE_SELF_CANNOT = 6,
  PRE_SYS_ERR = 7,
  PRE_STOP_SUCCESS = 8
};
bool PRACTICE_RESULT_E_IsValid(int value);
const PRACTICE_RESULT_E PRACTICE_RESULT_E_MIN = PRE_SUCCESS;
const PRACTICE_RESULT_E PRACTICE_RESULT_E_MAX = PRE_STOP_SUCCESS;
const int PRACTICE_RESULT_E_ARRAYSIZE = PRACTICE_RESULT_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* PRACTICE_RESULT_E_descriptor();
inline const ::std::string& PRACTICE_RESULT_E_Name(PRACTICE_RESULT_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    PRACTICE_RESULT_E_descriptor(), value);
}
inline bool PRACTICE_RESULT_E_Parse(
    const ::std::string& name, PRACTICE_RESULT_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PRACTICE_RESULT_E>(
    PRACTICE_RESULT_E_descriptor(), name, value);
}
// ===================================================================

class practice_req : public ::google::protobuf::Message {
 public:
  practice_req();
  virtual ~practice_req();

  practice_req(const practice_req& from);

  inline practice_req& operator=(const practice_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const practice_req& default_instance();

  void Swap(practice_req* other);

  // implements Message ----------------------------------------------

  practice_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const practice_req& from);
  void MergeFrom(const practice_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.practice_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static practice_req* default_instance_;
};
// -------------------------------------------------------------------

class practice_rsp : public ::google::protobuf::Message {
 public:
  practice_rsp();
  virtual ~practice_rsp();

  practice_rsp(const practice_rsp& from);

  inline practice_rsp& operator=(const practice_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const practice_rsp& default_instance();

  void Swap(practice_rsp* other);

  // implements Message ----------------------------------------------

  practice_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const practice_rsp& from);
  void MergeFrom(const practice_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.PRACTICE_RESULT_E ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::PRACTICE_RESULT_E ret() const;
  inline void set_ret(::client::PRACTICE_RESULT_E value);

  // @@protoc_insertion_point(class_scope:client.practice_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static practice_rsp* default_instance_;
};
// -------------------------------------------------------------------

class comm_practice_req : public ::google::protobuf::Message {
 public:
  comm_practice_req();
  virtual ~comm_practice_req();

  comm_practice_req(const comm_practice_req& from);

  inline comm_practice_req& operator=(const comm_practice_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comm_practice_req& default_instance();

  void Swap(comm_practice_req* other);

  // implements Message ----------------------------------------------

  comm_practice_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comm_practice_req& from);
  void MergeFrom(const comm_practice_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_data dst_rd = 1;
  inline bool has_dst_rd() const;
  inline void clear_dst_rd();
  static const int kDstRdFieldNumber = 1;
  inline const ::client::role_data& dst_rd() const;
  inline ::client::role_data* mutable_dst_rd();
  inline ::client::role_data* release_dst_rd();
  inline void set_allocated_dst_rd(::client::role_data* dst_rd);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.comm_practice_req)
 private:
  inline void set_has_dst_rd();
  inline void clear_has_dst_rd();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_data* dst_rd_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static comm_practice_req* default_instance_;
};
// -------------------------------------------------------------------

class comm_practice_rsp : public ::google::protobuf::Message {
 public:
  comm_practice_rsp();
  virtual ~comm_practice_rsp();

  comm_practice_rsp(const comm_practice_rsp& from);

  inline comm_practice_rsp& operator=(const comm_practice_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comm_practice_rsp& default_instance();

  void Swap(comm_practice_rsp* other);

  // implements Message ----------------------------------------------

  comm_practice_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comm_practice_rsp& from);
  void MergeFrom(const comm_practice_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.PRACTICE_RESULT_E ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::PRACTICE_RESULT_E ret() const;
  inline void set_ret(::client::PRACTICE_RESULT_E value);

  // @@protoc_insertion_point(class_scope:client.comm_practice_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static comm_practice_rsp* default_instance_;
};
// -------------------------------------------------------------------

class comm_practice_list_req : public ::google::protobuf::Message {
 public:
  comm_practice_list_req();
  virtual ~comm_practice_list_req();

  comm_practice_list_req(const comm_practice_list_req& from);

  inline comm_practice_list_req& operator=(const comm_practice_list_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comm_practice_list_req& default_instance();

  void Swap(comm_practice_list_req* other);

  // implements Message ----------------------------------------------

  comm_practice_list_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comm_practice_list_req& from);
  void MergeFrom(const comm_practice_list_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.comm_practice_list_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static comm_practice_list_req* default_instance_;
};
// -------------------------------------------------------------------

class comm_practice_info : public ::google::protobuf::Message {
 public:
  comm_practice_info();
  virtual ~comm_practice_info();

  comm_practice_info(const comm_practice_info& from);

  inline comm_practice_info& operator=(const comm_practice_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comm_practice_info& default_instance();

  void Swap(comm_practice_info* other);

  // implements Message ----------------------------------------------

  comm_practice_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comm_practice_info& from);
  void MergeFrom(const comm_practice_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_name rn = 1;
  inline bool has_rn() const;
  inline void clear_rn();
  static const int kRnFieldNumber = 1;
  inline const ::client::role_name& rn() const;
  inline ::client::role_name* mutable_rn();
  inline ::client::role_name* release_rn();
  inline void set_allocated_rn(::client::role_name* rn);

  // required uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required .client.client_map_pos pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline const ::client::client_map_pos& pos() const;
  inline ::client::client_map_pos* mutable_pos();
  inline ::client::client_map_pos* release_pos();
  inline void set_allocated_pos(::client::client_map_pos* pos);

  // @@protoc_insertion_point(class_scope:client.comm_practice_info)
 private:
  inline void set_has_rn();
  inline void clear_has_rn();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_name* rn_;
  ::client::client_map_pos* pos_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static comm_practice_info* default_instance_;
};
// -------------------------------------------------------------------

class comm_practice_list_rsp : public ::google::protobuf::Message {
 public:
  comm_practice_list_rsp();
  virtual ~comm_practice_list_rsp();

  comm_practice_list_rsp(const comm_practice_list_rsp& from);

  inline comm_practice_list_rsp& operator=(const comm_practice_list_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comm_practice_list_rsp& default_instance();

  void Swap(comm_practice_list_rsp* other);

  // implements Message ----------------------------------------------

  comm_practice_list_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comm_practice_list_rsp& from);
  void MergeFrom(const comm_practice_list_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.comm_practice_info cpi = 1;
  inline int cpi_size() const;
  inline void clear_cpi();
  static const int kCpiFieldNumber = 1;
  inline const ::client::comm_practice_info& cpi(int index) const;
  inline ::client::comm_practice_info* mutable_cpi(int index);
  inline ::client::comm_practice_info* add_cpi();
  inline const ::google::protobuf::RepeatedPtrField< ::client::comm_practice_info >&
      cpi() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::comm_practice_info >*
      mutable_cpi();

  // @@protoc_insertion_point(class_scope:client.comm_practice_list_rsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::comm_practice_info > cpi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static comm_practice_list_rsp* default_instance_;
};
// -------------------------------------------------------------------

class comm_practice_invite : public ::google::protobuf::Message {
 public:
  comm_practice_invite();
  virtual ~comm_practice_invite();

  comm_practice_invite(const comm_practice_invite& from);

  inline comm_practice_invite& operator=(const comm_practice_invite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comm_practice_invite& default_instance();

  void Swap(comm_practice_invite* other);

  // implements Message ----------------------------------------------

  comm_practice_invite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comm_practice_invite& from);
  void MergeFrom(const comm_practice_invite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.comm_practice_info cpi = 1;
  inline bool has_cpi() const;
  inline void clear_cpi();
  static const int kCpiFieldNumber = 1;
  inline const ::client::comm_practice_info& cpi() const;
  inline ::client::comm_practice_info* mutable_cpi();
  inline ::client::comm_practice_info* release_cpi();
  inline void set_allocated_cpi(::client::comm_practice_info* cpi);

  // @@protoc_insertion_point(class_scope:client.comm_practice_invite)
 private:
  inline void set_has_cpi();
  inline void clear_has_cpi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::comm_practice_info* cpi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static comm_practice_invite* default_instance_;
};
// -------------------------------------------------------------------

class comm_practice_invite_result : public ::google::protobuf::Message {
 public:
  comm_practice_invite_result();
  virtual ~comm_practice_invite_result();

  comm_practice_invite_result(const comm_practice_invite_result& from);

  inline comm_practice_invite_result& operator=(const comm_practice_invite_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comm_practice_invite_result& default_instance();

  void Swap(comm_practice_invite_result* other);

  // implements Message ----------------------------------------------

  comm_practice_invite_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comm_practice_invite_result& from);
  void MergeFrom(const comm_practice_invite_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.comm_practice_info cpi = 1;
  inline bool has_cpi() const;
  inline void clear_cpi();
  static const int kCpiFieldNumber = 1;
  inline const ::client::comm_practice_info& cpi() const;
  inline ::client::comm_practice_info* mutable_cpi();
  inline ::client::comm_practice_info* release_cpi();
  inline void set_allocated_cpi(::client::comm_practice_info* cpi);

  // required bool agree = 2;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 2;
  inline bool agree() const;
  inline void set_agree(bool value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.comm_practice_invite_result)
 private:
  inline void set_has_cpi();
  inline void clear_has_cpi();
  inline void set_has_agree();
  inline void clear_has_agree();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::comm_practice_info* cpi_;
  ::client::server_head* svr_head_;
  bool agree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static comm_practice_invite_result* default_instance_;
};
// -------------------------------------------------------------------

class auto_agree_comm_practice : public ::google::protobuf::Message {
 public:
  auto_agree_comm_practice();
  virtual ~auto_agree_comm_practice();

  auto_agree_comm_practice(const auto_agree_comm_practice& from);

  inline auto_agree_comm_practice& operator=(const auto_agree_comm_practice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auto_agree_comm_practice& default_instance();

  void Swap(auto_agree_comm_practice* other);

  // implements Message ----------------------------------------------

  auto_agree_comm_practice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const auto_agree_comm_practice& from);
  void MergeFrom(const auto_agree_comm_practice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool auto_agree = 1;
  inline bool has_auto_agree() const;
  inline void clear_auto_agree();
  static const int kAutoAgreeFieldNumber = 1;
  inline bool auto_agree() const;
  inline void set_auto_agree(bool value);

  // optional bool get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline bool get() const;
  inline void set_get(bool value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.auto_agree_comm_practice)
 private:
  inline void set_has_auto_agree();
  inline void clear_has_auto_agree();
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  bool auto_agree_;
  bool get_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static auto_agree_comm_practice* default_instance_;
};
// -------------------------------------------------------------------

class stop_comm_practice_req : public ::google::protobuf::Message {
 public:
  stop_comm_practice_req();
  virtual ~stop_comm_practice_req();

  stop_comm_practice_req(const stop_comm_practice_req& from);

  inline stop_comm_practice_req& operator=(const stop_comm_practice_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stop_comm_practice_req& default_instance();

  void Swap(stop_comm_practice_req* other);

  // implements Message ----------------------------------------------

  stop_comm_practice_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stop_comm_practice_req& from);
  void MergeFrom(const stop_comm_practice_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.stop_comm_practice_req)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2epractice_2eproto();
  friend void protobuf_AssignDesc_client_2epractice_2eproto();
  friend void protobuf_ShutdownFile_client_2epractice_2eproto();

  void InitAsDefaultInstance();
  static stop_comm_practice_req* default_instance_;
};
// ===================================================================


// ===================================================================

// practice_req

// required uint32 time = 1;
inline bool practice_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void practice_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void practice_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void practice_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 practice_req::time() const {
  return time_;
}
inline void practice_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool practice_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void practice_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void practice_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void practice_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& practice_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* practice_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* practice_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void practice_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// practice_rsp

// required .client.PRACTICE_RESULT_E ret = 1;
inline bool practice_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void practice_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void practice_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void practice_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::PRACTICE_RESULT_E practice_rsp::ret() const {
  return static_cast< ::client::PRACTICE_RESULT_E >(ret_);
}
inline void practice_rsp::set_ret(::client::PRACTICE_RESULT_E value) {
  assert(::client::PRACTICE_RESULT_E_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// comm_practice_req

// required .client.role_data dst_rd = 1;
inline bool comm_practice_req::has_dst_rd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comm_practice_req::set_has_dst_rd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comm_practice_req::clear_has_dst_rd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comm_practice_req::clear_dst_rd() {
  if (dst_rd_ != NULL) dst_rd_->::client::role_data::Clear();
  clear_has_dst_rd();
}
inline const ::client::role_data& comm_practice_req::dst_rd() const {
  return dst_rd_ != NULL ? *dst_rd_ : *default_instance_->dst_rd_;
}
inline ::client::role_data* comm_practice_req::mutable_dst_rd() {
  set_has_dst_rd();
  if (dst_rd_ == NULL) dst_rd_ = new ::client::role_data;
  return dst_rd_;
}
inline ::client::role_data* comm_practice_req::release_dst_rd() {
  clear_has_dst_rd();
  ::client::role_data* temp = dst_rd_;
  dst_rd_ = NULL;
  return temp;
}
inline void comm_practice_req::set_allocated_dst_rd(::client::role_data* dst_rd) {
  delete dst_rd_;
  dst_rd_ = dst_rd;
  if (dst_rd) {
    set_has_dst_rd();
  } else {
    clear_has_dst_rd();
  }
}

// optional .client.server_head svr_head = 1000;
inline bool comm_practice_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void comm_practice_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void comm_practice_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void comm_practice_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& comm_practice_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* comm_practice_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* comm_practice_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void comm_practice_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// comm_practice_rsp

// required .client.PRACTICE_RESULT_E ret = 1;
inline bool comm_practice_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comm_practice_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comm_practice_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comm_practice_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::PRACTICE_RESULT_E comm_practice_rsp::ret() const {
  return static_cast< ::client::PRACTICE_RESULT_E >(ret_);
}
inline void comm_practice_rsp::set_ret(::client::PRACTICE_RESULT_E value) {
  assert(::client::PRACTICE_RESULT_E_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// comm_practice_list_req

// required uint32 time = 1;
inline bool comm_practice_list_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comm_practice_list_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comm_practice_list_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comm_practice_list_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 comm_practice_list_req::time() const {
  return time_;
}
inline void comm_practice_list_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool comm_practice_list_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void comm_practice_list_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void comm_practice_list_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void comm_practice_list_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& comm_practice_list_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* comm_practice_list_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* comm_practice_list_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void comm_practice_list_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// comm_practice_info

// required .client.role_name rn = 1;
inline bool comm_practice_info::has_rn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comm_practice_info::set_has_rn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comm_practice_info::clear_has_rn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comm_practice_info::clear_rn() {
  if (rn_ != NULL) rn_->::client::role_name::Clear();
  clear_has_rn();
}
inline const ::client::role_name& comm_practice_info::rn() const {
  return rn_ != NULL ? *rn_ : *default_instance_->rn_;
}
inline ::client::role_name* comm_practice_info::mutable_rn() {
  set_has_rn();
  if (rn_ == NULL) rn_ = new ::client::role_name;
  return rn_;
}
inline ::client::role_name* comm_practice_info::release_rn() {
  clear_has_rn();
  ::client::role_name* temp = rn_;
  rn_ = NULL;
  return temp;
}
inline void comm_practice_info::set_allocated_rn(::client::role_name* rn) {
  delete rn_;
  rn_ = rn;
  if (rn) {
    set_has_rn();
  } else {
    clear_has_rn();
  }
}

// required uint32 level = 2;
inline bool comm_practice_info::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void comm_practice_info::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void comm_practice_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void comm_practice_info::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 comm_practice_info::level() const {
  return level_;
}
inline void comm_practice_info::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required .client.client_map_pos pos = 3;
inline bool comm_practice_info::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void comm_practice_info::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void comm_practice_info::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void comm_practice_info::clear_pos() {
  if (pos_ != NULL) pos_->::client::client_map_pos::Clear();
  clear_has_pos();
}
inline const ::client::client_map_pos& comm_practice_info::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::client::client_map_pos* comm_practice_info::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::client::client_map_pos;
  return pos_;
}
inline ::client::client_map_pos* comm_practice_info::release_pos() {
  clear_has_pos();
  ::client::client_map_pos* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void comm_practice_info::set_allocated_pos(::client::client_map_pos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// -------------------------------------------------------------------

// comm_practice_list_rsp

// repeated .client.comm_practice_info cpi = 1;
inline int comm_practice_list_rsp::cpi_size() const {
  return cpi_.size();
}
inline void comm_practice_list_rsp::clear_cpi() {
  cpi_.Clear();
}
inline const ::client::comm_practice_info& comm_practice_list_rsp::cpi(int index) const {
  return cpi_.Get(index);
}
inline ::client::comm_practice_info* comm_practice_list_rsp::mutable_cpi(int index) {
  return cpi_.Mutable(index);
}
inline ::client::comm_practice_info* comm_practice_list_rsp::add_cpi() {
  return cpi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::comm_practice_info >&
comm_practice_list_rsp::cpi() const {
  return cpi_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::comm_practice_info >*
comm_practice_list_rsp::mutable_cpi() {
  return &cpi_;
}

// -------------------------------------------------------------------

// comm_practice_invite

// required .client.comm_practice_info cpi = 1;
inline bool comm_practice_invite::has_cpi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comm_practice_invite::set_has_cpi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comm_practice_invite::clear_has_cpi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comm_practice_invite::clear_cpi() {
  if (cpi_ != NULL) cpi_->::client::comm_practice_info::Clear();
  clear_has_cpi();
}
inline const ::client::comm_practice_info& comm_practice_invite::cpi() const {
  return cpi_ != NULL ? *cpi_ : *default_instance_->cpi_;
}
inline ::client::comm_practice_info* comm_practice_invite::mutable_cpi() {
  set_has_cpi();
  if (cpi_ == NULL) cpi_ = new ::client::comm_practice_info;
  return cpi_;
}
inline ::client::comm_practice_info* comm_practice_invite::release_cpi() {
  clear_has_cpi();
  ::client::comm_practice_info* temp = cpi_;
  cpi_ = NULL;
  return temp;
}
inline void comm_practice_invite::set_allocated_cpi(::client::comm_practice_info* cpi) {
  delete cpi_;
  cpi_ = cpi;
  if (cpi) {
    set_has_cpi();
  } else {
    clear_has_cpi();
  }
}

// -------------------------------------------------------------------

// comm_practice_invite_result

// required .client.comm_practice_info cpi = 1;
inline bool comm_practice_invite_result::has_cpi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comm_practice_invite_result::set_has_cpi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comm_practice_invite_result::clear_has_cpi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comm_practice_invite_result::clear_cpi() {
  if (cpi_ != NULL) cpi_->::client::comm_practice_info::Clear();
  clear_has_cpi();
}
inline const ::client::comm_practice_info& comm_practice_invite_result::cpi() const {
  return cpi_ != NULL ? *cpi_ : *default_instance_->cpi_;
}
inline ::client::comm_practice_info* comm_practice_invite_result::mutable_cpi() {
  set_has_cpi();
  if (cpi_ == NULL) cpi_ = new ::client::comm_practice_info;
  return cpi_;
}
inline ::client::comm_practice_info* comm_practice_invite_result::release_cpi() {
  clear_has_cpi();
  ::client::comm_practice_info* temp = cpi_;
  cpi_ = NULL;
  return temp;
}
inline void comm_practice_invite_result::set_allocated_cpi(::client::comm_practice_info* cpi) {
  delete cpi_;
  cpi_ = cpi;
  if (cpi) {
    set_has_cpi();
  } else {
    clear_has_cpi();
  }
}

// required bool agree = 2;
inline bool comm_practice_invite_result::has_agree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void comm_practice_invite_result::set_has_agree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void comm_practice_invite_result::clear_has_agree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void comm_practice_invite_result::clear_agree() {
  agree_ = false;
  clear_has_agree();
}
inline bool comm_practice_invite_result::agree() const {
  return agree_;
}
inline void comm_practice_invite_result::set_agree(bool value) {
  set_has_agree();
  agree_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool comm_practice_invite_result::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void comm_practice_invite_result::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void comm_practice_invite_result::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void comm_practice_invite_result::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& comm_practice_invite_result::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* comm_practice_invite_result::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* comm_practice_invite_result::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void comm_practice_invite_result::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// auto_agree_comm_practice

// required bool auto_agree = 1;
inline bool auto_agree_comm_practice::has_auto_agree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auto_agree_comm_practice::set_has_auto_agree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auto_agree_comm_practice::clear_has_auto_agree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auto_agree_comm_practice::clear_auto_agree() {
  auto_agree_ = false;
  clear_has_auto_agree();
}
inline bool auto_agree_comm_practice::auto_agree() const {
  return auto_agree_;
}
inline void auto_agree_comm_practice::set_auto_agree(bool value) {
  set_has_auto_agree();
  auto_agree_ = value;
}

// optional bool get = 2;
inline bool auto_agree_comm_practice::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auto_agree_comm_practice::set_has_get() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auto_agree_comm_practice::clear_has_get() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auto_agree_comm_practice::clear_get() {
  get_ = false;
  clear_has_get();
}
inline bool auto_agree_comm_practice::get() const {
  return get_;
}
inline void auto_agree_comm_practice::set_get(bool value) {
  set_has_get();
  get_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool auto_agree_comm_practice::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auto_agree_comm_practice::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auto_agree_comm_practice::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auto_agree_comm_practice::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& auto_agree_comm_practice::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* auto_agree_comm_practice::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* auto_agree_comm_practice::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void auto_agree_comm_practice::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// stop_comm_practice_req

// required uint32 unixtime = 1;
inline bool stop_comm_practice_req::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stop_comm_practice_req::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stop_comm_practice_req::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stop_comm_practice_req::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 stop_comm_practice_req::unixtime() const {
  return unixtime_;
}
inline void stop_comm_practice_req::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool stop_comm_practice_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stop_comm_practice_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stop_comm_practice_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stop_comm_practice_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& stop_comm_practice_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* stop_comm_practice_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* stop_comm_practice_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void stop_comm_practice_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::PRACTICE_RESULT_E>() {
  return ::client::PRACTICE_RESULT_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2epractice_2eproto__INCLUDED
