// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.task.proto

#ifndef PROTOBUF_client_2etask_2eproto__INCLUDED
#define PROTOBUF_client_2etask_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2etask_2eproto();
void protobuf_AssignDesc_client_2etask_2eproto();
void protobuf_ShutdownFile_client_2etask_2eproto();

class ctrl_scene_req;
class ctrl_scene_rsp;
class task_talk;
class task_raid;
class task_pick;
class task_kill;
class task_guard;
class task_level;
class task_event;
class task_progress;
class task_accepted;
class task_completed;
class task_msg;
class accept_task_req;
class accept_task_rsp;
class submit_task_req;
class submit_task_rsp;
class talk_task_req;
class talk_task_rsp;
class story_end_req;

enum ctrl_scene_req_ctrl_type {
  ctrl_scene_req_ctrl_type_suspend = 1,
  ctrl_scene_req_ctrl_type_resume = 2
};
bool ctrl_scene_req_ctrl_type_IsValid(int value);
const ctrl_scene_req_ctrl_type ctrl_scene_req_ctrl_type_ctrl_type_MIN = ctrl_scene_req_ctrl_type_suspend;
const ctrl_scene_req_ctrl_type ctrl_scene_req_ctrl_type_ctrl_type_MAX = ctrl_scene_req_ctrl_type_resume;
const int ctrl_scene_req_ctrl_type_ctrl_type_ARRAYSIZE = ctrl_scene_req_ctrl_type_ctrl_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ctrl_scene_req_ctrl_type_descriptor();
inline const ::std::string& ctrl_scene_req_ctrl_type_Name(ctrl_scene_req_ctrl_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ctrl_scene_req_ctrl_type_descriptor(), value);
}
inline bool ctrl_scene_req_ctrl_type_Parse(
    const ::std::string& name, ctrl_scene_req_ctrl_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ctrl_scene_req_ctrl_type>(
    ctrl_scene_req_ctrl_type_descriptor(), name, value);
}
enum task_msg_type {
  task_msg_type_insert = 1,
  task_msg_type_remove = 2,
  task_msg_type_update = 3
};
bool task_msg_type_IsValid(int value);
const task_msg_type task_msg_type_type_MIN = task_msg_type_insert;
const task_msg_type task_msg_type_type_MAX = task_msg_type_update;
const int task_msg_type_type_ARRAYSIZE = task_msg_type_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* task_msg_type_descriptor();
inline const ::std::string& task_msg_type_Name(task_msg_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    task_msg_type_descriptor(), value);
}
inline bool task_msg_type_Parse(
    const ::std::string& name, task_msg_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<task_msg_type>(
    task_msg_type_descriptor(), name, value);
}
enum TASK_RESULT {
  TR_SUCCESS = 0,
  TR_LIMIT_CONDITION = 1,
  TR_LIMIT_ACCEPETD = 2,
  TR_LIMIT_NPC = 3,
  TR_TASK_ERROR = 4
};
bool TASK_RESULT_IsValid(int value);
const TASK_RESULT TASK_RESULT_MIN = TR_SUCCESS;
const TASK_RESULT TASK_RESULT_MAX = TR_TASK_ERROR;
const int TASK_RESULT_ARRAYSIZE = TASK_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* TASK_RESULT_descriptor();
inline const ::std::string& TASK_RESULT_Name(TASK_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    TASK_RESULT_descriptor(), value);
}
inline bool TASK_RESULT_Parse(
    const ::std::string& name, TASK_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TASK_RESULT>(
    TASK_RESULT_descriptor(), name, value);
}
// ===================================================================

class ctrl_scene_req : public ::google::protobuf::Message {
 public:
  ctrl_scene_req();
  virtual ~ctrl_scene_req();

  ctrl_scene_req(const ctrl_scene_req& from);

  inline ctrl_scene_req& operator=(const ctrl_scene_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ctrl_scene_req& default_instance();

  void Swap(ctrl_scene_req* other);

  // implements Message ----------------------------------------------

  ctrl_scene_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ctrl_scene_req& from);
  void MergeFrom(const ctrl_scene_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ctrl_scene_req_ctrl_type ctrl_type;
  static const ctrl_type suspend = ctrl_scene_req_ctrl_type_suspend;
  static const ctrl_type resume = ctrl_scene_req_ctrl_type_resume;
  static inline bool ctrl_type_IsValid(int value) {
    return ctrl_scene_req_ctrl_type_IsValid(value);
  }
  static const ctrl_type ctrl_type_MIN =
    ctrl_scene_req_ctrl_type_ctrl_type_MIN;
  static const ctrl_type ctrl_type_MAX =
    ctrl_scene_req_ctrl_type_ctrl_type_MAX;
  static const int ctrl_type_ARRAYSIZE =
    ctrl_scene_req_ctrl_type_ctrl_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ctrl_type_descriptor() {
    return ctrl_scene_req_ctrl_type_descriptor();
  }
  static inline const ::std::string& ctrl_type_Name(ctrl_type value) {
    return ctrl_scene_req_ctrl_type_Name(value);
  }
  static inline bool ctrl_type_Parse(const ::std::string& name,
      ctrl_type* value) {
    return ctrl_scene_req_ctrl_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.ctrl_scene_req.ctrl_type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::client::ctrl_scene_req_ctrl_type type() const;
  inline void set_type(::client::ctrl_scene_req_ctrl_type value);

  // optional uint32 unixtime = 2;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 2;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.ctrl_scene_req)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_unixtime();
  inline void clear_has_unixtime();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 unixtime_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static ctrl_scene_req* default_instance_;
};
// -------------------------------------------------------------------

class ctrl_scene_rsp : public ::google::protobuf::Message {
 public:
  ctrl_scene_rsp();
  virtual ~ctrl_scene_rsp();

  ctrl_scene_rsp(const ctrl_scene_rsp& from);

  inline ctrl_scene_rsp& operator=(const ctrl_scene_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ctrl_scene_rsp& default_instance();

  void Swap(ctrl_scene_rsp* other);

  // implements Message ----------------------------------------------

  ctrl_scene_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ctrl_scene_rsp& from);
  void MergeFrom(const ctrl_scene_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required .client.ctrl_scene_req req = 2;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 2;
  inline const ::client::ctrl_scene_req& req() const;
  inline ::client::ctrl_scene_req* mutable_req();
  inline ::client::ctrl_scene_req* release_req();
  inline void set_allocated_req(::client::ctrl_scene_req* req);

  // @@protoc_insertion_point(class_scope:client.ctrl_scene_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::ctrl_scene_req* req_;
  ::google::protobuf::uint32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static ctrl_scene_rsp* default_instance_;
};
// -------------------------------------------------------------------

class task_talk : public ::google::protobuf::Message {
 public:
  task_talk();
  virtual ~task_talk();

  task_talk(const task_talk& from);

  inline task_talk& operator=(const task_talk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_talk& default_instance();

  void Swap(task_talk* other);

  // implements Message ----------------------------------------------

  task_talk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_talk& from);
  void MergeFrom(const task_talk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 npc_id = 1;
  inline bool has_npc_id() const;
  inline void clear_npc_id();
  static const int kNpcIdFieldNumber = 1;
  inline ::google::protobuf::uint32 npc_id() const;
  inline void set_npc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_talk)
 private:
  inline void set_has_npc_id();
  inline void clear_has_npc_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 npc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_talk* default_instance_;
};
// -------------------------------------------------------------------

class task_raid : public ::google::protobuf::Message {
 public:
  task_raid();
  virtual ~task_raid();

  task_raid(const task_raid& from);

  inline task_raid& operator=(const task_raid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_raid& default_instance();

  void Swap(task_raid* other);

  // implements Message ----------------------------------------------

  task_raid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_raid& from);
  void MergeFrom(const task_raid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 raid_id = 1;
  inline bool has_raid_id() const;
  inline void clear_raid_id();
  static const int kRaidIdFieldNumber = 1;
  inline ::google::protobuf::uint32 raid_id() const;
  inline void set_raid_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_raid)
 private:
  inline void set_has_raid_id();
  inline void clear_has_raid_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 raid_id_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_raid* default_instance_;
};
// -------------------------------------------------------------------

class task_pick : public ::google::protobuf::Message {
 public:
  task_pick();
  virtual ~task_pick();

  task_pick(const task_pick& from);

  inline task_pick& operator=(const task_pick& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_pick& default_instance();

  void Swap(task_pick* other);

  // implements Message ----------------------------------------------

  task_pick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_pick& from);
  void MergeFrom(const task_pick& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_pick)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_pick* default_instance_;
};
// -------------------------------------------------------------------

class task_kill : public ::google::protobuf::Message {
 public:
  task_kill();
  virtual ~task_kill();

  task_kill(const task_kill& from);

  inline task_kill& operator=(const task_kill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_kill& default_instance();

  void Swap(task_kill* other);

  // implements Message ----------------------------------------------

  task_kill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_kill& from);
  void MergeFrom(const task_kill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_kill)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_kill* default_instance_;
};
// -------------------------------------------------------------------

class task_guard : public ::google::protobuf::Message {
 public:
  task_guard();
  virtual ~task_guard();

  task_guard(const task_guard& from);

  inline task_guard& operator=(const task_guard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_guard& default_instance();

  void Swap(task_guard* other);

  // implements Message ----------------------------------------------

  task_guard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_guard& from);
  void MergeFrom(const task_guard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_guard)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_guard* default_instance_;
};
// -------------------------------------------------------------------

class task_level : public ::google::protobuf::Message {
 public:
  task_level();
  virtual ~task_level();

  task_level(const task_level& from);

  inline task_level& operator=(const task_level& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_level& default_instance();

  void Swap(task_level* other);

  // implements Message ----------------------------------------------

  task_level* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_level& from);
  void MergeFrom(const task_level& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_level)
 private:
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_level* default_instance_;
};
// -------------------------------------------------------------------

class task_event : public ::google::protobuf::Message {
 public:
  task_event();
  virtual ~task_event();

  task_event(const task_event& from);

  inline task_event& operator=(const task_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_event& default_instance();

  void Swap(task_event* other);

  // implements Message ----------------------------------------------

  task_event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_event& from);
  void MergeFrom(const task_event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_event)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_event* default_instance_;
};
// -------------------------------------------------------------------

class task_progress : public ::google::protobuf::Message {
 public:
  task_progress();
  virtual ~task_progress();

  task_progress(const task_progress& from);

  inline task_progress& operator=(const task_progress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_progress& default_instance();

  void Swap(task_progress* other);

  // implements Message ----------------------------------------------

  task_progress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_progress& from);
  void MergeFrom(const task_progress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.task_talk talk = 1;
  inline int talk_size() const;
  inline void clear_talk();
  static const int kTalkFieldNumber = 1;
  inline const ::client::task_talk& talk(int index) const;
  inline ::client::task_talk* mutable_talk(int index);
  inline ::client::task_talk* add_talk();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_talk >&
      talk() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_talk >*
      mutable_talk();

  // repeated .client.task_raid raid = 2;
  inline int raid_size() const;
  inline void clear_raid();
  static const int kRaidFieldNumber = 2;
  inline const ::client::task_raid& raid(int index) const;
  inline ::client::task_raid* mutable_raid(int index);
  inline ::client::task_raid* add_raid();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_raid >&
      raid() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_raid >*
      mutable_raid();

  // repeated .client.task_pick pick = 3;
  inline int pick_size() const;
  inline void clear_pick();
  static const int kPickFieldNumber = 3;
  inline const ::client::task_pick& pick(int index) const;
  inline ::client::task_pick* mutable_pick(int index);
  inline ::client::task_pick* add_pick();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_pick >&
      pick() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_pick >*
      mutable_pick();

  // repeated .client.task_kill kill = 4;
  inline int kill_size() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 4;
  inline const ::client::task_kill& kill(int index) const;
  inline ::client::task_kill* mutable_kill(int index);
  inline ::client::task_kill* add_kill();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_kill >&
      kill() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_kill >*
      mutable_kill();

  // repeated .client.task_guard guard = 5;
  inline int guard_size() const;
  inline void clear_guard();
  static const int kGuardFieldNumber = 5;
  inline const ::client::task_guard& guard(int index) const;
  inline ::client::task_guard* mutable_guard(int index);
  inline ::client::task_guard* add_guard();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_guard >&
      guard() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_guard >*
      mutable_guard();

  // repeated .client.task_level level = 6;
  inline int level_size() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline const ::client::task_level& level(int index) const;
  inline ::client::task_level* mutable_level(int index);
  inline ::client::task_level* add_level();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_level >&
      level() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_level >*
      mutable_level();

  // repeated .client.task_event event = 7;
  inline int event_size() const;
  inline void clear_event();
  static const int kEventFieldNumber = 7;
  inline const ::client::task_event& event(int index) const;
  inline ::client::task_event* mutable_event(int index);
  inline ::client::task_event* add_event();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_event >&
      event() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_event >*
      mutable_event();

  // @@protoc_insertion_point(class_scope:client.task_progress)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::task_talk > talk_;
  ::google::protobuf::RepeatedPtrField< ::client::task_raid > raid_;
  ::google::protobuf::RepeatedPtrField< ::client::task_pick > pick_;
  ::google::protobuf::RepeatedPtrField< ::client::task_kill > kill_;
  ::google::protobuf::RepeatedPtrField< ::client::task_guard > guard_;
  ::google::protobuf::RepeatedPtrField< ::client::task_level > level_;
  ::google::protobuf::RepeatedPtrField< ::client::task_event > event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_progress* default_instance_;
};
// -------------------------------------------------------------------

class task_accepted : public ::google::protobuf::Message {
 public:
  task_accepted();
  virtual ~task_accepted();

  task_accepted(const task_accepted& from);

  inline task_accepted& operator=(const task_accepted& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_accepted& default_instance();

  void Swap(task_accepted* other);

  // implements Message ----------------------------------------------

  task_accepted* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_accepted& from);
  void MergeFrom(const task_accepted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_id = 1 [default = 0];
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // required .client.task_progress progress = 2;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 2;
  inline const ::client::task_progress& progress() const;
  inline ::client::task_progress* mutable_progress();
  inline ::client::task_progress* release_progress();
  inline void set_allocated_progress(::client::task_progress* progress);

  // @@protoc_insertion_point(class_scope:client.task_accepted)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_progress();
  inline void clear_has_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::task_progress* progress_;
  ::google::protobuf::uint32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_accepted* default_instance_;
};
// -------------------------------------------------------------------

class task_completed : public ::google::protobuf::Message {
 public:
  task_completed();
  virtual ~task_completed();

  task_completed(const task_completed& from);

  inline task_completed& operator=(const task_completed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_completed& default_instance();

  void Swap(task_completed* other);

  // implements Message ----------------------------------------------

  task_completed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_completed& from);
  void MergeFrom(const task_completed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_id = 1 [default = 0];
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // required uint32 count = 2 [default = 0];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 time = 3 [default = 0];
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_completed)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_completed* default_instance_;
};
// -------------------------------------------------------------------

class task_msg : public ::google::protobuf::Message {
 public:
  task_msg();
  virtual ~task_msg();

  task_msg(const task_msg& from);

  inline task_msg& operator=(const task_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_msg& default_instance();

  void Swap(task_msg* other);

  // implements Message ----------------------------------------------

  task_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_msg& from);
  void MergeFrom(const task_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef task_msg_type type;
  static const type insert = task_msg_type_insert;
  static const type remove = task_msg_type_remove;
  static const type update = task_msg_type_update;
  static inline bool type_IsValid(int value) {
    return task_msg_type_IsValid(value);
  }
  static const type type_MIN =
    task_msg_type_type_MIN;
  static const type type_MAX =
    task_msg_type_type_MAX;
  static const int type_ARRAYSIZE =
    task_msg_type_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  type_descriptor() {
    return task_msg_type_descriptor();
  }
  static inline const ::std::string& type_Name(type value) {
    return task_msg_type_Name(value);
  }
  static inline bool type_Parse(const ::std::string& name,
      type* value) {
    return task_msg_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.task_msg.type t = 1;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 1;
  inline ::client::task_msg_type t() const;
  inline void set_t(::client::task_msg_type value);

  // repeated .client.task_accepted accepted = 2;
  inline int accepted_size() const;
  inline void clear_accepted();
  static const int kAcceptedFieldNumber = 2;
  inline const ::client::task_accepted& accepted(int index) const;
  inline ::client::task_accepted* mutable_accepted(int index);
  inline ::client::task_accepted* add_accepted();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_accepted >&
      accepted() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_accepted >*
      mutable_accepted();

  // repeated .client.task_completed completed = 3;
  inline int completed_size() const;
  inline void clear_completed();
  static const int kCompletedFieldNumber = 3;
  inline const ::client::task_completed& completed(int index) const;
  inline ::client::task_completed* mutable_completed(int index);
  inline ::client::task_completed* add_completed();
  inline const ::google::protobuf::RepeatedPtrField< ::client::task_completed >&
      completed() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::task_completed >*
      mutable_completed();

  // optional uint32 task_flag = 4;
  inline bool has_task_flag() const;
  inline void clear_task_flag();
  static const int kTaskFlagFieldNumber = 4;
  inline ::google::protobuf::uint32 task_flag() const;
  inline void set_task_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.task_msg)
 private:
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_task_flag();
  inline void clear_has_task_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::task_accepted > accepted_;
  int t_;
  ::google::protobuf::uint32 task_flag_;
  ::google::protobuf::RepeatedPtrField< ::client::task_completed > completed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static task_msg* default_instance_;
};
// -------------------------------------------------------------------

class accept_task_req : public ::google::protobuf::Message {
 public:
  accept_task_req();
  virtual ~accept_task_req();

  accept_task_req(const accept_task_req& from);

  inline accept_task_req& operator=(const accept_task_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const accept_task_req& default_instance();

  void Swap(accept_task_req* other);

  // implements Message ----------------------------------------------

  accept_task_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const accept_task_req& from);
  void MergeFrom(const accept_task_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.accept_task_req)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static accept_task_req* default_instance_;
};
// -------------------------------------------------------------------

class accept_task_rsp : public ::google::protobuf::Message {
 public:
  accept_task_rsp();
  virtual ~accept_task_rsp();

  accept_task_rsp(const accept_task_rsp& from);

  inline accept_task_rsp& operator=(const accept_task_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const accept_task_rsp& default_instance();

  void Swap(accept_task_rsp* other);

  // implements Message ----------------------------------------------

  accept_task_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const accept_task_rsp& from);
  void MergeFrom(const accept_task_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.TASK_RESULT ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::TASK_RESULT ret() const;
  inline void set_ret(::client::TASK_RESULT value);

  // required uint32 task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.accept_task_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;
  ::google::protobuf::uint32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static accept_task_rsp* default_instance_;
};
// -------------------------------------------------------------------

class submit_task_req : public ::google::protobuf::Message {
 public:
  submit_task_req();
  virtual ~submit_task_req();

  submit_task_req(const submit_task_req& from);

  inline submit_task_req& operator=(const submit_task_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const submit_task_req& default_instance();

  void Swap(submit_task_req* other);

  // implements Message ----------------------------------------------

  submit_task_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const submit_task_req& from);
  void MergeFrom(const submit_task_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // repeated uint32 chose_reward_id = 2;
  inline int chose_reward_id_size() const;
  inline void clear_chose_reward_id();
  static const int kChoseRewardIdFieldNumber = 2;
  inline ::google::protobuf::uint32 chose_reward_id(int index) const;
  inline void set_chose_reward_id(int index, ::google::protobuf::uint32 value);
  inline void add_chose_reward_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      chose_reward_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_chose_reward_id();

  // optional uint32 task_flag = 3;
  inline bool has_task_flag() const;
  inline void clear_task_flag();
  static const int kTaskFlagFieldNumber = 3;
  inline ::google::protobuf::uint32 task_flag() const;
  inline void set_task_flag(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.submit_task_req)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_task_flag();
  inline void clear_has_task_flag();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > chose_reward_id_;
  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 task_flag_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static submit_task_req* default_instance_;
};
// -------------------------------------------------------------------

class submit_task_rsp : public ::google::protobuf::Message {
 public:
  submit_task_rsp();
  virtual ~submit_task_rsp();

  submit_task_rsp(const submit_task_rsp& from);

  inline submit_task_rsp& operator=(const submit_task_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const submit_task_rsp& default_instance();

  void Swap(submit_task_rsp* other);

  // implements Message ----------------------------------------------

  submit_task_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const submit_task_rsp& from);
  void MergeFrom(const submit_task_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.TASK_RESULT ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::TASK_RESULT ret() const;
  inline void set_ret(::client::TASK_RESULT value);

  // required uint32 task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.submit_task_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;
  ::google::protobuf::uint32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static submit_task_rsp* default_instance_;
};
// -------------------------------------------------------------------

class talk_task_req : public ::google::protobuf::Message {
 public:
  talk_task_req();
  virtual ~talk_task_req();

  talk_task_req(const talk_task_req& from);

  inline talk_task_req& operator=(const talk_task_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const talk_task_req& default_instance();

  void Swap(talk_task_req* other);

  // implements Message ----------------------------------------------

  talk_task_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const talk_task_req& from);
  void MergeFrom(const talk_task_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // required uint32 npc_id = 2;
  inline bool has_npc_id() const;
  inline void clear_npc_id();
  static const int kNpcIdFieldNumber = 2;
  inline ::google::protobuf::uint32 npc_id() const;
  inline void set_npc_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.talk_task_req)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_npc_id();
  inline void clear_has_npc_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 npc_id_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static talk_task_req* default_instance_;
};
// -------------------------------------------------------------------

class talk_task_rsp : public ::google::protobuf::Message {
 public:
  talk_task_rsp();
  virtual ~talk_task_rsp();

  talk_task_rsp(const talk_task_rsp& from);

  inline talk_task_rsp& operator=(const talk_task_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const talk_task_rsp& default_instance();

  void Swap(talk_task_rsp* other);

  // implements Message ----------------------------------------------

  talk_task_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const talk_task_rsp& from);
  void MergeFrom(const talk_task_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.TASK_RESULT ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::TASK_RESULT ret() const;
  inline void set_ret(::client::TASK_RESULT value);

  // required uint32 task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.talk_task_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;
  ::google::protobuf::uint32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static talk_task_rsp* default_instance_;
};
// -------------------------------------------------------------------

class story_end_req : public ::google::protobuf::Message {
 public:
  story_end_req();
  virtual ~story_end_req();

  story_end_req(const story_end_req& from);

  inline story_end_req& operator=(const story_end_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const story_end_req& default_instance();

  void Swap(story_end_req* other);

  // implements Message ----------------------------------------------

  story_end_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const story_end_req& from);
  void MergeFrom(const story_end_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.story_end_req)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2etask_2eproto();
  friend void protobuf_AssignDesc_client_2etask_2eproto();
  friend void protobuf_ShutdownFile_client_2etask_2eproto();

  void InitAsDefaultInstance();
  static story_end_req* default_instance_;
};
// ===================================================================


// ===================================================================

// ctrl_scene_req

// required .client.ctrl_scene_req.ctrl_type type = 1;
inline bool ctrl_scene_req::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ctrl_scene_req::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ctrl_scene_req::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ctrl_scene_req::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::client::ctrl_scene_req_ctrl_type ctrl_scene_req::type() const {
  return static_cast< ::client::ctrl_scene_req_ctrl_type >(type_);
}
inline void ctrl_scene_req::set_type(::client::ctrl_scene_req_ctrl_type value) {
  assert(::client::ctrl_scene_req_ctrl_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 unixtime = 2;
inline bool ctrl_scene_req::has_unixtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctrl_scene_req::set_has_unixtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ctrl_scene_req::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ctrl_scene_req::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 ctrl_scene_req::unixtime() const {
  return unixtime_;
}
inline void ctrl_scene_req::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool ctrl_scene_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ctrl_scene_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ctrl_scene_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ctrl_scene_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& ctrl_scene_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* ctrl_scene_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* ctrl_scene_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void ctrl_scene_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// ctrl_scene_rsp

// required uint32 ret = 1;
inline bool ctrl_scene_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ctrl_scene_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ctrl_scene_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ctrl_scene_rsp::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 ctrl_scene_rsp::ret() const {
  return ret_;
}
inline void ctrl_scene_rsp::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
}

// required .client.ctrl_scene_req req = 2;
inline bool ctrl_scene_rsp::has_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctrl_scene_rsp::set_has_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ctrl_scene_rsp::clear_has_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ctrl_scene_rsp::clear_req() {
  if (req_ != NULL) req_->::client::ctrl_scene_req::Clear();
  clear_has_req();
}
inline const ::client::ctrl_scene_req& ctrl_scene_rsp::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::client::ctrl_scene_req* ctrl_scene_rsp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::client::ctrl_scene_req;
  return req_;
}
inline ::client::ctrl_scene_req* ctrl_scene_rsp::release_req() {
  clear_has_req();
  ::client::ctrl_scene_req* temp = req_;
  req_ = NULL;
  return temp;
}
inline void ctrl_scene_rsp::set_allocated_req(::client::ctrl_scene_req* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// task_talk

// required uint32 npc_id = 1;
inline bool task_talk::has_npc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_talk::set_has_npc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_talk::clear_has_npc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_talk::clear_npc_id() {
  npc_id_ = 0u;
  clear_has_npc_id();
}
inline ::google::protobuf::uint32 task_talk::npc_id() const {
  return npc_id_;
}
inline void task_talk::set_npc_id(::google::protobuf::uint32 value) {
  set_has_npc_id();
  npc_id_ = value;
}

// -------------------------------------------------------------------

// task_raid

// required uint32 raid_id = 1;
inline bool task_raid::has_raid_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_raid::set_has_raid_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_raid::clear_has_raid_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_raid::clear_raid_id() {
  raid_id_ = 0u;
  clear_has_raid_id();
}
inline ::google::protobuf::uint32 task_raid::raid_id() const {
  return raid_id_;
}
inline void task_raid::set_raid_id(::google::protobuf::uint32 value) {
  set_has_raid_id();
  raid_id_ = value;
}

// required uint32 count = 2;
inline bool task_raid::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_raid::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_raid::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_raid::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 task_raid::count() const {
  return count_;
}
inline void task_raid::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// task_pick

// required uint32 id = 1;
inline bool task_pick::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_pick::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_pick::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_pick::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 task_pick::id() const {
  return id_;
}
inline void task_pick::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 count = 2;
inline bool task_pick::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_pick::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_pick::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_pick::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 task_pick::count() const {
  return count_;
}
inline void task_pick::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// task_kill

// required uint32 id = 1;
inline bool task_kill::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_kill::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_kill::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_kill::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 task_kill::id() const {
  return id_;
}
inline void task_kill::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 count = 2;
inline bool task_kill::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_kill::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_kill::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_kill::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 task_kill::count() const {
  return count_;
}
inline void task_kill::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// task_guard

// required uint32 id = 1;
inline bool task_guard::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_guard::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_guard::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_guard::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 task_guard::id() const {
  return id_;
}
inline void task_guard::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// task_level

// required uint32 level = 1;
inline bool task_level::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_level::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_level::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_level::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 task_level::level() const {
  return level_;
}
inline void task_level::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// task_event

// required uint32 id = 1;
inline bool task_event::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_event::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_event::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_event::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 task_event::id() const {
  return id_;
}
inline void task_event::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// task_progress

// repeated .client.task_talk talk = 1;
inline int task_progress::talk_size() const {
  return talk_.size();
}
inline void task_progress::clear_talk() {
  talk_.Clear();
}
inline const ::client::task_talk& task_progress::talk(int index) const {
  return talk_.Get(index);
}
inline ::client::task_talk* task_progress::mutable_talk(int index) {
  return talk_.Mutable(index);
}
inline ::client::task_talk* task_progress::add_talk() {
  return talk_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_talk >&
task_progress::talk() const {
  return talk_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_talk >*
task_progress::mutable_talk() {
  return &talk_;
}

// repeated .client.task_raid raid = 2;
inline int task_progress::raid_size() const {
  return raid_.size();
}
inline void task_progress::clear_raid() {
  raid_.Clear();
}
inline const ::client::task_raid& task_progress::raid(int index) const {
  return raid_.Get(index);
}
inline ::client::task_raid* task_progress::mutable_raid(int index) {
  return raid_.Mutable(index);
}
inline ::client::task_raid* task_progress::add_raid() {
  return raid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_raid >&
task_progress::raid() const {
  return raid_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_raid >*
task_progress::mutable_raid() {
  return &raid_;
}

// repeated .client.task_pick pick = 3;
inline int task_progress::pick_size() const {
  return pick_.size();
}
inline void task_progress::clear_pick() {
  pick_.Clear();
}
inline const ::client::task_pick& task_progress::pick(int index) const {
  return pick_.Get(index);
}
inline ::client::task_pick* task_progress::mutable_pick(int index) {
  return pick_.Mutable(index);
}
inline ::client::task_pick* task_progress::add_pick() {
  return pick_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_pick >&
task_progress::pick() const {
  return pick_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_pick >*
task_progress::mutable_pick() {
  return &pick_;
}

// repeated .client.task_kill kill = 4;
inline int task_progress::kill_size() const {
  return kill_.size();
}
inline void task_progress::clear_kill() {
  kill_.Clear();
}
inline const ::client::task_kill& task_progress::kill(int index) const {
  return kill_.Get(index);
}
inline ::client::task_kill* task_progress::mutable_kill(int index) {
  return kill_.Mutable(index);
}
inline ::client::task_kill* task_progress::add_kill() {
  return kill_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_kill >&
task_progress::kill() const {
  return kill_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_kill >*
task_progress::mutable_kill() {
  return &kill_;
}

// repeated .client.task_guard guard = 5;
inline int task_progress::guard_size() const {
  return guard_.size();
}
inline void task_progress::clear_guard() {
  guard_.Clear();
}
inline const ::client::task_guard& task_progress::guard(int index) const {
  return guard_.Get(index);
}
inline ::client::task_guard* task_progress::mutable_guard(int index) {
  return guard_.Mutable(index);
}
inline ::client::task_guard* task_progress::add_guard() {
  return guard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_guard >&
task_progress::guard() const {
  return guard_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_guard >*
task_progress::mutable_guard() {
  return &guard_;
}

// repeated .client.task_level level = 6;
inline int task_progress::level_size() const {
  return level_.size();
}
inline void task_progress::clear_level() {
  level_.Clear();
}
inline const ::client::task_level& task_progress::level(int index) const {
  return level_.Get(index);
}
inline ::client::task_level* task_progress::mutable_level(int index) {
  return level_.Mutable(index);
}
inline ::client::task_level* task_progress::add_level() {
  return level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_level >&
task_progress::level() const {
  return level_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_level >*
task_progress::mutable_level() {
  return &level_;
}

// repeated .client.task_event event = 7;
inline int task_progress::event_size() const {
  return event_.size();
}
inline void task_progress::clear_event() {
  event_.Clear();
}
inline const ::client::task_event& task_progress::event(int index) const {
  return event_.Get(index);
}
inline ::client::task_event* task_progress::mutable_event(int index) {
  return event_.Mutable(index);
}
inline ::client::task_event* task_progress::add_event() {
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_event >&
task_progress::event() const {
  return event_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_event >*
task_progress::mutable_event() {
  return &event_;
}

// -------------------------------------------------------------------

// task_accepted

// required uint32 task_id = 1 [default = 0];
inline bool task_accepted::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_accepted::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_accepted::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_accepted::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 task_accepted::task_id() const {
  return task_id_;
}
inline void task_accepted::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// required .client.task_progress progress = 2;
inline bool task_accepted::has_progress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_accepted::set_has_progress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_accepted::clear_has_progress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_accepted::clear_progress() {
  if (progress_ != NULL) progress_->::client::task_progress::Clear();
  clear_has_progress();
}
inline const ::client::task_progress& task_accepted::progress() const {
  return progress_ != NULL ? *progress_ : *default_instance_->progress_;
}
inline ::client::task_progress* task_accepted::mutable_progress() {
  set_has_progress();
  if (progress_ == NULL) progress_ = new ::client::task_progress;
  return progress_;
}
inline ::client::task_progress* task_accepted::release_progress() {
  clear_has_progress();
  ::client::task_progress* temp = progress_;
  progress_ = NULL;
  return temp;
}
inline void task_accepted::set_allocated_progress(::client::task_progress* progress) {
  delete progress_;
  progress_ = progress;
  if (progress) {
    set_has_progress();
  } else {
    clear_has_progress();
  }
}

// -------------------------------------------------------------------

// task_completed

// required uint32 task_id = 1 [default = 0];
inline bool task_completed::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_completed::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_completed::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_completed::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 task_completed::task_id() const {
  return task_id_;
}
inline void task_completed::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// required uint32 count = 2 [default = 0];
inline bool task_completed::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_completed::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_completed::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_completed::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 task_completed::count() const {
  return count_;
}
inline void task_completed::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 time = 3 [default = 0];
inline bool task_completed::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void task_completed::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void task_completed::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void task_completed::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 task_completed::time() const {
  return time_;
}
inline void task_completed::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// task_msg

// required .client.task_msg.type t = 1;
inline bool task_msg::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_msg::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_msg::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_msg::clear_t() {
  t_ = 1;
  clear_has_t();
}
inline ::client::task_msg_type task_msg::t() const {
  return static_cast< ::client::task_msg_type >(t_);
}
inline void task_msg::set_t(::client::task_msg_type value) {
  assert(::client::task_msg_type_IsValid(value));
  set_has_t();
  t_ = value;
}

// repeated .client.task_accepted accepted = 2;
inline int task_msg::accepted_size() const {
  return accepted_.size();
}
inline void task_msg::clear_accepted() {
  accepted_.Clear();
}
inline const ::client::task_accepted& task_msg::accepted(int index) const {
  return accepted_.Get(index);
}
inline ::client::task_accepted* task_msg::mutable_accepted(int index) {
  return accepted_.Mutable(index);
}
inline ::client::task_accepted* task_msg::add_accepted() {
  return accepted_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_accepted >&
task_msg::accepted() const {
  return accepted_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_accepted >*
task_msg::mutable_accepted() {
  return &accepted_;
}

// repeated .client.task_completed completed = 3;
inline int task_msg::completed_size() const {
  return completed_.size();
}
inline void task_msg::clear_completed() {
  completed_.Clear();
}
inline const ::client::task_completed& task_msg::completed(int index) const {
  return completed_.Get(index);
}
inline ::client::task_completed* task_msg::mutable_completed(int index) {
  return completed_.Mutable(index);
}
inline ::client::task_completed* task_msg::add_completed() {
  return completed_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::task_completed >&
task_msg::completed() const {
  return completed_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::task_completed >*
task_msg::mutable_completed() {
  return &completed_;
}

// optional uint32 task_flag = 4;
inline bool task_msg::has_task_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void task_msg::set_has_task_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void task_msg::clear_has_task_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void task_msg::clear_task_flag() {
  task_flag_ = 0u;
  clear_has_task_flag();
}
inline ::google::protobuf::uint32 task_msg::task_flag() const {
  return task_flag_;
}
inline void task_msg::set_task_flag(::google::protobuf::uint32 value) {
  set_has_task_flag();
  task_flag_ = value;
}

// -------------------------------------------------------------------

// accept_task_req

// required uint32 task_id = 1;
inline bool accept_task_req::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void accept_task_req::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void accept_task_req::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void accept_task_req::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 accept_task_req::task_id() const {
  return task_id_;
}
inline void accept_task_req::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool accept_task_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void accept_task_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void accept_task_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void accept_task_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& accept_task_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* accept_task_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* accept_task_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void accept_task_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// accept_task_rsp

// required .client.TASK_RESULT ret = 1;
inline bool accept_task_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void accept_task_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void accept_task_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void accept_task_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::TASK_RESULT accept_task_rsp::ret() const {
  return static_cast< ::client::TASK_RESULT >(ret_);
}
inline void accept_task_rsp::set_ret(::client::TASK_RESULT value) {
  assert(::client::TASK_RESULT_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// required uint32 task_id = 2;
inline bool accept_task_rsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void accept_task_rsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void accept_task_rsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void accept_task_rsp::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 accept_task_rsp::task_id() const {
  return task_id_;
}
inline void accept_task_rsp::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// -------------------------------------------------------------------

// submit_task_req

// required uint32 task_id = 1;
inline bool submit_task_req::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void submit_task_req::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void submit_task_req::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void submit_task_req::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 submit_task_req::task_id() const {
  return task_id_;
}
inline void submit_task_req::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// repeated uint32 chose_reward_id = 2;
inline int submit_task_req::chose_reward_id_size() const {
  return chose_reward_id_.size();
}
inline void submit_task_req::clear_chose_reward_id() {
  chose_reward_id_.Clear();
}
inline ::google::protobuf::uint32 submit_task_req::chose_reward_id(int index) const {
  return chose_reward_id_.Get(index);
}
inline void submit_task_req::set_chose_reward_id(int index, ::google::protobuf::uint32 value) {
  chose_reward_id_.Set(index, value);
}
inline void submit_task_req::add_chose_reward_id(::google::protobuf::uint32 value) {
  chose_reward_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
submit_task_req::chose_reward_id() const {
  return chose_reward_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
submit_task_req::mutable_chose_reward_id() {
  return &chose_reward_id_;
}

// optional uint32 task_flag = 3;
inline bool submit_task_req::has_task_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void submit_task_req::set_has_task_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void submit_task_req::clear_has_task_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void submit_task_req::clear_task_flag() {
  task_flag_ = 0u;
  clear_has_task_flag();
}
inline ::google::protobuf::uint32 submit_task_req::task_flag() const {
  return task_flag_;
}
inline void submit_task_req::set_task_flag(::google::protobuf::uint32 value) {
  set_has_task_flag();
  task_flag_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool submit_task_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void submit_task_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void submit_task_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void submit_task_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& submit_task_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* submit_task_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* submit_task_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void submit_task_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// submit_task_rsp

// required .client.TASK_RESULT ret = 1;
inline bool submit_task_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void submit_task_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void submit_task_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void submit_task_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::TASK_RESULT submit_task_rsp::ret() const {
  return static_cast< ::client::TASK_RESULT >(ret_);
}
inline void submit_task_rsp::set_ret(::client::TASK_RESULT value) {
  assert(::client::TASK_RESULT_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// required uint32 task_id = 2;
inline bool submit_task_rsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void submit_task_rsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void submit_task_rsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void submit_task_rsp::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 submit_task_rsp::task_id() const {
  return task_id_;
}
inline void submit_task_rsp::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// -------------------------------------------------------------------

// talk_task_req

// required uint32 task_id = 1;
inline bool talk_task_req::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void talk_task_req::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void talk_task_req::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void talk_task_req::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 talk_task_req::task_id() const {
  return task_id_;
}
inline void talk_task_req::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// required uint32 npc_id = 2;
inline bool talk_task_req::has_npc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void talk_task_req::set_has_npc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void talk_task_req::clear_has_npc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void talk_task_req::clear_npc_id() {
  npc_id_ = 0u;
  clear_has_npc_id();
}
inline ::google::protobuf::uint32 talk_task_req::npc_id() const {
  return npc_id_;
}
inline void talk_task_req::set_npc_id(::google::protobuf::uint32 value) {
  set_has_npc_id();
  npc_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool talk_task_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void talk_task_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void talk_task_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void talk_task_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& talk_task_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* talk_task_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* talk_task_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void talk_task_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// talk_task_rsp

// required .client.TASK_RESULT ret = 1;
inline bool talk_task_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void talk_task_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void talk_task_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void talk_task_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::TASK_RESULT talk_task_rsp::ret() const {
  return static_cast< ::client::TASK_RESULT >(ret_);
}
inline void talk_task_rsp::set_ret(::client::TASK_RESULT value) {
  assert(::client::TASK_RESULT_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// required uint32 task_id = 2;
inline bool talk_task_rsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void talk_task_rsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void talk_task_rsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void talk_task_rsp::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 talk_task_rsp::task_id() const {
  return task_id_;
}
inline void talk_task_rsp::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// -------------------------------------------------------------------

// story_end_req

// required uint32 id = 1;
inline bool story_end_req::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void story_end_req::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void story_end_req::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void story_end_req::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 story_end_req::id() const {
  return id_;
}
inline void story_end_req::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool story_end_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void story_end_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void story_end_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void story_end_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& story_end_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* story_end_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* story_end_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void story_end_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::ctrl_scene_req_ctrl_type>() {
  return ::client::ctrl_scene_req_ctrl_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::task_msg_type>() {
  return ::client::task_msg_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::TASK_RESULT>() {
  return ::client::TASK_RESULT_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2etask_2eproto__INCLUDED
