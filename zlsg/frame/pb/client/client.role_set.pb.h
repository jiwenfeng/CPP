// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.role_set.proto

#ifndef PROTOBUF_client_2erole_5fset_2eproto__INCLUDED
#define PROTOBUF_client_2erole_5fset_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2erole_5fset_2eproto();
void protobuf_AssignDesc_client_2erole_5fset_2eproto();
void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

class shortcut_req;
class shortcut_info;
class shortcut_rsp;
class shortcut_set_req;
class shortcut_set_rsp;
class handup_req;
class handup_info;
class handup_rsp;
class handup_set_req;
class handup_set_rsp;
class practice_info;
class role_set_info;

// ===================================================================

class shortcut_req : public ::google::protobuf::Message {
 public:
  shortcut_req();
  virtual ~shortcut_req();

  shortcut_req(const shortcut_req& from);

  inline shortcut_req& operator=(const shortcut_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shortcut_req& default_instance();

  void Swap(shortcut_req* other);

  // implements Message ----------------------------------------------

  shortcut_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shortcut_req& from);
  void MergeFrom(const shortcut_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.shortcut_req)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static shortcut_req* default_instance_;
};
// -------------------------------------------------------------------

class shortcut_info : public ::google::protobuf::Message {
 public:
  shortcut_info();
  virtual ~shortcut_info();

  shortcut_info(const shortcut_info& from);

  inline shortcut_info& operator=(const shortcut_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shortcut_info& default_instance();

  void Swap(shortcut_info* other);

  // implements Message ----------------------------------------------

  shortcut_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shortcut_info& from);
  void MergeFrom(const shortcut_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 type = 2 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 val = 3 [default = 0];
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 3;
  inline ::google::protobuf::uint32 val() const;
  inline void set_val(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.shortcut_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static shortcut_info* default_instance_;
};
// -------------------------------------------------------------------

class shortcut_rsp : public ::google::protobuf::Message {
 public:
  shortcut_rsp();
  virtual ~shortcut_rsp();

  shortcut_rsp(const shortcut_rsp& from);

  inline shortcut_rsp& operator=(const shortcut_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shortcut_rsp& default_instance();

  void Swap(shortcut_rsp* other);

  // implements Message ----------------------------------------------

  shortcut_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shortcut_rsp& from);
  void MergeFrom(const shortcut_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.shortcut_info si = 1;
  inline int si_size() const;
  inline void clear_si();
  static const int kSiFieldNumber = 1;
  inline const ::client::shortcut_info& si(int index) const;
  inline ::client::shortcut_info* mutable_si(int index);
  inline ::client::shortcut_info* add_si();
  inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
      si() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
      mutable_si();

  // @@protoc_insertion_point(class_scope:client.shortcut_rsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::shortcut_info > si_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static shortcut_rsp* default_instance_;
};
// -------------------------------------------------------------------

class shortcut_set_req : public ::google::protobuf::Message {
 public:
  shortcut_set_req();
  virtual ~shortcut_set_req();

  shortcut_set_req(const shortcut_set_req& from);

  inline shortcut_set_req& operator=(const shortcut_set_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shortcut_set_req& default_instance();

  void Swap(shortcut_set_req* other);

  // implements Message ----------------------------------------------

  shortcut_set_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shortcut_set_req& from);
  void MergeFrom(const shortcut_set_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.shortcut_info si = 1;
  inline int si_size() const;
  inline void clear_si();
  static const int kSiFieldNumber = 1;
  inline const ::client::shortcut_info& si(int index) const;
  inline ::client::shortcut_info* mutable_si(int index);
  inline ::client::shortcut_info* add_si();
  inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
      si() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
      mutable_si();

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.shortcut_set_req)
 private:
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::shortcut_info > si_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static shortcut_set_req* default_instance_;
};
// -------------------------------------------------------------------

class shortcut_set_rsp : public ::google::protobuf::Message {
 public:
  shortcut_set_rsp();
  virtual ~shortcut_set_rsp();

  shortcut_set_rsp(const shortcut_set_rsp& from);

  inline shortcut_set_rsp& operator=(const shortcut_set_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shortcut_set_rsp& default_instance();

  void Swap(shortcut_set_rsp* other);

  // implements Message ----------------------------------------------

  shortcut_set_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shortcut_set_rsp& from);
  void MergeFrom(const shortcut_set_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.shortcut_info si = 1;
  inline int si_size() const;
  inline void clear_si();
  static const int kSiFieldNumber = 1;
  inline const ::client::shortcut_info& si(int index) const;
  inline ::client::shortcut_info* mutable_si(int index);
  inline ::client::shortcut_info* add_si();
  inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
      si() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
      mutable_si();

  // repeated uint32 ret = 2;
  inline int ret_size() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::uint32 ret(int index) const;
  inline void set_ret(int index, ::google::protobuf::uint32 value);
  inline void add_ret(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ret() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ret();

  // @@protoc_insertion_point(class_scope:client.shortcut_set_rsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::shortcut_info > si_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static shortcut_set_rsp* default_instance_;
};
// -------------------------------------------------------------------

class handup_req : public ::google::protobuf::Message {
 public:
  handup_req();
  virtual ~handup_req();

  handup_req(const handup_req& from);

  inline handup_req& operator=(const handup_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const handup_req& default_instance();

  void Swap(handup_req* other);

  // implements Message ----------------------------------------------

  handup_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const handup_req& from);
  void MergeFrom(const handup_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.handup_req)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static handup_req* default_instance_;
};
// -------------------------------------------------------------------

class handup_info : public ::google::protobuf::Message {
 public:
  handup_info();
  virtual ~handup_info();

  handup_info(const handup_info& from);

  inline handup_info& operator=(const handup_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const handup_info& default_instance();

  void Swap(handup_info* other);

  // implements Message ----------------------------------------------

  handup_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const handup_info& from);
  void MergeFrom(const handup_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool relive = 1;
  inline bool has_relive() const;
  inline void clear_relive();
  static const int kReliveFieldNumber = 1;
  inline bool relive() const;
  inline void set_relive(bool value);

  // optional bool pick_equip = 2;
  inline bool has_pick_equip() const;
  inline void clear_pick_equip();
  static const int kPickEquipFieldNumber = 2;
  inline bool pick_equip() const;
  inline void set_pick_equip(bool value);

  // optional uint32 pick_prop = 3;
  inline bool has_pick_prop() const;
  inline void clear_pick_prop();
  static const int kPickPropFieldNumber = 3;
  inline ::google::protobuf::uint32 pick_prop() const;
  inline void set_pick_prop(::google::protobuf::uint32 value);

  // optional bool back_base = 4;
  inline bool has_back_base() const;
  inline void clear_back_base();
  static const int kBackBaseFieldNumber = 4;
  inline bool back_base() const;
  inline void set_back_base(bool value);

  // repeated uint32 skills = 5;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 5;
  inline ::google::protobuf::uint32 skills(int index) const;
  inline void set_skills(int index, ::google::protobuf::uint32 value);
  inline void add_skills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      skills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_skills();

  // @@protoc_insertion_point(class_scope:client.handup_info)
 private:
  inline void set_has_relive();
  inline void clear_has_relive();
  inline void set_has_pick_equip();
  inline void clear_has_pick_equip();
  inline void set_has_pick_prop();
  inline void clear_has_pick_prop();
  inline void set_has_back_base();
  inline void clear_has_back_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool relive_;
  bool pick_equip_;
  bool back_base_;
  ::google::protobuf::uint32 pick_prop_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > skills_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static handup_info* default_instance_;
};
// -------------------------------------------------------------------

class handup_rsp : public ::google::protobuf::Message {
 public:
  handup_rsp();
  virtual ~handup_rsp();

  handup_rsp(const handup_rsp& from);

  inline handup_rsp& operator=(const handup_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const handup_rsp& default_instance();

  void Swap(handup_rsp* other);

  // implements Message ----------------------------------------------

  handup_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const handup_rsp& from);
  void MergeFrom(const handup_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.handup_info hi = 1;
  inline bool has_hi() const;
  inline void clear_hi();
  static const int kHiFieldNumber = 1;
  inline const ::client::handup_info& hi() const;
  inline ::client::handup_info* mutable_hi();
  inline ::client::handup_info* release_hi();
  inline void set_allocated_hi(::client::handup_info* hi);

  // @@protoc_insertion_point(class_scope:client.handup_rsp)
 private:
  inline void set_has_hi();
  inline void clear_has_hi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::handup_info* hi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static handup_rsp* default_instance_;
};
// -------------------------------------------------------------------

class handup_set_req : public ::google::protobuf::Message {
 public:
  handup_set_req();
  virtual ~handup_set_req();

  handup_set_req(const handup_set_req& from);

  inline handup_set_req& operator=(const handup_set_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const handup_set_req& default_instance();

  void Swap(handup_set_req* other);

  // implements Message ----------------------------------------------

  handup_set_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const handup_set_req& from);
  void MergeFrom(const handup_set_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.handup_info hi = 1;
  inline bool has_hi() const;
  inline void clear_hi();
  static const int kHiFieldNumber = 1;
  inline const ::client::handup_info& hi() const;
  inline ::client::handup_info* mutable_hi();
  inline ::client::handup_info* release_hi();
  inline void set_allocated_hi(::client::handup_info* hi);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.handup_set_req)
 private:
  inline void set_has_hi();
  inline void clear_has_hi();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::handup_info* hi_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static handup_set_req* default_instance_;
};
// -------------------------------------------------------------------

class handup_set_rsp : public ::google::protobuf::Message {
 public:
  handup_set_rsp();
  virtual ~handup_set_rsp();

  handup_set_rsp(const handup_set_rsp& from);

  inline handup_set_rsp& operator=(const handup_set_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const handup_set_rsp& default_instance();

  void Swap(handup_set_rsp* other);

  // implements Message ----------------------------------------------

  handup_set_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const handup_set_rsp& from);
  void MergeFrom(const handup_set_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.handup_info hi = 1;
  inline bool has_hi() const;
  inline void clear_hi();
  static const int kHiFieldNumber = 1;
  inline const ::client::handup_info& hi() const;
  inline ::client::handup_info* mutable_hi();
  inline ::client::handup_info* release_hi();
  inline void set_allocated_hi(::client::handup_info* hi);

  // @@protoc_insertion_point(class_scope:client.handup_set_rsp)
 private:
  inline void set_has_hi();
  inline void clear_has_hi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::handup_info* hi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static handup_set_rsp* default_instance_;
};
// -------------------------------------------------------------------

class practice_info : public ::google::protobuf::Message {
 public:
  practice_info();
  virtual ~practice_info();

  practice_info(const practice_info& from);

  inline practice_info& operator=(const practice_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const practice_info& default_instance();

  void Swap(practice_info* other);

  // implements Message ----------------------------------------------

  practice_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const practice_info& from);
  void MergeFrom(const practice_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool auto_practice = 1 [default = true];
  inline bool has_auto_practice() const;
  inline void clear_auto_practice();
  static const int kAutoPracticeFieldNumber = 1;
  inline bool auto_practice() const;
  inline void set_auto_practice(bool value);

  // optional bool auto_comm_practice = 2 [default = true];
  inline bool has_auto_comm_practice() const;
  inline void clear_auto_comm_practice();
  static const int kAutoCommPracticeFieldNumber = 2;
  inline bool auto_comm_practice() const;
  inline void set_auto_comm_practice(bool value);

  // @@protoc_insertion_point(class_scope:client.practice_info)
 private:
  inline void set_has_auto_practice();
  inline void clear_has_auto_practice();
  inline void set_has_auto_comm_practice();
  inline void clear_has_auto_comm_practice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool auto_practice_;
  bool auto_comm_practice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static practice_info* default_instance_;
};
// -------------------------------------------------------------------

class role_set_info : public ::google::protobuf::Message {
 public:
  role_set_info();
  virtual ~role_set_info();

  role_set_info(const role_set_info& from);

  inline role_set_info& operator=(const role_set_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_set_info& default_instance();

  void Swap(role_set_info* other);

  // implements Message ----------------------------------------------

  role_set_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_set_info& from);
  void MergeFrom(const role_set_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.shortcut_info si = 1;
  inline int si_size() const;
  inline void clear_si();
  static const int kSiFieldNumber = 1;
  inline const ::client::shortcut_info& si(int index) const;
  inline ::client::shortcut_info* mutable_si(int index);
  inline ::client::shortcut_info* add_si();
  inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
      si() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
      mutable_si();

  // optional .client.handup_info hi = 2;
  inline bool has_hi() const;
  inline void clear_hi();
  static const int kHiFieldNumber = 2;
  inline const ::client::handup_info& hi() const;
  inline ::client::handup_info* mutable_hi();
  inline ::client::handup_info* release_hi();
  inline void set_allocated_hi(::client::handup_info* hi);

  // optional .client.practice_info pi = 3;
  inline bool has_pi() const;
  inline void clear_pi();
  static const int kPiFieldNumber = 3;
  inline const ::client::practice_info& pi() const;
  inline ::client::practice_info* mutable_pi();
  inline ::client::practice_info* release_pi();
  inline void set_allocated_pi(::client::practice_info* pi);

  // @@protoc_insertion_point(class_scope:client.role_set_info)
 private:
  inline void set_has_hi();
  inline void clear_has_hi();
  inline void set_has_pi();
  inline void clear_has_pi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::shortcut_info > si_;
  ::client::handup_info* hi_;
  ::client::practice_info* pi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fset_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fset_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fset_2eproto();

  void InitAsDefaultInstance();
  static role_set_info* default_instance_;
};
// ===================================================================


// ===================================================================

// shortcut_req

// required uint32 unixtime = 1;
inline bool shortcut_req::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void shortcut_req::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void shortcut_req::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void shortcut_req::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 shortcut_req::unixtime() const {
  return unixtime_;
}
inline void shortcut_req::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool shortcut_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void shortcut_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void shortcut_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void shortcut_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& shortcut_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* shortcut_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* shortcut_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void shortcut_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// shortcut_info

// required uint32 id = 1 [default = 0];
inline bool shortcut_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void shortcut_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void shortcut_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void shortcut_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 shortcut_info::id() const {
  return id_;
}
inline void shortcut_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 type = 2 [default = 0];
inline bool shortcut_info::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void shortcut_info::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void shortcut_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void shortcut_info::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 shortcut_info::type() const {
  return type_;
}
inline void shortcut_info::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 val = 3 [default = 0];
inline bool shortcut_info::has_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void shortcut_info::set_has_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void shortcut_info::clear_has_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void shortcut_info::clear_val() {
  val_ = 0u;
  clear_has_val();
}
inline ::google::protobuf::uint32 shortcut_info::val() const {
  return val_;
}
inline void shortcut_info::set_val(::google::protobuf::uint32 value) {
  set_has_val();
  val_ = value;
}

// -------------------------------------------------------------------

// shortcut_rsp

// repeated .client.shortcut_info si = 1;
inline int shortcut_rsp::si_size() const {
  return si_.size();
}
inline void shortcut_rsp::clear_si() {
  si_.Clear();
}
inline const ::client::shortcut_info& shortcut_rsp::si(int index) const {
  return si_.Get(index);
}
inline ::client::shortcut_info* shortcut_rsp::mutable_si(int index) {
  return si_.Mutable(index);
}
inline ::client::shortcut_info* shortcut_rsp::add_si() {
  return si_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
shortcut_rsp::si() const {
  return si_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
shortcut_rsp::mutable_si() {
  return &si_;
}

// -------------------------------------------------------------------

// shortcut_set_req

// repeated .client.shortcut_info si = 1;
inline int shortcut_set_req::si_size() const {
  return si_.size();
}
inline void shortcut_set_req::clear_si() {
  si_.Clear();
}
inline const ::client::shortcut_info& shortcut_set_req::si(int index) const {
  return si_.Get(index);
}
inline ::client::shortcut_info* shortcut_set_req::mutable_si(int index) {
  return si_.Mutable(index);
}
inline ::client::shortcut_info* shortcut_set_req::add_si() {
  return si_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
shortcut_set_req::si() const {
  return si_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
shortcut_set_req::mutable_si() {
  return &si_;
}

// optional .client.server_head svr_head = 1000;
inline bool shortcut_set_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void shortcut_set_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void shortcut_set_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void shortcut_set_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& shortcut_set_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* shortcut_set_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* shortcut_set_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void shortcut_set_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// shortcut_set_rsp

// repeated .client.shortcut_info si = 1;
inline int shortcut_set_rsp::si_size() const {
  return si_.size();
}
inline void shortcut_set_rsp::clear_si() {
  si_.Clear();
}
inline const ::client::shortcut_info& shortcut_set_rsp::si(int index) const {
  return si_.Get(index);
}
inline ::client::shortcut_info* shortcut_set_rsp::mutable_si(int index) {
  return si_.Mutable(index);
}
inline ::client::shortcut_info* shortcut_set_rsp::add_si() {
  return si_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
shortcut_set_rsp::si() const {
  return si_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
shortcut_set_rsp::mutable_si() {
  return &si_;
}

// repeated uint32 ret = 2;
inline int shortcut_set_rsp::ret_size() const {
  return ret_.size();
}
inline void shortcut_set_rsp::clear_ret() {
  ret_.Clear();
}
inline ::google::protobuf::uint32 shortcut_set_rsp::ret(int index) const {
  return ret_.Get(index);
}
inline void shortcut_set_rsp::set_ret(int index, ::google::protobuf::uint32 value) {
  ret_.Set(index, value);
}
inline void shortcut_set_rsp::add_ret(::google::protobuf::uint32 value) {
  ret_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
shortcut_set_rsp::ret() const {
  return ret_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
shortcut_set_rsp::mutable_ret() {
  return &ret_;
}

// -------------------------------------------------------------------

// handup_req

// required uint32 unixtime = 1;
inline bool handup_req::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void handup_req::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void handup_req::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void handup_req::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 handup_req::unixtime() const {
  return unixtime_;
}
inline void handup_req::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool handup_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void handup_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void handup_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void handup_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& handup_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* handup_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* handup_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void handup_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// handup_info

// optional bool relive = 1;
inline bool handup_info::has_relive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void handup_info::set_has_relive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void handup_info::clear_has_relive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void handup_info::clear_relive() {
  relive_ = false;
  clear_has_relive();
}
inline bool handup_info::relive() const {
  return relive_;
}
inline void handup_info::set_relive(bool value) {
  set_has_relive();
  relive_ = value;
}

// optional bool pick_equip = 2;
inline bool handup_info::has_pick_equip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void handup_info::set_has_pick_equip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void handup_info::clear_has_pick_equip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void handup_info::clear_pick_equip() {
  pick_equip_ = false;
  clear_has_pick_equip();
}
inline bool handup_info::pick_equip() const {
  return pick_equip_;
}
inline void handup_info::set_pick_equip(bool value) {
  set_has_pick_equip();
  pick_equip_ = value;
}

// optional uint32 pick_prop = 3;
inline bool handup_info::has_pick_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void handup_info::set_has_pick_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void handup_info::clear_has_pick_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void handup_info::clear_pick_prop() {
  pick_prop_ = 0u;
  clear_has_pick_prop();
}
inline ::google::protobuf::uint32 handup_info::pick_prop() const {
  return pick_prop_;
}
inline void handup_info::set_pick_prop(::google::protobuf::uint32 value) {
  set_has_pick_prop();
  pick_prop_ = value;
}

// optional bool back_base = 4;
inline bool handup_info::has_back_base() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void handup_info::set_has_back_base() {
  _has_bits_[0] |= 0x00000008u;
}
inline void handup_info::clear_has_back_base() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void handup_info::clear_back_base() {
  back_base_ = false;
  clear_has_back_base();
}
inline bool handup_info::back_base() const {
  return back_base_;
}
inline void handup_info::set_back_base(bool value) {
  set_has_back_base();
  back_base_ = value;
}

// repeated uint32 skills = 5;
inline int handup_info::skills_size() const {
  return skills_.size();
}
inline void handup_info::clear_skills() {
  skills_.Clear();
}
inline ::google::protobuf::uint32 handup_info::skills(int index) const {
  return skills_.Get(index);
}
inline void handup_info::set_skills(int index, ::google::protobuf::uint32 value) {
  skills_.Set(index, value);
}
inline void handup_info::add_skills(::google::protobuf::uint32 value) {
  skills_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
handup_info::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
handup_info::mutable_skills() {
  return &skills_;
}

// -------------------------------------------------------------------

// handup_rsp

// required .client.handup_info hi = 1;
inline bool handup_rsp::has_hi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void handup_rsp::set_has_hi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void handup_rsp::clear_has_hi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void handup_rsp::clear_hi() {
  if (hi_ != NULL) hi_->::client::handup_info::Clear();
  clear_has_hi();
}
inline const ::client::handup_info& handup_rsp::hi() const {
  return hi_ != NULL ? *hi_ : *default_instance_->hi_;
}
inline ::client::handup_info* handup_rsp::mutable_hi() {
  set_has_hi();
  if (hi_ == NULL) hi_ = new ::client::handup_info;
  return hi_;
}
inline ::client::handup_info* handup_rsp::release_hi() {
  clear_has_hi();
  ::client::handup_info* temp = hi_;
  hi_ = NULL;
  return temp;
}
inline void handup_rsp::set_allocated_hi(::client::handup_info* hi) {
  delete hi_;
  hi_ = hi;
  if (hi) {
    set_has_hi();
  } else {
    clear_has_hi();
  }
}

// -------------------------------------------------------------------

// handup_set_req

// required .client.handup_info hi = 1;
inline bool handup_set_req::has_hi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void handup_set_req::set_has_hi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void handup_set_req::clear_has_hi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void handup_set_req::clear_hi() {
  if (hi_ != NULL) hi_->::client::handup_info::Clear();
  clear_has_hi();
}
inline const ::client::handup_info& handup_set_req::hi() const {
  return hi_ != NULL ? *hi_ : *default_instance_->hi_;
}
inline ::client::handup_info* handup_set_req::mutable_hi() {
  set_has_hi();
  if (hi_ == NULL) hi_ = new ::client::handup_info;
  return hi_;
}
inline ::client::handup_info* handup_set_req::release_hi() {
  clear_has_hi();
  ::client::handup_info* temp = hi_;
  hi_ = NULL;
  return temp;
}
inline void handup_set_req::set_allocated_hi(::client::handup_info* hi) {
  delete hi_;
  hi_ = hi;
  if (hi) {
    set_has_hi();
  } else {
    clear_has_hi();
  }
}

// optional .client.server_head svr_head = 1000;
inline bool handup_set_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void handup_set_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void handup_set_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void handup_set_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& handup_set_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* handup_set_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* handup_set_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void handup_set_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// handup_set_rsp

// required .client.handup_info hi = 1;
inline bool handup_set_rsp::has_hi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void handup_set_rsp::set_has_hi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void handup_set_rsp::clear_has_hi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void handup_set_rsp::clear_hi() {
  if (hi_ != NULL) hi_->::client::handup_info::Clear();
  clear_has_hi();
}
inline const ::client::handup_info& handup_set_rsp::hi() const {
  return hi_ != NULL ? *hi_ : *default_instance_->hi_;
}
inline ::client::handup_info* handup_set_rsp::mutable_hi() {
  set_has_hi();
  if (hi_ == NULL) hi_ = new ::client::handup_info;
  return hi_;
}
inline ::client::handup_info* handup_set_rsp::release_hi() {
  clear_has_hi();
  ::client::handup_info* temp = hi_;
  hi_ = NULL;
  return temp;
}
inline void handup_set_rsp::set_allocated_hi(::client::handup_info* hi) {
  delete hi_;
  hi_ = hi;
  if (hi) {
    set_has_hi();
  } else {
    clear_has_hi();
  }
}

// -------------------------------------------------------------------

// practice_info

// optional bool auto_practice = 1 [default = true];
inline bool practice_info::has_auto_practice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void practice_info::set_has_auto_practice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void practice_info::clear_has_auto_practice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void practice_info::clear_auto_practice() {
  auto_practice_ = true;
  clear_has_auto_practice();
}
inline bool practice_info::auto_practice() const {
  return auto_practice_;
}
inline void practice_info::set_auto_practice(bool value) {
  set_has_auto_practice();
  auto_practice_ = value;
}

// optional bool auto_comm_practice = 2 [default = true];
inline bool practice_info::has_auto_comm_practice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void practice_info::set_has_auto_comm_practice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void practice_info::clear_has_auto_comm_practice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void practice_info::clear_auto_comm_practice() {
  auto_comm_practice_ = true;
  clear_has_auto_comm_practice();
}
inline bool practice_info::auto_comm_practice() const {
  return auto_comm_practice_;
}
inline void practice_info::set_auto_comm_practice(bool value) {
  set_has_auto_comm_practice();
  auto_comm_practice_ = value;
}

// -------------------------------------------------------------------

// role_set_info

// repeated .client.shortcut_info si = 1;
inline int role_set_info::si_size() const {
  return si_.size();
}
inline void role_set_info::clear_si() {
  si_.Clear();
}
inline const ::client::shortcut_info& role_set_info::si(int index) const {
  return si_.Get(index);
}
inline ::client::shortcut_info* role_set_info::mutable_si(int index) {
  return si_.Mutable(index);
}
inline ::client::shortcut_info* role_set_info::add_si() {
  return si_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >&
role_set_info::si() const {
  return si_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::shortcut_info >*
role_set_info::mutable_si() {
  return &si_;
}

// optional .client.handup_info hi = 2;
inline bool role_set_info::has_hi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_set_info::set_has_hi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_set_info::clear_has_hi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_set_info::clear_hi() {
  if (hi_ != NULL) hi_->::client::handup_info::Clear();
  clear_has_hi();
}
inline const ::client::handup_info& role_set_info::hi() const {
  return hi_ != NULL ? *hi_ : *default_instance_->hi_;
}
inline ::client::handup_info* role_set_info::mutable_hi() {
  set_has_hi();
  if (hi_ == NULL) hi_ = new ::client::handup_info;
  return hi_;
}
inline ::client::handup_info* role_set_info::release_hi() {
  clear_has_hi();
  ::client::handup_info* temp = hi_;
  hi_ = NULL;
  return temp;
}
inline void role_set_info::set_allocated_hi(::client::handup_info* hi) {
  delete hi_;
  hi_ = hi;
  if (hi) {
    set_has_hi();
  } else {
    clear_has_hi();
  }
}

// optional .client.practice_info pi = 3;
inline bool role_set_info::has_pi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_set_info::set_has_pi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_set_info::clear_has_pi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_set_info::clear_pi() {
  if (pi_ != NULL) pi_->::client::practice_info::Clear();
  clear_has_pi();
}
inline const ::client::practice_info& role_set_info::pi() const {
  return pi_ != NULL ? *pi_ : *default_instance_->pi_;
}
inline ::client::practice_info* role_set_info::mutable_pi() {
  set_has_pi();
  if (pi_ == NULL) pi_ = new ::client::practice_info;
  return pi_;
}
inline ::client::practice_info* role_set_info::release_pi() {
  clear_has_pi();
  ::client::practice_info* temp = pi_;
  pi_ = NULL;
  return temp;
}
inline void role_set_info::set_allocated_pi(::client::practice_info* pi) {
  delete pi_;
  pi_ = pi;
  if (pi) {
    set_has_pi();
  } else {
    clear_has_pi();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2erole_5fset_2eproto__INCLUDED
