// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.role_status.proto

#ifndef PROTOBUF_client_2erole_5fstatus_2eproto__INCLUDED
#define PROTOBUF_client_2erole_5fstatus_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2erole_5fstatus_2eproto();
void protobuf_AssignDesc_client_2erole_5fstatus_2eproto();
void protobuf_ShutdownFile_client_2erole_5fstatus_2eproto();

class role_status;
class change_status;
class notify_kill_event;
class select_relive_type_req;
class select_relive_type_rsp;
class dark_zero_time;

enum role_status_pvp_status {
  role_status_pvp_status_pvp_kill = 0,
  role_status_pvp_status_pvp_prote = 1
};
bool role_status_pvp_status_IsValid(int value);
const role_status_pvp_status role_status_pvp_status_pvp_status_MIN = role_status_pvp_status_pvp_kill;
const role_status_pvp_status role_status_pvp_status_pvp_status_MAX = role_status_pvp_status_pvp_prote;
const int role_status_pvp_status_pvp_status_ARRAYSIZE = role_status_pvp_status_pvp_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* role_status_pvp_status_descriptor();
inline const ::std::string& role_status_pvp_status_Name(role_status_pvp_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    role_status_pvp_status_descriptor(), value);
}
inline bool role_status_pvp_status_Parse(
    const ::std::string& name, role_status_pvp_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<role_status_pvp_status>(
    role_status_pvp_status_descriptor(), name, value);
}
enum role_status_attack_mode {
  role_status_attack_mode_attack_mod_null = 0,
  role_status_attack_mode_attack_mod_peace = 1,
  role_status_attack_mode_attack_mod_team = 2,
  role_status_attack_mode_attack_mod_family = 3,
  role_status_attack_mode_attack_mod_all = 4,
  role_status_attack_mode_attack_mod_camp = 5,
  role_status_attack_mode_attack_mod_invalid = 6
};
bool role_status_attack_mode_IsValid(int value);
const role_status_attack_mode role_status_attack_mode_attack_mode_MIN = role_status_attack_mode_attack_mod_null;
const role_status_attack_mode role_status_attack_mode_attack_mode_MAX = role_status_attack_mode_attack_mod_invalid;
const int role_status_attack_mode_attack_mode_ARRAYSIZE = role_status_attack_mode_attack_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* role_status_attack_mode_descriptor();
inline const ::std::string& role_status_attack_mode_Name(role_status_attack_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    role_status_attack_mode_descriptor(), value);
}
inline bool role_status_attack_mode_Parse(
    const ::std::string& name, role_status_attack_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<role_status_attack_mode>(
    role_status_attack_mode_descriptor(), name, value);
}
enum role_status_alive_status {
  role_status_alive_status_status_alive = 1,
  role_status_alive_status_status_dead = 2
};
bool role_status_alive_status_IsValid(int value);
const role_status_alive_status role_status_alive_status_alive_status_MIN = role_status_alive_status_status_alive;
const role_status_alive_status role_status_alive_status_alive_status_MAX = role_status_alive_status_status_dead;
const int role_status_alive_status_alive_status_ARRAYSIZE = role_status_alive_status_alive_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* role_status_alive_status_descriptor();
inline const ::std::string& role_status_alive_status_Name(role_status_alive_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    role_status_alive_status_descriptor(), value);
}
inline bool role_status_alive_status_Parse(
    const ::std::string& name, role_status_alive_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<role_status_alive_status>(
    role_status_alive_status_descriptor(), name, value);
}
enum role_status_riding_status {
  role_status_riding_status_status_walk = 0,
  role_status_riding_status_status_riding = 1,
  role_status_riding_status_status_fly = 2
};
bool role_status_riding_status_IsValid(int value);
const role_status_riding_status role_status_riding_status_riding_status_MIN = role_status_riding_status_status_walk;
const role_status_riding_status role_status_riding_status_riding_status_MAX = role_status_riding_status_status_fly;
const int role_status_riding_status_riding_status_ARRAYSIZE = role_status_riding_status_riding_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* role_status_riding_status_descriptor();
inline const ::std::string& role_status_riding_status_Name(role_status_riding_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    role_status_riding_status_descriptor(), value);
}
inline bool role_status_riding_status_Parse(
    const ::std::string& name, role_status_riding_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<role_status_riding_status>(
    role_status_riding_status_descriptor(), name, value);
}
enum select_relive_type_req_TYPE {
  select_relive_type_req_TYPE_SITU = 0,
  select_relive_type_req_TYPE_CHECK_POINT = 1,
  select_relive_type_req_TYPE_MAIN_CITY = 2,
  select_relive_type_req_TYPE_BIRTH_POINT = 3,
  select_relive_type_req_TYPE_SAFE_ZONE = 4
};
bool select_relive_type_req_TYPE_IsValid(int value);
const select_relive_type_req_TYPE select_relive_type_req_TYPE_TYPE_MIN = select_relive_type_req_TYPE_SITU;
const select_relive_type_req_TYPE select_relive_type_req_TYPE_TYPE_MAX = select_relive_type_req_TYPE_SAFE_ZONE;
const int select_relive_type_req_TYPE_TYPE_ARRAYSIZE = select_relive_type_req_TYPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* select_relive_type_req_TYPE_descriptor();
inline const ::std::string& select_relive_type_req_TYPE_Name(select_relive_type_req_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    select_relive_type_req_TYPE_descriptor(), value);
}
inline bool select_relive_type_req_TYPE_Parse(
    const ::std::string& name, select_relive_type_req_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<select_relive_type_req_TYPE>(
    select_relive_type_req_TYPE_descriptor(), name, value);
}
enum select_relive_type_rsp_RET {
  select_relive_type_rsp_RET_SUCCESS = 0,
  select_relive_type_rsp_RET_PROPS_LIMIT = 1,
  select_relive_type_rsp_RET_MONEY_LIMIT = 2,
  select_relive_type_rsp_RET_CONFIG_ERROR = 3
};
bool select_relive_type_rsp_RET_IsValid(int value);
const select_relive_type_rsp_RET select_relive_type_rsp_RET_RET_MIN = select_relive_type_rsp_RET_SUCCESS;
const select_relive_type_rsp_RET select_relive_type_rsp_RET_RET_MAX = select_relive_type_rsp_RET_CONFIG_ERROR;
const int select_relive_type_rsp_RET_RET_ARRAYSIZE = select_relive_type_rsp_RET_RET_MAX + 1;

const ::google::protobuf::EnumDescriptor* select_relive_type_rsp_RET_descriptor();
inline const ::std::string& select_relive_type_rsp_RET_Name(select_relive_type_rsp_RET value) {
  return ::google::protobuf::internal::NameOfEnum(
    select_relive_type_rsp_RET_descriptor(), value);
}
inline bool select_relive_type_rsp_RET_Parse(
    const ::std::string& name, select_relive_type_rsp_RET* value) {
  return ::google::protobuf::internal::ParseNamedEnum<select_relive_type_rsp_RET>(
    select_relive_type_rsp_RET_descriptor(), name, value);
}
enum ROLE_STATUS_E {
  RSE_STATUS_MEDITATE = 0,
  RSE_STATUS_AUTOPATH = 1,
  RSE_STATUS_FIGHT = 2,
  RSE_STATUS_ROBOT = 3,
  RSE_STATUS_PVP = 4,
  RSE_STATUS_ONLINE = 5,
  RSE_STATUS_ATTKMODE = 6,
  RSE_STATUS_ALIVE = 7,
  RSE_STATUS_RIDING = 8,
  RSE_STATUS_FURIOUS = 9,
  RSE_STATUS_HURTED = 10,
  RSE_STATUS_WEEK = 11,
  RSE_STATUS_GIDDY = 12,
  RSE_STATUS_FAINT = 13,
  RSE_STATUS_FIRED = 14,
  RSE_STATUS_POSION = 15,
  RSE_STATUS_BLOOD = 16,
  RSE_STATUS_INJURY = 17,
  RSE_STATUS_CURSED = 18,
  RSE_STATUS_BLIND = 19,
  RSE_STATUS_MAIMED = 20,
  RSE_STATUS_SILENT = 21,
  RSE_STATUS_DISARM = 22,
  RSE_STATUS_SLOWLY = 23,
  RSE_STATUS_DEC_HARM = 24,
  RSE_STATUS_REJ_HARM = 25,
  RSE_STATUS_STREANTH = 26,
  RSE_STATUS_BODY = 27,
  RSE_STATUS_GUARD = 28,
  RSE_STATUS_COMM_PRACTICE = 29,
  RSE_STATUS_MAX = 30
};
bool ROLE_STATUS_E_IsValid(int value);
const ROLE_STATUS_E ROLE_STATUS_E_MIN = RSE_STATUS_MEDITATE;
const ROLE_STATUS_E ROLE_STATUS_E_MAX = RSE_STATUS_MAX;
const int ROLE_STATUS_E_ARRAYSIZE = ROLE_STATUS_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROLE_STATUS_E_descriptor();
inline const ::std::string& ROLE_STATUS_E_Name(ROLE_STATUS_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROLE_STATUS_E_descriptor(), value);
}
inline bool ROLE_STATUS_E_Parse(
    const ::std::string& name, ROLE_STATUS_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROLE_STATUS_E>(
    ROLE_STATUS_E_descriptor(), name, value);
}
// ===================================================================

class role_status : public ::google::protobuf::Message {
 public:
  role_status();
  virtual ~role_status();

  role_status(const role_status& from);

  inline role_status& operator=(const role_status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_status& default_instance();

  void Swap(role_status* other);

  // implements Message ----------------------------------------------

  role_status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_status& from);
  void MergeFrom(const role_status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef role_status_pvp_status pvp_status;
  static const pvp_status pvp_kill = role_status_pvp_status_pvp_kill;
  static const pvp_status pvp_prote = role_status_pvp_status_pvp_prote;
  static inline bool pvp_status_IsValid(int value) {
    return role_status_pvp_status_IsValid(value);
  }
  static const pvp_status pvp_status_MIN =
    role_status_pvp_status_pvp_status_MIN;
  static const pvp_status pvp_status_MAX =
    role_status_pvp_status_pvp_status_MAX;
  static const int pvp_status_ARRAYSIZE =
    role_status_pvp_status_pvp_status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  pvp_status_descriptor() {
    return role_status_pvp_status_descriptor();
  }
  static inline const ::std::string& pvp_status_Name(pvp_status value) {
    return role_status_pvp_status_Name(value);
  }
  static inline bool pvp_status_Parse(const ::std::string& name,
      pvp_status* value) {
    return role_status_pvp_status_Parse(name, value);
  }

  typedef role_status_attack_mode attack_mode;
  static const attack_mode attack_mod_null = role_status_attack_mode_attack_mod_null;
  static const attack_mode attack_mod_peace = role_status_attack_mode_attack_mod_peace;
  static const attack_mode attack_mod_team = role_status_attack_mode_attack_mod_team;
  static const attack_mode attack_mod_family = role_status_attack_mode_attack_mod_family;
  static const attack_mode attack_mod_all = role_status_attack_mode_attack_mod_all;
  static const attack_mode attack_mod_camp = role_status_attack_mode_attack_mod_camp;
  static const attack_mode attack_mod_invalid = role_status_attack_mode_attack_mod_invalid;
  static inline bool attack_mode_IsValid(int value) {
    return role_status_attack_mode_IsValid(value);
  }
  static const attack_mode attack_mode_MIN =
    role_status_attack_mode_attack_mode_MIN;
  static const attack_mode attack_mode_MAX =
    role_status_attack_mode_attack_mode_MAX;
  static const int attack_mode_ARRAYSIZE =
    role_status_attack_mode_attack_mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  attack_mode_descriptor() {
    return role_status_attack_mode_descriptor();
  }
  static inline const ::std::string& attack_mode_Name(attack_mode value) {
    return role_status_attack_mode_Name(value);
  }
  static inline bool attack_mode_Parse(const ::std::string& name,
      attack_mode* value) {
    return role_status_attack_mode_Parse(name, value);
  }

  typedef role_status_alive_status alive_status;
  static const alive_status status_alive = role_status_alive_status_status_alive;
  static const alive_status status_dead = role_status_alive_status_status_dead;
  static inline bool alive_status_IsValid(int value) {
    return role_status_alive_status_IsValid(value);
  }
  static const alive_status alive_status_MIN =
    role_status_alive_status_alive_status_MIN;
  static const alive_status alive_status_MAX =
    role_status_alive_status_alive_status_MAX;
  static const int alive_status_ARRAYSIZE =
    role_status_alive_status_alive_status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  alive_status_descriptor() {
    return role_status_alive_status_descriptor();
  }
  static inline const ::std::string& alive_status_Name(alive_status value) {
    return role_status_alive_status_Name(value);
  }
  static inline bool alive_status_Parse(const ::std::string& name,
      alive_status* value) {
    return role_status_alive_status_Parse(name, value);
  }

  typedef role_status_riding_status riding_status;
  static const riding_status status_walk = role_status_riding_status_status_walk;
  static const riding_status status_riding = role_status_riding_status_status_riding;
  static const riding_status status_fly = role_status_riding_status_status_fly;
  static inline bool riding_status_IsValid(int value) {
    return role_status_riding_status_IsValid(value);
  }
  static const riding_status riding_status_MIN =
    role_status_riding_status_riding_status_MIN;
  static const riding_status riding_status_MAX =
    role_status_riding_status_riding_status_MAX;
  static const int riding_status_ARRAYSIZE =
    role_status_riding_status_riding_status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  riding_status_descriptor() {
    return role_status_riding_status_descriptor();
  }
  static inline const ::std::string& riding_status_Name(riding_status value) {
    return role_status_riding_status_Name(value);
  }
  static inline bool riding_status_Parse(const ::std::string& name,
      riding_status* value) {
    return role_status_riding_status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool meditate = 1 [default = false];
  inline bool has_meditate() const;
  inline void clear_meditate();
  static const int kMeditateFieldNumber = 1;
  inline bool meditate() const;
  inline void set_meditate(bool value);

  // optional bool autopath = 2 [default = false];
  inline bool has_autopath() const;
  inline void clear_autopath();
  static const int kAutopathFieldNumber = 2;
  inline bool autopath() const;
  inline void set_autopath(bool value);

  // optional bool fight = 3 [default = false];
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 3;
  inline bool fight() const;
  inline void set_fight(bool value);

  // optional bool robot = 4 [default = false];
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 4;
  inline bool robot() const;
  inline void set_robot(bool value);

  // optional .client.role_status.pvp_status pvp = 5 [default = pvp_prote];
  inline bool has_pvp() const;
  inline void clear_pvp();
  static const int kPvpFieldNumber = 5;
  inline ::client::role_status_pvp_status pvp() const;
  inline void set_pvp(::client::role_status_pvp_status value);

  // optional bool online = 6 [default = false];
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 6;
  inline bool online() const;
  inline void set_online(bool value);

  // optional .client.role_status.attack_mode atk_mode = 7 [default = attack_mod_null];
  inline bool has_atk_mode() const;
  inline void clear_atk_mode();
  static const int kAtkModeFieldNumber = 7;
  inline ::client::role_status_attack_mode atk_mode() const;
  inline void set_atk_mode(::client::role_status_attack_mode value);

  // optional .client.role_status.alive_status alive = 8 [default = status_alive];
  inline bool has_alive() const;
  inline void clear_alive();
  static const int kAliveFieldNumber = 8;
  inline ::client::role_status_alive_status alive() const;
  inline void set_alive(::client::role_status_alive_status value);

  // optional .client.role_status.riding_status riding = 9 [default = status_walk];
  inline bool has_riding() const;
  inline void clear_riding();
  static const int kRidingFieldNumber = 9;
  inline ::client::role_status_riding_status riding() const;
  inline void set_riding(::client::role_status_riding_status value);

  // optional bool furious = 10 [default = false];
  inline bool has_furious() const;
  inline void clear_furious();
  static const int kFuriousFieldNumber = 10;
  inline bool furious() const;
  inline void set_furious(bool value);

  // optional bool hurted = 11 [default = false];
  inline bool has_hurted() const;
  inline void clear_hurted();
  static const int kHurtedFieldNumber = 11;
  inline bool hurted() const;
  inline void set_hurted(bool value);

  // optional bool week = 12 [default = false];
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 12;
  inline bool week() const;
  inline void set_week(bool value);

  // optional bool giddy = 13 [default = false];
  inline bool has_giddy() const;
  inline void clear_giddy();
  static const int kGiddyFieldNumber = 13;
  inline bool giddy() const;
  inline void set_giddy(bool value);

  // optional bool faint = 14 [default = false];
  inline bool has_faint() const;
  inline void clear_faint();
  static const int kFaintFieldNumber = 14;
  inline bool faint() const;
  inline void set_faint(bool value);

  // optional bool fired = 15 [default = false];
  inline bool has_fired() const;
  inline void clear_fired();
  static const int kFiredFieldNumber = 15;
  inline bool fired() const;
  inline void set_fired(bool value);

  // optional bool posion = 16 [default = false];
  inline bool has_posion() const;
  inline void clear_posion();
  static const int kPosionFieldNumber = 16;
  inline bool posion() const;
  inline void set_posion(bool value);

  // optional bool blood = 17 [default = false];
  inline bool has_blood() const;
  inline void clear_blood();
  static const int kBloodFieldNumber = 17;
  inline bool blood() const;
  inline void set_blood(bool value);

  // optional bool injury = 18 [default = false];
  inline bool has_injury() const;
  inline void clear_injury();
  static const int kInjuryFieldNumber = 18;
  inline bool injury() const;
  inline void set_injury(bool value);

  // optional bool cursed = 19 [default = false];
  inline bool has_cursed() const;
  inline void clear_cursed();
  static const int kCursedFieldNumber = 19;
  inline bool cursed() const;
  inline void set_cursed(bool value);

  // optional bool blind = 20 [default = false];
  inline bool has_blind() const;
  inline void clear_blind();
  static const int kBlindFieldNumber = 20;
  inline bool blind() const;
  inline void set_blind(bool value);

  // optional bool maimed = 21 [default = false];
  inline bool has_maimed() const;
  inline void clear_maimed();
  static const int kMaimedFieldNumber = 21;
  inline bool maimed() const;
  inline void set_maimed(bool value);

  // optional bool silent = 22 [default = false];
  inline bool has_silent() const;
  inline void clear_silent();
  static const int kSilentFieldNumber = 22;
  inline bool silent() const;
  inline void set_silent(bool value);

  // optional bool disarm = 23 [default = false];
  inline bool has_disarm() const;
  inline void clear_disarm();
  static const int kDisarmFieldNumber = 23;
  inline bool disarm() const;
  inline void set_disarm(bool value);

  // optional bool slowly = 24 [default = false];
  inline bool has_slowly() const;
  inline void clear_slowly();
  static const int kSlowlyFieldNumber = 24;
  inline bool slowly() const;
  inline void set_slowly(bool value);

  // optional bool dec_harm = 25 [default = false];
  inline bool has_dec_harm() const;
  inline void clear_dec_harm();
  static const int kDecHarmFieldNumber = 25;
  inline bool dec_harm() const;
  inline void set_dec_harm(bool value);

  // optional bool rej_harm = 26 [default = false];
  inline bool has_rej_harm() const;
  inline void clear_rej_harm();
  static const int kRejHarmFieldNumber = 26;
  inline bool rej_harm() const;
  inline void set_rej_harm(bool value);

  // optional bool streanth = 27 [default = false];
  inline bool has_streanth() const;
  inline void clear_streanth();
  static const int kStreanthFieldNumber = 27;
  inline bool streanth() const;
  inline void set_streanth(bool value);

  // optional bool body = 28 [default = false];
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 28;
  inline bool body() const;
  inline void set_body(bool value);

  // optional uint32 guard = 29 [default = 0];
  inline bool has_guard() const;
  inline void clear_guard();
  static const int kGuardFieldNumber = 29;
  inline ::google::protobuf::uint32 guard() const;
  inline void set_guard(::google::protobuf::uint32 value);

  // optional bool comm_practice = 30 [default = false];
  inline bool has_comm_practice() const;
  inline void clear_comm_practice();
  static const int kCommPracticeFieldNumber = 30;
  inline bool comm_practice() const;
  inline void set_comm_practice(bool value);

  // @@protoc_insertion_point(class_scope:client.role_status)
 private:
  inline void set_has_meditate();
  inline void clear_has_meditate();
  inline void set_has_autopath();
  inline void clear_has_autopath();
  inline void set_has_fight();
  inline void clear_has_fight();
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_pvp();
  inline void clear_has_pvp();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_atk_mode();
  inline void clear_has_atk_mode();
  inline void set_has_alive();
  inline void clear_has_alive();
  inline void set_has_riding();
  inline void clear_has_riding();
  inline void set_has_furious();
  inline void clear_has_furious();
  inline void set_has_hurted();
  inline void clear_has_hurted();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_giddy();
  inline void clear_has_giddy();
  inline void set_has_faint();
  inline void clear_has_faint();
  inline void set_has_fired();
  inline void clear_has_fired();
  inline void set_has_posion();
  inline void clear_has_posion();
  inline void set_has_blood();
  inline void clear_has_blood();
  inline void set_has_injury();
  inline void clear_has_injury();
  inline void set_has_cursed();
  inline void clear_has_cursed();
  inline void set_has_blind();
  inline void clear_has_blind();
  inline void set_has_maimed();
  inline void clear_has_maimed();
  inline void set_has_silent();
  inline void clear_has_silent();
  inline void set_has_disarm();
  inline void clear_has_disarm();
  inline void set_has_slowly();
  inline void clear_has_slowly();
  inline void set_has_dec_harm();
  inline void clear_has_dec_harm();
  inline void set_has_rej_harm();
  inline void clear_has_rej_harm();
  inline void set_has_streanth();
  inline void clear_has_streanth();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_guard();
  inline void clear_has_guard();
  inline void set_has_comm_practice();
  inline void clear_has_comm_practice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool meditate_;
  bool autopath_;
  bool fight_;
  bool robot_;
  int pvp_;
  int atk_mode_;
  int alive_;
  int riding_;
  bool online_;
  bool furious_;
  bool hurted_;
  bool week_;
  bool giddy_;
  bool faint_;
  bool fired_;
  bool posion_;
  bool blood_;
  bool injury_;
  bool cursed_;
  bool blind_;
  bool maimed_;
  bool silent_;
  bool disarm_;
  bool slowly_;
  bool dec_harm_;
  bool rej_harm_;
  bool streanth_;
  bool body_;
  ::google::protobuf::uint32 guard_;
  bool comm_practice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static role_status* default_instance_;
};
// -------------------------------------------------------------------

class change_status : public ::google::protobuf::Message {
 public:
  change_status();
  virtual ~change_status();

  change_status(const change_status& from);

  inline change_status& operator=(const change_status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const change_status& default_instance();

  void Swap(change_status* other);

  // implements Message ----------------------------------------------

  change_status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const change_status& from);
  void MergeFrom(const change_status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_status rs = 1;
  inline bool has_rs() const;
  inline void clear_rs();
  static const int kRsFieldNumber = 1;
  inline const ::client::role_status& rs() const;
  inline ::client::role_status* mutable_rs();
  inline ::client::role_status* release_rs();
  inline void set_allocated_rs(::client::role_status* rs);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.change_status)
 private:
  inline void set_has_rs();
  inline void clear_has_rs();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_status* rs_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static change_status* default_instance_;
};
// -------------------------------------------------------------------

class notify_kill_event : public ::google::protobuf::Message {
 public:
  notify_kill_event();
  virtual ~notify_kill_event();

  notify_kill_event(const notify_kill_event& from);

  inline notify_kill_event& operator=(const notify_kill_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const notify_kill_event& default_instance();

  void Swap(notify_kill_event* other);

  // implements Message ----------------------------------------------

  notify_kill_event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const notify_kill_event& from);
  void MergeFrom(const notify_kill_event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_data dead = 1;
  inline bool has_dead() const;
  inline void clear_dead();
  static const int kDeadFieldNumber = 1;
  inline const ::client::role_data& dead() const;
  inline ::client::role_data* mutable_dead();
  inline ::client::role_data* release_dead();
  inline void set_allocated_dead(::client::role_data* dead);

  // required .client.role_data killer = 2;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 2;
  inline const ::client::role_data& killer() const;
  inline ::client::role_data* mutable_killer();
  inline ::client::role_data* release_killer();
  inline void set_allocated_killer(::client::role_data* killer);

  // optional uint32 dead_lose_factor = 3;
  inline bool has_dead_lose_factor() const;
  inline void clear_dead_lose_factor();
  static const int kDeadLoseFactorFieldNumber = 3;
  inline ::google::protobuf::uint32 dead_lose_factor() const;
  inline void set_dead_lose_factor(::google::protobuf::uint32 value);

  // optional uint32 killer_got_factor = 4;
  inline bool has_killer_got_factor() const;
  inline void clear_killer_got_factor();
  static const int kKillerGotFactorFieldNumber = 4;
  inline ::google::protobuf::uint32 killer_got_factor() const;
  inline void set_killer_got_factor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.notify_kill_event)
 private:
  inline void set_has_dead();
  inline void clear_has_dead();
  inline void set_has_killer();
  inline void clear_has_killer();
  inline void set_has_dead_lose_factor();
  inline void clear_has_dead_lose_factor();
  inline void set_has_killer_got_factor();
  inline void clear_has_killer_got_factor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_data* dead_;
  ::client::role_data* killer_;
  ::google::protobuf::uint32 dead_lose_factor_;
  ::google::protobuf::uint32 killer_got_factor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static notify_kill_event* default_instance_;
};
// -------------------------------------------------------------------

class select_relive_type_req : public ::google::protobuf::Message {
 public:
  select_relive_type_req();
  virtual ~select_relive_type_req();

  select_relive_type_req(const select_relive_type_req& from);

  inline select_relive_type_req& operator=(const select_relive_type_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const select_relive_type_req& default_instance();

  void Swap(select_relive_type_req* other);

  // implements Message ----------------------------------------------

  select_relive_type_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const select_relive_type_req& from);
  void MergeFrom(const select_relive_type_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef select_relive_type_req_TYPE TYPE;
  static const TYPE SITU = select_relive_type_req_TYPE_SITU;
  static const TYPE CHECK_POINT = select_relive_type_req_TYPE_CHECK_POINT;
  static const TYPE MAIN_CITY = select_relive_type_req_TYPE_MAIN_CITY;
  static const TYPE BIRTH_POINT = select_relive_type_req_TYPE_BIRTH_POINT;
  static const TYPE SAFE_ZONE = select_relive_type_req_TYPE_SAFE_ZONE;
  static inline bool TYPE_IsValid(int value) {
    return select_relive_type_req_TYPE_IsValid(value);
  }
  static const TYPE TYPE_MIN =
    select_relive_type_req_TYPE_TYPE_MIN;
  static const TYPE TYPE_MAX =
    select_relive_type_req_TYPE_TYPE_MAX;
  static const int TYPE_ARRAYSIZE =
    select_relive_type_req_TYPE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TYPE_descriptor() {
    return select_relive_type_req_TYPE_descriptor();
  }
  static inline const ::std::string& TYPE_Name(TYPE value) {
    return select_relive_type_req_TYPE_Name(value);
  }
  static inline bool TYPE_Parse(const ::std::string& name,
      TYPE* value) {
    return select_relive_type_req_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.select_relive_type_req.TYPE type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::client::select_relive_type_req_TYPE type() const;
  inline void set_type(::client::select_relive_type_req_TYPE value);

  // optional bool auto_buy = 2;
  inline bool has_auto_buy() const;
  inline void clear_auto_buy();
  static const int kAutoBuyFieldNumber = 2;
  inline bool auto_buy() const;
  inline void set_auto_buy(bool value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.select_relive_type_req)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_auto_buy();
  inline void clear_has_auto_buy();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  bool auto_buy_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static select_relive_type_req* default_instance_;
};
// -------------------------------------------------------------------

class select_relive_type_rsp : public ::google::protobuf::Message {
 public:
  select_relive_type_rsp();
  virtual ~select_relive_type_rsp();

  select_relive_type_rsp(const select_relive_type_rsp& from);

  inline select_relive_type_rsp& operator=(const select_relive_type_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const select_relive_type_rsp& default_instance();

  void Swap(select_relive_type_rsp* other);

  // implements Message ----------------------------------------------

  select_relive_type_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const select_relive_type_rsp& from);
  void MergeFrom(const select_relive_type_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef select_relive_type_rsp_RET RET;
  static const RET SUCCESS = select_relive_type_rsp_RET_SUCCESS;
  static const RET PROPS_LIMIT = select_relive_type_rsp_RET_PROPS_LIMIT;
  static const RET MONEY_LIMIT = select_relive_type_rsp_RET_MONEY_LIMIT;
  static const RET CONFIG_ERROR = select_relive_type_rsp_RET_CONFIG_ERROR;
  static inline bool RET_IsValid(int value) {
    return select_relive_type_rsp_RET_IsValid(value);
  }
  static const RET RET_MIN =
    select_relive_type_rsp_RET_RET_MIN;
  static const RET RET_MAX =
    select_relive_type_rsp_RET_RET_MAX;
  static const int RET_ARRAYSIZE =
    select_relive_type_rsp_RET_RET_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RET_descriptor() {
    return select_relive_type_rsp_RET_descriptor();
  }
  static inline const ::std::string& RET_Name(RET value) {
    return select_relive_type_rsp_RET_Name(value);
  }
  static inline bool RET_Parse(const ::std::string& name,
      RET* value) {
    return select_relive_type_rsp_RET_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.select_relive_type_rsp.RET ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::client::select_relive_type_rsp_RET ret() const;
  inline void set_ret(::client::select_relive_type_rsp_RET value);

  // @@protoc_insertion_point(class_scope:client.select_relive_type_rsp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static select_relive_type_rsp* default_instance_;
};
// -------------------------------------------------------------------

class dark_zero_time : public ::google::protobuf::Message {
 public:
  dark_zero_time();
  virtual ~dark_zero_time();

  dark_zero_time(const dark_zero_time& from);

  inline dark_zero_time& operator=(const dark_zero_time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dark_zero_time& default_instance();

  void Swap(dark_zero_time* other);

  // implements Message ----------------------------------------------

  dark_zero_time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dark_zero_time& from);
  void MergeFrom(const dark_zero_time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unixtime = 1;
  inline bool has_unixtime() const;
  inline void clear_unixtime();
  static const int kUnixtimeFieldNumber = 1;
  inline ::google::protobuf::uint32 unixtime() const;
  inline void set_unixtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.dark_zero_time)
 private:
  inline void set_has_unixtime();
  inline void clear_has_unixtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 unixtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_AssignDesc_client_2erole_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_client_2erole_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static dark_zero_time* default_instance_;
};
// ===================================================================


// ===================================================================

// role_status

// optional bool meditate = 1 [default = false];
inline bool role_status::has_meditate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_status::set_has_meditate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_status::clear_has_meditate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_status::clear_meditate() {
  meditate_ = false;
  clear_has_meditate();
}
inline bool role_status::meditate() const {
  return meditate_;
}
inline void role_status::set_meditate(bool value) {
  set_has_meditate();
  meditate_ = value;
}

// optional bool autopath = 2 [default = false];
inline bool role_status::has_autopath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_status::set_has_autopath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_status::clear_has_autopath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_status::clear_autopath() {
  autopath_ = false;
  clear_has_autopath();
}
inline bool role_status::autopath() const {
  return autopath_;
}
inline void role_status::set_autopath(bool value) {
  set_has_autopath();
  autopath_ = value;
}

// optional bool fight = 3 [default = false];
inline bool role_status::has_fight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_status::set_has_fight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_status::clear_has_fight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_status::clear_fight() {
  fight_ = false;
  clear_has_fight();
}
inline bool role_status::fight() const {
  return fight_;
}
inline void role_status::set_fight(bool value) {
  set_has_fight();
  fight_ = value;
}

// optional bool robot = 4 [default = false];
inline bool role_status::has_robot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_status::set_has_robot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_status::clear_has_robot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_status::clear_robot() {
  robot_ = false;
  clear_has_robot();
}
inline bool role_status::robot() const {
  return robot_;
}
inline void role_status::set_robot(bool value) {
  set_has_robot();
  robot_ = value;
}

// optional .client.role_status.pvp_status pvp = 5 [default = pvp_prote];
inline bool role_status::has_pvp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_status::set_has_pvp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_status::clear_has_pvp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_status::clear_pvp() {
  pvp_ = 1;
  clear_has_pvp();
}
inline ::client::role_status_pvp_status role_status::pvp() const {
  return static_cast< ::client::role_status_pvp_status >(pvp_);
}
inline void role_status::set_pvp(::client::role_status_pvp_status value) {
  assert(::client::role_status_pvp_status_IsValid(value));
  set_has_pvp();
  pvp_ = value;
}

// optional bool online = 6 [default = false];
inline bool role_status::has_online() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_status::set_has_online() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_status::clear_has_online() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_status::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool role_status::online() const {
  return online_;
}
inline void role_status::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional .client.role_status.attack_mode atk_mode = 7 [default = attack_mod_null];
inline bool role_status::has_atk_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_status::set_has_atk_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_status::clear_has_atk_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_status::clear_atk_mode() {
  atk_mode_ = 0;
  clear_has_atk_mode();
}
inline ::client::role_status_attack_mode role_status::atk_mode() const {
  return static_cast< ::client::role_status_attack_mode >(atk_mode_);
}
inline void role_status::set_atk_mode(::client::role_status_attack_mode value) {
  assert(::client::role_status_attack_mode_IsValid(value));
  set_has_atk_mode();
  atk_mode_ = value;
}

// optional .client.role_status.alive_status alive = 8 [default = status_alive];
inline bool role_status::has_alive() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void role_status::set_has_alive() {
  _has_bits_[0] |= 0x00000080u;
}
inline void role_status::clear_has_alive() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void role_status::clear_alive() {
  alive_ = 1;
  clear_has_alive();
}
inline ::client::role_status_alive_status role_status::alive() const {
  return static_cast< ::client::role_status_alive_status >(alive_);
}
inline void role_status::set_alive(::client::role_status_alive_status value) {
  assert(::client::role_status_alive_status_IsValid(value));
  set_has_alive();
  alive_ = value;
}

// optional .client.role_status.riding_status riding = 9 [default = status_walk];
inline bool role_status::has_riding() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void role_status::set_has_riding() {
  _has_bits_[0] |= 0x00000100u;
}
inline void role_status::clear_has_riding() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void role_status::clear_riding() {
  riding_ = 0;
  clear_has_riding();
}
inline ::client::role_status_riding_status role_status::riding() const {
  return static_cast< ::client::role_status_riding_status >(riding_);
}
inline void role_status::set_riding(::client::role_status_riding_status value) {
  assert(::client::role_status_riding_status_IsValid(value));
  set_has_riding();
  riding_ = value;
}

// optional bool furious = 10 [default = false];
inline bool role_status::has_furious() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void role_status::set_has_furious() {
  _has_bits_[0] |= 0x00000200u;
}
inline void role_status::clear_has_furious() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void role_status::clear_furious() {
  furious_ = false;
  clear_has_furious();
}
inline bool role_status::furious() const {
  return furious_;
}
inline void role_status::set_furious(bool value) {
  set_has_furious();
  furious_ = value;
}

// optional bool hurted = 11 [default = false];
inline bool role_status::has_hurted() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void role_status::set_has_hurted() {
  _has_bits_[0] |= 0x00000400u;
}
inline void role_status::clear_has_hurted() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void role_status::clear_hurted() {
  hurted_ = false;
  clear_has_hurted();
}
inline bool role_status::hurted() const {
  return hurted_;
}
inline void role_status::set_hurted(bool value) {
  set_has_hurted();
  hurted_ = value;
}

// optional bool week = 12 [default = false];
inline bool role_status::has_week() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void role_status::set_has_week() {
  _has_bits_[0] |= 0x00000800u;
}
inline void role_status::clear_has_week() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void role_status::clear_week() {
  week_ = false;
  clear_has_week();
}
inline bool role_status::week() const {
  return week_;
}
inline void role_status::set_week(bool value) {
  set_has_week();
  week_ = value;
}

// optional bool giddy = 13 [default = false];
inline bool role_status::has_giddy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void role_status::set_has_giddy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void role_status::clear_has_giddy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void role_status::clear_giddy() {
  giddy_ = false;
  clear_has_giddy();
}
inline bool role_status::giddy() const {
  return giddy_;
}
inline void role_status::set_giddy(bool value) {
  set_has_giddy();
  giddy_ = value;
}

// optional bool faint = 14 [default = false];
inline bool role_status::has_faint() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void role_status::set_has_faint() {
  _has_bits_[0] |= 0x00002000u;
}
inline void role_status::clear_has_faint() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void role_status::clear_faint() {
  faint_ = false;
  clear_has_faint();
}
inline bool role_status::faint() const {
  return faint_;
}
inline void role_status::set_faint(bool value) {
  set_has_faint();
  faint_ = value;
}

// optional bool fired = 15 [default = false];
inline bool role_status::has_fired() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void role_status::set_has_fired() {
  _has_bits_[0] |= 0x00004000u;
}
inline void role_status::clear_has_fired() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void role_status::clear_fired() {
  fired_ = false;
  clear_has_fired();
}
inline bool role_status::fired() const {
  return fired_;
}
inline void role_status::set_fired(bool value) {
  set_has_fired();
  fired_ = value;
}

// optional bool posion = 16 [default = false];
inline bool role_status::has_posion() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void role_status::set_has_posion() {
  _has_bits_[0] |= 0x00008000u;
}
inline void role_status::clear_has_posion() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void role_status::clear_posion() {
  posion_ = false;
  clear_has_posion();
}
inline bool role_status::posion() const {
  return posion_;
}
inline void role_status::set_posion(bool value) {
  set_has_posion();
  posion_ = value;
}

// optional bool blood = 17 [default = false];
inline bool role_status::has_blood() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void role_status::set_has_blood() {
  _has_bits_[0] |= 0x00010000u;
}
inline void role_status::clear_has_blood() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void role_status::clear_blood() {
  blood_ = false;
  clear_has_blood();
}
inline bool role_status::blood() const {
  return blood_;
}
inline void role_status::set_blood(bool value) {
  set_has_blood();
  blood_ = value;
}

// optional bool injury = 18 [default = false];
inline bool role_status::has_injury() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void role_status::set_has_injury() {
  _has_bits_[0] |= 0x00020000u;
}
inline void role_status::clear_has_injury() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void role_status::clear_injury() {
  injury_ = false;
  clear_has_injury();
}
inline bool role_status::injury() const {
  return injury_;
}
inline void role_status::set_injury(bool value) {
  set_has_injury();
  injury_ = value;
}

// optional bool cursed = 19 [default = false];
inline bool role_status::has_cursed() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void role_status::set_has_cursed() {
  _has_bits_[0] |= 0x00040000u;
}
inline void role_status::clear_has_cursed() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void role_status::clear_cursed() {
  cursed_ = false;
  clear_has_cursed();
}
inline bool role_status::cursed() const {
  return cursed_;
}
inline void role_status::set_cursed(bool value) {
  set_has_cursed();
  cursed_ = value;
}

// optional bool blind = 20 [default = false];
inline bool role_status::has_blind() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void role_status::set_has_blind() {
  _has_bits_[0] |= 0x00080000u;
}
inline void role_status::clear_has_blind() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void role_status::clear_blind() {
  blind_ = false;
  clear_has_blind();
}
inline bool role_status::blind() const {
  return blind_;
}
inline void role_status::set_blind(bool value) {
  set_has_blind();
  blind_ = value;
}

// optional bool maimed = 21 [default = false];
inline bool role_status::has_maimed() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void role_status::set_has_maimed() {
  _has_bits_[0] |= 0x00100000u;
}
inline void role_status::clear_has_maimed() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void role_status::clear_maimed() {
  maimed_ = false;
  clear_has_maimed();
}
inline bool role_status::maimed() const {
  return maimed_;
}
inline void role_status::set_maimed(bool value) {
  set_has_maimed();
  maimed_ = value;
}

// optional bool silent = 22 [default = false];
inline bool role_status::has_silent() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void role_status::set_has_silent() {
  _has_bits_[0] |= 0x00200000u;
}
inline void role_status::clear_has_silent() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void role_status::clear_silent() {
  silent_ = false;
  clear_has_silent();
}
inline bool role_status::silent() const {
  return silent_;
}
inline void role_status::set_silent(bool value) {
  set_has_silent();
  silent_ = value;
}

// optional bool disarm = 23 [default = false];
inline bool role_status::has_disarm() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void role_status::set_has_disarm() {
  _has_bits_[0] |= 0x00400000u;
}
inline void role_status::clear_has_disarm() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void role_status::clear_disarm() {
  disarm_ = false;
  clear_has_disarm();
}
inline bool role_status::disarm() const {
  return disarm_;
}
inline void role_status::set_disarm(bool value) {
  set_has_disarm();
  disarm_ = value;
}

// optional bool slowly = 24 [default = false];
inline bool role_status::has_slowly() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void role_status::set_has_slowly() {
  _has_bits_[0] |= 0x00800000u;
}
inline void role_status::clear_has_slowly() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void role_status::clear_slowly() {
  slowly_ = false;
  clear_has_slowly();
}
inline bool role_status::slowly() const {
  return slowly_;
}
inline void role_status::set_slowly(bool value) {
  set_has_slowly();
  slowly_ = value;
}

// optional bool dec_harm = 25 [default = false];
inline bool role_status::has_dec_harm() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void role_status::set_has_dec_harm() {
  _has_bits_[0] |= 0x01000000u;
}
inline void role_status::clear_has_dec_harm() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void role_status::clear_dec_harm() {
  dec_harm_ = false;
  clear_has_dec_harm();
}
inline bool role_status::dec_harm() const {
  return dec_harm_;
}
inline void role_status::set_dec_harm(bool value) {
  set_has_dec_harm();
  dec_harm_ = value;
}

// optional bool rej_harm = 26 [default = false];
inline bool role_status::has_rej_harm() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void role_status::set_has_rej_harm() {
  _has_bits_[0] |= 0x02000000u;
}
inline void role_status::clear_has_rej_harm() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void role_status::clear_rej_harm() {
  rej_harm_ = false;
  clear_has_rej_harm();
}
inline bool role_status::rej_harm() const {
  return rej_harm_;
}
inline void role_status::set_rej_harm(bool value) {
  set_has_rej_harm();
  rej_harm_ = value;
}

// optional bool streanth = 27 [default = false];
inline bool role_status::has_streanth() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void role_status::set_has_streanth() {
  _has_bits_[0] |= 0x04000000u;
}
inline void role_status::clear_has_streanth() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void role_status::clear_streanth() {
  streanth_ = false;
  clear_has_streanth();
}
inline bool role_status::streanth() const {
  return streanth_;
}
inline void role_status::set_streanth(bool value) {
  set_has_streanth();
  streanth_ = value;
}

// optional bool body = 28 [default = false];
inline bool role_status::has_body() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void role_status::set_has_body() {
  _has_bits_[0] |= 0x08000000u;
}
inline void role_status::clear_has_body() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void role_status::clear_body() {
  body_ = false;
  clear_has_body();
}
inline bool role_status::body() const {
  return body_;
}
inline void role_status::set_body(bool value) {
  set_has_body();
  body_ = value;
}

// optional uint32 guard = 29 [default = 0];
inline bool role_status::has_guard() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void role_status::set_has_guard() {
  _has_bits_[0] |= 0x10000000u;
}
inline void role_status::clear_has_guard() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void role_status::clear_guard() {
  guard_ = 0u;
  clear_has_guard();
}
inline ::google::protobuf::uint32 role_status::guard() const {
  return guard_;
}
inline void role_status::set_guard(::google::protobuf::uint32 value) {
  set_has_guard();
  guard_ = value;
}

// optional bool comm_practice = 30 [default = false];
inline bool role_status::has_comm_practice() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void role_status::set_has_comm_practice() {
  _has_bits_[0] |= 0x20000000u;
}
inline void role_status::clear_has_comm_practice() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void role_status::clear_comm_practice() {
  comm_practice_ = false;
  clear_has_comm_practice();
}
inline bool role_status::comm_practice() const {
  return comm_practice_;
}
inline void role_status::set_comm_practice(bool value) {
  set_has_comm_practice();
  comm_practice_ = value;
}

// -------------------------------------------------------------------

// change_status

// required .client.role_status rs = 1;
inline bool change_status::has_rs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void change_status::set_has_rs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void change_status::clear_has_rs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void change_status::clear_rs() {
  if (rs_ != NULL) rs_->::client::role_status::Clear();
  clear_has_rs();
}
inline const ::client::role_status& change_status::rs() const {
  return rs_ != NULL ? *rs_ : *default_instance_->rs_;
}
inline ::client::role_status* change_status::mutable_rs() {
  set_has_rs();
  if (rs_ == NULL) rs_ = new ::client::role_status;
  return rs_;
}
inline ::client::role_status* change_status::release_rs() {
  clear_has_rs();
  ::client::role_status* temp = rs_;
  rs_ = NULL;
  return temp;
}
inline void change_status::set_allocated_rs(::client::role_status* rs) {
  delete rs_;
  rs_ = rs;
  if (rs) {
    set_has_rs();
  } else {
    clear_has_rs();
  }
}

// optional .client.server_head svr_head = 1000;
inline bool change_status::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void change_status::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void change_status::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void change_status::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& change_status::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* change_status::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* change_status::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void change_status::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// notify_kill_event

// required .client.role_data dead = 1;
inline bool notify_kill_event::has_dead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void notify_kill_event::set_has_dead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void notify_kill_event::clear_has_dead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void notify_kill_event::clear_dead() {
  if (dead_ != NULL) dead_->::client::role_data::Clear();
  clear_has_dead();
}
inline const ::client::role_data& notify_kill_event::dead() const {
  return dead_ != NULL ? *dead_ : *default_instance_->dead_;
}
inline ::client::role_data* notify_kill_event::mutable_dead() {
  set_has_dead();
  if (dead_ == NULL) dead_ = new ::client::role_data;
  return dead_;
}
inline ::client::role_data* notify_kill_event::release_dead() {
  clear_has_dead();
  ::client::role_data* temp = dead_;
  dead_ = NULL;
  return temp;
}
inline void notify_kill_event::set_allocated_dead(::client::role_data* dead) {
  delete dead_;
  dead_ = dead;
  if (dead) {
    set_has_dead();
  } else {
    clear_has_dead();
  }
}

// required .client.role_data killer = 2;
inline bool notify_kill_event::has_killer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void notify_kill_event::set_has_killer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void notify_kill_event::clear_has_killer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void notify_kill_event::clear_killer() {
  if (killer_ != NULL) killer_->::client::role_data::Clear();
  clear_has_killer();
}
inline const ::client::role_data& notify_kill_event::killer() const {
  return killer_ != NULL ? *killer_ : *default_instance_->killer_;
}
inline ::client::role_data* notify_kill_event::mutable_killer() {
  set_has_killer();
  if (killer_ == NULL) killer_ = new ::client::role_data;
  return killer_;
}
inline ::client::role_data* notify_kill_event::release_killer() {
  clear_has_killer();
  ::client::role_data* temp = killer_;
  killer_ = NULL;
  return temp;
}
inline void notify_kill_event::set_allocated_killer(::client::role_data* killer) {
  delete killer_;
  killer_ = killer;
  if (killer) {
    set_has_killer();
  } else {
    clear_has_killer();
  }
}

// optional uint32 dead_lose_factor = 3;
inline bool notify_kill_event::has_dead_lose_factor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void notify_kill_event::set_has_dead_lose_factor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void notify_kill_event::clear_has_dead_lose_factor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void notify_kill_event::clear_dead_lose_factor() {
  dead_lose_factor_ = 0u;
  clear_has_dead_lose_factor();
}
inline ::google::protobuf::uint32 notify_kill_event::dead_lose_factor() const {
  return dead_lose_factor_;
}
inline void notify_kill_event::set_dead_lose_factor(::google::protobuf::uint32 value) {
  set_has_dead_lose_factor();
  dead_lose_factor_ = value;
}

// optional uint32 killer_got_factor = 4;
inline bool notify_kill_event::has_killer_got_factor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void notify_kill_event::set_has_killer_got_factor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void notify_kill_event::clear_has_killer_got_factor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void notify_kill_event::clear_killer_got_factor() {
  killer_got_factor_ = 0u;
  clear_has_killer_got_factor();
}
inline ::google::protobuf::uint32 notify_kill_event::killer_got_factor() const {
  return killer_got_factor_;
}
inline void notify_kill_event::set_killer_got_factor(::google::protobuf::uint32 value) {
  set_has_killer_got_factor();
  killer_got_factor_ = value;
}

// -------------------------------------------------------------------

// select_relive_type_req

// required .client.select_relive_type_req.TYPE type = 1;
inline bool select_relive_type_req::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void select_relive_type_req::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void select_relive_type_req::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void select_relive_type_req::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::client::select_relive_type_req_TYPE select_relive_type_req::type() const {
  return static_cast< ::client::select_relive_type_req_TYPE >(type_);
}
inline void select_relive_type_req::set_type(::client::select_relive_type_req_TYPE value) {
  assert(::client::select_relive_type_req_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool auto_buy = 2;
inline bool select_relive_type_req::has_auto_buy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void select_relive_type_req::set_has_auto_buy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void select_relive_type_req::clear_has_auto_buy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void select_relive_type_req::clear_auto_buy() {
  auto_buy_ = false;
  clear_has_auto_buy();
}
inline bool select_relive_type_req::auto_buy() const {
  return auto_buy_;
}
inline void select_relive_type_req::set_auto_buy(bool value) {
  set_has_auto_buy();
  auto_buy_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool select_relive_type_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void select_relive_type_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void select_relive_type_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void select_relive_type_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& select_relive_type_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* select_relive_type_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* select_relive_type_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void select_relive_type_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// select_relive_type_rsp

// required .client.select_relive_type_rsp.RET ret = 1;
inline bool select_relive_type_rsp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void select_relive_type_rsp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void select_relive_type_rsp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void select_relive_type_rsp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::select_relive_type_rsp_RET select_relive_type_rsp::ret() const {
  return static_cast< ::client::select_relive_type_rsp_RET >(ret_);
}
inline void select_relive_type_rsp::set_ret(::client::select_relive_type_rsp_RET value) {
  assert(::client::select_relive_type_rsp_RET_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// dark_zero_time

// required uint32 unixtime = 1;
inline bool dark_zero_time::has_unixtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dark_zero_time::set_has_unixtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dark_zero_time::clear_has_unixtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dark_zero_time::clear_unixtime() {
  unixtime_ = 0u;
  clear_has_unixtime();
}
inline ::google::protobuf::uint32 dark_zero_time::unixtime() const {
  return unixtime_;
}
inline void dark_zero_time::set_unixtime(::google::protobuf::uint32 value) {
  set_has_unixtime();
  unixtime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::role_status_pvp_status>() {
  return ::client::role_status_pvp_status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::role_status_attack_mode>() {
  return ::client::role_status_attack_mode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::role_status_alive_status>() {
  return ::client::role_status_alive_status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::role_status_riding_status>() {
  return ::client::role_status_riding_status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::select_relive_type_req_TYPE>() {
  return ::client::select_relive_type_req_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::select_relive_type_rsp_RET>() {
  return ::client::select_relive_type_rsp_RET_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::ROLE_STATUS_E>() {
  return ::client::ROLE_STATUS_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2erole_5fstatus_2eproto__INCLUDED
