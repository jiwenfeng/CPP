// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.effect.proto

#ifndef PROTOBUF_client_2eeffect_2eproto__INCLUDED
#define PROTOBUF_client_2eeffect_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2eeffect_2eproto();
void protobuf_AssignDesc_client_2eeffect_2eproto();
void protobuf_ShutdownFile_client_2eeffect_2eproto();

class buffer_effect_val;
class each_bear_harm;
class buffer_effect_shield;
class rebound_damage;
class trigger_skill;
class immune_effect;
class taunt_effect;
class halo_effect;
class buffer_info;
class buffer_operate_info;
class buffer_list;
class buffer_hurt_msg;
class buffer_immune_msg;
class buffer_rebound_msg;

enum buffer_effect_val_OP {
  buffer_effect_val_OP_ADD = 0,
  buffer_effect_val_OP_MULTI = 1
};
bool buffer_effect_val_OP_IsValid(int value);
const buffer_effect_val_OP buffer_effect_val_OP_OP_MIN = buffer_effect_val_OP_ADD;
const buffer_effect_val_OP buffer_effect_val_OP_OP_MAX = buffer_effect_val_OP_MULTI;
const int buffer_effect_val_OP_OP_ARRAYSIZE = buffer_effect_val_OP_OP_MAX + 1;

const ::google::protobuf::EnumDescriptor* buffer_effect_val_OP_descriptor();
inline const ::std::string& buffer_effect_val_OP_Name(buffer_effect_val_OP value) {
  return ::google::protobuf::internal::NameOfEnum(
    buffer_effect_val_OP_descriptor(), value);
}
inline bool buffer_effect_val_OP_Parse(
    const ::std::string& name, buffer_effect_val_OP* value) {
  return ::google::protobuf::internal::ParseNamedEnum<buffer_effect_val_OP>(
    buffer_effect_val_OP_descriptor(), name, value);
}
enum BUFFER_LIST_METHOD_E {
  BLME_ADD = 1,
  BLME_UPDATE = 2,
  BLME_DELETE = 3
};
bool BUFFER_LIST_METHOD_E_IsValid(int value);
const BUFFER_LIST_METHOD_E BUFFER_LIST_METHOD_E_MIN = BLME_ADD;
const BUFFER_LIST_METHOD_E BUFFER_LIST_METHOD_E_MAX = BLME_DELETE;
const int BUFFER_LIST_METHOD_E_ARRAYSIZE = BUFFER_LIST_METHOD_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* BUFFER_LIST_METHOD_E_descriptor();
inline const ::std::string& BUFFER_LIST_METHOD_E_Name(BUFFER_LIST_METHOD_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    BUFFER_LIST_METHOD_E_descriptor(), value);
}
inline bool BUFFER_LIST_METHOD_E_Parse(
    const ::std::string& name, BUFFER_LIST_METHOD_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BUFFER_LIST_METHOD_E>(
    BUFFER_LIST_METHOD_E_descriptor(), name, value);
}
// ===================================================================

class buffer_effect_val : public ::google::protobuf::Message {
 public:
  buffer_effect_val();
  virtual ~buffer_effect_val();

  buffer_effect_val(const buffer_effect_val& from);

  inline buffer_effect_val& operator=(const buffer_effect_val& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_effect_val& default_instance();

  void Swap(buffer_effect_val* other);

  // implements Message ----------------------------------------------

  buffer_effect_val* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_effect_val& from);
  void MergeFrom(const buffer_effect_val& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef buffer_effect_val_OP OP;
  static const OP ADD = buffer_effect_val_OP_ADD;
  static const OP MULTI = buffer_effect_val_OP_MULTI;
  static inline bool OP_IsValid(int value) {
    return buffer_effect_val_OP_IsValid(value);
  }
  static const OP OP_MIN =
    buffer_effect_val_OP_OP_MIN;
  static const OP OP_MAX =
    buffer_effect_val_OP_OP_MAX;
  static const int OP_ARRAYSIZE =
    buffer_effect_val_OP_OP_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OP_descriptor() {
    return buffer_effect_val_OP_descriptor();
  }
  static inline const ::std::string& OP_Name(OP value) {
    return buffer_effect_val_OP_Name(value);
  }
  static inline bool OP_Parse(const ::std::string& name,
      OP* value) {
    return buffer_effect_val_OP_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required int32 val = 2 [default = 0];
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline ::google::protobuf::int32 val() const;
  inline void set_val(::google::protobuf::int32 value);

  // optional .client.buffer_effect_val.OP operate = 3 [default = ADD];
  inline bool has_operate() const;
  inline void clear_operate();
  static const int kOperateFieldNumber = 3;
  inline ::client::buffer_effect_val_OP operate() const;
  inline void set_operate(::client::buffer_effect_val_OP value);

  // optional int32 max_val = 4;
  inline bool has_max_val() const;
  inline void clear_max_val();
  static const int kMaxValFieldNumber = 4;
  inline ::google::protobuf::int32 max_val() const;
  inline void set_max_val(::google::protobuf::int32 value);

  // optional int32 min_val = 5;
  inline bool has_min_val() const;
  inline void clear_min_val();
  static const int kMinValFieldNumber = 5;
  inline ::google::protobuf::int32 min_val() const;
  inline void set_min_val(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.buffer_effect_val)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_val();
  inline void clear_has_val();
  inline void set_has_operate();
  inline void clear_has_operate();
  inline void set_has_max_val();
  inline void clear_has_max_val();
  inline void set_has_min_val();
  inline void clear_has_min_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::int32 val_;
  int operate_;
  ::google::protobuf::int32 max_val_;
  ::google::protobuf::int32 min_val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_effect_val* default_instance_;
};
// -------------------------------------------------------------------

class each_bear_harm : public ::google::protobuf::Message {
 public:
  each_bear_harm();
  virtual ~each_bear_harm();

  each_bear_harm(const each_bear_harm& from);

  inline each_bear_harm& operator=(const each_bear_harm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const each_bear_harm& default_instance();

  void Swap(each_bear_harm* other);

  // implements Message ----------------------------------------------

  each_bear_harm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const each_bear_harm& from);
  void MergeFrom(const each_bear_harm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 molecular = 1;
  inline bool has_molecular() const;
  inline void clear_molecular();
  static const int kMolecularFieldNumber = 1;
  inline ::google::protobuf::int32 molecular() const;
  inline void set_molecular(::google::protobuf::int32 value);

  // optional int32 denominator = 2;
  inline bool has_denominator() const;
  inline void clear_denominator();
  static const int kDenominatorFieldNumber = 2;
  inline ::google::protobuf::int32 denominator() const;
  inline void set_denominator(::google::protobuf::int32 value);

  // optional int32 val = 3;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 3;
  inline ::google::protobuf::int32 val() const;
  inline void set_val(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.each_bear_harm)
 private:
  inline void set_has_molecular();
  inline void clear_has_molecular();
  inline void set_has_denominator();
  inline void clear_has_denominator();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 molecular_;
  ::google::protobuf::int32 denominator_;
  ::google::protobuf::int32 val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static each_bear_harm* default_instance_;
};
// -------------------------------------------------------------------

class buffer_effect_shield : public ::google::protobuf::Message {
 public:
  buffer_effect_shield();
  virtual ~buffer_effect_shield();

  buffer_effect_shield(const buffer_effect_shield& from);

  inline buffer_effect_shield& operator=(const buffer_effect_shield& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_effect_shield& default_instance();

  void Swap(buffer_effect_shield* other);

  // implements Message ----------------------------------------------

  buffer_effect_shield* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_effect_shield& from);
  void MergeFrom(const buffer_effect_shield& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 effect_id = 1;
  inline bool has_effect_id() const;
  inline void clear_effect_id();
  static const int kEffectIdFieldNumber = 1;
  inline ::google::protobuf::uint32 effect_id() const;
  inline void set_effect_id(::google::protobuf::uint32 value);

  // required int32 durable_max = 2;
  inline bool has_durable_max() const;
  inline void clear_durable_max();
  static const int kDurableMaxFieldNumber = 2;
  inline ::google::protobuf::int32 durable_max() const;
  inline void set_durable_max(::google::protobuf::int32 value);

  // required .client.each_bear_harm ebh = 4;
  inline bool has_ebh() const;
  inline void clear_ebh();
  static const int kEbhFieldNumber = 4;
  inline const ::client::each_bear_harm& ebh() const;
  inline ::client::each_bear_harm* mutable_ebh();
  inline ::client::each_bear_harm* release_ebh();
  inline void set_allocated_ebh(::client::each_bear_harm* ebh);

  // required float over_back_proportion = 5;
  inline bool has_over_back_proportion() const;
  inline void clear_over_back_proportion();
  static const int kOverBackProportionFieldNumber = 5;
  inline float over_back_proportion() const;
  inline void set_over_back_proportion(float value);

  // required int32 over_back_max = 6;
  inline bool has_over_back_max() const;
  inline void clear_over_back_max();
  static const int kOverBackMaxFieldNumber = 6;
  inline ::google::protobuf::int32 over_back_max() const;
  inline void set_over_back_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:client.buffer_effect_shield)
 private:
  inline void set_has_effect_id();
  inline void clear_has_effect_id();
  inline void set_has_durable_max();
  inline void clear_has_durable_max();
  inline void set_has_ebh();
  inline void clear_has_ebh();
  inline void set_has_over_back_proportion();
  inline void clear_has_over_back_proportion();
  inline void set_has_over_back_max();
  inline void clear_has_over_back_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 effect_id_;
  ::google::protobuf::int32 durable_max_;
  ::client::each_bear_harm* ebh_;
  float over_back_proportion_;
  ::google::protobuf::int32 over_back_max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_effect_shield* default_instance_;
};
// -------------------------------------------------------------------

class rebound_damage : public ::google::protobuf::Message {
 public:
  rebound_damage();
  virtual ~rebound_damage();

  rebound_damage(const rebound_damage& from);

  inline rebound_damage& operator=(const rebound_damage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rebound_damage& default_instance();

  void Swap(rebound_damage* other);

  // implements Message ----------------------------------------------

  rebound_damage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rebound_damage& from);
  void MergeFrom(const rebound_damage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rebound_count = 1;
  inline bool has_rebound_count() const;
  inline void clear_rebound_count();
  static const int kReboundCountFieldNumber = 1;
  inline ::google::protobuf::uint32 rebound_count() const;
  inline void set_rebound_count(::google::protobuf::uint32 value);

  // required uint32 rebound_proportion = 2;
  inline bool has_rebound_proportion() const;
  inline void clear_rebound_proportion();
  static const int kReboundProportionFieldNumber = 2;
  inline ::google::protobuf::uint32 rebound_proportion() const;
  inline void set_rebound_proportion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.rebound_damage)
 private:
  inline void set_has_rebound_count();
  inline void clear_has_rebound_count();
  inline void set_has_rebound_proportion();
  inline void clear_has_rebound_proportion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rebound_count_;
  ::google::protobuf::uint32 rebound_proportion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static rebound_damage* default_instance_;
};
// -------------------------------------------------------------------

class trigger_skill : public ::google::protobuf::Message {
 public:
  trigger_skill();
  virtual ~trigger_skill();

  trigger_skill(const trigger_skill& from);

  inline trigger_skill& operator=(const trigger_skill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trigger_skill& default_instance();

  void Swap(trigger_skill* other);

  // implements Message ----------------------------------------------

  trigger_skill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trigger_skill& from);
  void MergeFrom(const trigger_skill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 cd = 2;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCdFieldNumber = 2;
  inline ::google::protobuf::uint32 cd() const;
  inline void set_cd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.trigger_skill)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_cd();
  inline void clear_has_cd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 cd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static trigger_skill* default_instance_;
};
// -------------------------------------------------------------------

class immune_effect : public ::google::protobuf::Message {
 public:
  immune_effect();
  virtual ~immune_effect();

  immune_effect(const immune_effect& from);

  inline immune_effect& operator=(const immune_effect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const immune_effect& default_instance();

  void Swap(immune_effect* other);

  // implements Message ----------------------------------------------

  immune_effect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const immune_effect& from);
  void MergeFrom(const immune_effect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 proportion = 2;
  inline bool has_proportion() const;
  inline void clear_proportion();
  static const int kProportionFieldNumber = 2;
  inline ::google::protobuf::uint32 proportion() const;
  inline void set_proportion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.immune_effect)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_proportion();
  inline void clear_has_proportion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 proportion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static immune_effect* default_instance_;
};
// -------------------------------------------------------------------

class taunt_effect : public ::google::protobuf::Message {
 public:
  taunt_effect();
  virtual ~taunt_effect();

  taunt_effect(const taunt_effect& from);

  inline taunt_effect& operator=(const taunt_effect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const taunt_effect& default_instance();

  void Swap(taunt_effect* other);

  // implements Message ----------------------------------------------

  taunt_effect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const taunt_effect& from);
  void MergeFrom(const taunt_effect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 inst_id = 1;
  inline bool has_inst_id() const;
  inline void clear_inst_id();
  static const int kInstIdFieldNumber = 1;
  inline ::google::protobuf::uint64 inst_id() const;
  inline void set_inst_id(::google::protobuf::uint64 value);

  // required uint32 ms = 2;
  inline bool has_ms() const;
  inline void clear_ms();
  static const int kMsFieldNumber = 2;
  inline ::google::protobuf::uint32 ms() const;
  inline void set_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.taunt_effect)
 private:
  inline void set_has_inst_id();
  inline void clear_has_inst_id();
  inline void set_has_ms();
  inline void clear_has_ms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 inst_id_;
  ::google::protobuf::uint32 ms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static taunt_effect* default_instance_;
};
// -------------------------------------------------------------------

class halo_effect : public ::google::protobuf::Message {
 public:
  halo_effect();
  virtual ~halo_effect();

  halo_effect(const halo_effect& from);

  inline halo_effect& operator=(const halo_effect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const halo_effect& default_instance();

  void Swap(halo_effect* other);

  // implements Message ----------------------------------------------

  halo_effect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const halo_effect& from);
  void MergeFrom(const halo_effect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 radius = 1;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 1;
  inline ::google::protobuf::uint32 radius() const;
  inline void set_radius(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.halo_effect)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 radius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static halo_effect* default_instance_;
};
// -------------------------------------------------------------------

class buffer_info : public ::google::protobuf::Message {
 public:
  buffer_info();
  virtual ~buffer_info();

  buffer_info(const buffer_info& from);

  inline buffer_info& operator=(const buffer_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_info& default_instance();

  void Swap(buffer_info* other);

  // implements Message ----------------------------------------------

  buffer_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_info& from);
  void MergeFrom(const buffer_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 effect_id = 1 [default = 0];
  inline bool has_effect_id() const;
  inline void clear_effect_id();
  static const int kEffectIdFieldNumber = 1;
  inline ::google::protobuf::uint32 effect_id() const;
  inline void set_effect_id(::google::protobuf::uint32 value);

  // required uint32 repeat_levels = 2 [default = 0];
  inline bool has_repeat_levels() const;
  inline void clear_repeat_levels();
  static const int kRepeatLevelsFieldNumber = 2;
  inline ::google::protobuf::uint32 repeat_levels() const;
  inline void set_repeat_levels(::google::protobuf::uint32 value);

  // optional uint32 cur_stacks = 3 [default = 0];
  inline bool has_cur_stacks() const;
  inline void clear_cur_stacks();
  static const int kCurStacksFieldNumber = 3;
  inline ::google::protobuf::uint32 cur_stacks() const;
  inline void set_cur_stacks(::google::protobuf::uint32 value);

  // optional uint32 duration = 4 [default = 0];
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 interval = 5 [default = 0];
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 5;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // optional uint32 effect_tick = 6 [default = 0];
  inline bool has_effect_tick() const;
  inline void clear_effect_tick();
  static const int kEffectTickFieldNumber = 6;
  inline ::google::protobuf::uint32 effect_tick() const;
  inline void set_effect_tick(::google::protobuf::uint32 value);

  // optional uint32 remain_tick = 7 [default = 0];
  inline bool has_remain_tick() const;
  inline void clear_remain_tick();
  static const int kRemainTickFieldNumber = 7;
  inline ::google::protobuf::uint32 remain_tick() const;
  inline void set_remain_tick(::google::protobuf::uint32 value);

  // optional uint32 max_effect_times = 8 [default = 0];
  inline bool has_max_effect_times() const;
  inline void clear_max_effect_times();
  static const int kMaxEffectTimesFieldNumber = 8;
  inline ::google::protobuf::uint32 max_effect_times() const;
  inline void set_max_effect_times(::google::protobuf::uint32 value);

  // optional uint32 effected_times = 9 [default = 0];
  inline bool has_effected_times() const;
  inline void clear_effected_times();
  static const int kEffectedTimesFieldNumber = 9;
  inline ::google::protobuf::uint32 effected_times() const;
  inline void set_effected_times(::google::protobuf::uint32 value);

  // repeated .client.buffer_effect_val status_val = 10;
  inline int status_val_size() const;
  inline void clear_status_val();
  static const int kStatusValFieldNumber = 10;
  inline const ::client::buffer_effect_val& status_val(int index) const;
  inline ::client::buffer_effect_val* mutable_status_val(int index);
  inline ::client::buffer_effect_val* add_status_val();
  inline const ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >&
      status_val() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >*
      mutable_status_val();

  // repeated .client.buffer_effect_val attr_val = 11;
  inline int attr_val_size() const;
  inline void clear_attr_val();
  static const int kAttrValFieldNumber = 11;
  inline const ::client::buffer_effect_val& attr_val(int index) const;
  inline ::client::buffer_effect_val* mutable_attr_val(int index);
  inline ::client::buffer_effect_val* add_attr_val();
  inline const ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >&
      attr_val() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >*
      mutable_attr_val();

  // optional .client.buffer_effect_shield shield = 12;
  inline bool has_shield() const;
  inline void clear_shield();
  static const int kShieldFieldNumber = 12;
  inline const ::client::buffer_effect_shield& shield() const;
  inline ::client::buffer_effect_shield* mutable_shield();
  inline ::client::buffer_effect_shield* release_shield();
  inline void set_allocated_shield(::client::buffer_effect_shield* shield);

  // optional .client.rebound_damage rebound = 13;
  inline bool has_rebound() const;
  inline void clear_rebound();
  static const int kReboundFieldNumber = 13;
  inline const ::client::rebound_damage& rebound() const;
  inline ::client::rebound_damage* mutable_rebound();
  inline ::client::rebound_damage* release_rebound();
  inline void set_allocated_rebound(::client::rebound_damage* rebound);

  // repeated .client.trigger_skill skills = 14;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 14;
  inline const ::client::trigger_skill& skills(int index) const;
  inline ::client::trigger_skill* mutable_skills(int index);
  inline ::client::trigger_skill* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::client::trigger_skill >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::trigger_skill >*
      mutable_skills();

  // repeated .client.immune_effect immune = 15;
  inline int immune_size() const;
  inline void clear_immune();
  static const int kImmuneFieldNumber = 15;
  inline const ::client::immune_effect& immune(int index) const;
  inline ::client::immune_effect* mutable_immune(int index);
  inline ::client::immune_effect* add_immune();
  inline const ::google::protobuf::RepeatedPtrField< ::client::immune_effect >&
      immune() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::immune_effect >*
      mutable_immune();

  // optional .client.taunt_effect taunt = 16;
  inline bool has_taunt() const;
  inline void clear_taunt();
  static const int kTauntFieldNumber = 16;
  inline const ::client::taunt_effect& taunt() const;
  inline ::client::taunt_effect* mutable_taunt();
  inline ::client::taunt_effect* release_taunt();
  inline void set_allocated_taunt(::client::taunt_effect* taunt);

  // optional .client.buffer_effect_val seckill = 17;
  inline bool has_seckill() const;
  inline void clear_seckill();
  static const int kSeckillFieldNumber = 17;
  inline const ::client::buffer_effect_val& seckill() const;
  inline ::client::buffer_effect_val* mutable_seckill();
  inline ::client::buffer_effect_val* release_seckill();
  inline void set_allocated_seckill(::client::buffer_effect_val* seckill);

  // optional .client.halo_effect halo = 18;
  inline bool has_halo() const;
  inline void clear_halo();
  static const int kHaloFieldNumber = 18;
  inline const ::client::halo_effect& halo() const;
  inline ::client::halo_effect* mutable_halo();
  inline ::client::halo_effect* release_halo();
  inline void set_allocated_halo(::client::halo_effect* halo);

  // optional .client.role_data caster = 19;
  inline bool has_caster() const;
  inline void clear_caster();
  static const int kCasterFieldNumber = 19;
  inline const ::client::role_data& caster() const;
  inline ::client::role_data* mutable_caster();
  inline ::client::role_data* release_caster();
  inline void set_allocated_caster(::client::role_data* caster);

  // @@protoc_insertion_point(class_scope:client.buffer_info)
 private:
  inline void set_has_effect_id();
  inline void clear_has_effect_id();
  inline void set_has_repeat_levels();
  inline void clear_has_repeat_levels();
  inline void set_has_cur_stacks();
  inline void clear_has_cur_stacks();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_effect_tick();
  inline void clear_has_effect_tick();
  inline void set_has_remain_tick();
  inline void clear_has_remain_tick();
  inline void set_has_max_effect_times();
  inline void clear_has_max_effect_times();
  inline void set_has_effected_times();
  inline void clear_has_effected_times();
  inline void set_has_shield();
  inline void clear_has_shield();
  inline void set_has_rebound();
  inline void clear_has_rebound();
  inline void set_has_taunt();
  inline void clear_has_taunt();
  inline void set_has_seckill();
  inline void clear_has_seckill();
  inline void set_has_halo();
  inline void clear_has_halo();
  inline void set_has_caster();
  inline void clear_has_caster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 effect_id_;
  ::google::protobuf::uint32 repeat_levels_;
  ::google::protobuf::uint32 cur_stacks_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 interval_;
  ::google::protobuf::uint32 effect_tick_;
  ::google::protobuf::uint32 remain_tick_;
  ::google::protobuf::uint32 max_effect_times_;
  ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val > status_val_;
  ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val > attr_val_;
  ::client::buffer_effect_shield* shield_;
  ::client::rebound_damage* rebound_;
  ::google::protobuf::RepeatedPtrField< ::client::trigger_skill > skills_;
  ::google::protobuf::RepeatedPtrField< ::client::immune_effect > immune_;
  ::client::taunt_effect* taunt_;
  ::client::buffer_effect_val* seckill_;
  ::client::halo_effect* halo_;
  ::client::role_data* caster_;
  ::google::protobuf::uint32 effected_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_info* default_instance_;
};
// -------------------------------------------------------------------

class buffer_operate_info : public ::google::protobuf::Message {
 public:
  buffer_operate_info();
  virtual ~buffer_operate_info();

  buffer_operate_info(const buffer_operate_info& from);

  inline buffer_operate_info& operator=(const buffer_operate_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_operate_info& default_instance();

  void Swap(buffer_operate_info* other);

  // implements Message ----------------------------------------------

  buffer_operate_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_operate_info& from);
  void MergeFrom(const buffer_operate_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.BUFFER_LIST_METHOD_E method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  inline ::client::BUFFER_LIST_METHOD_E method() const;
  inline void set_method(::client::BUFFER_LIST_METHOD_E value);

  // required .client.buffer_info bi = 2;
  inline bool has_bi() const;
  inline void clear_bi();
  static const int kBiFieldNumber = 2;
  inline const ::client::buffer_info& bi() const;
  inline ::client::buffer_info* mutable_bi();
  inline ::client::buffer_info* release_bi();
  inline void set_allocated_bi(::client::buffer_info* bi);

  // @@protoc_insertion_point(class_scope:client.buffer_operate_info)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_bi();
  inline void clear_has_bi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::buffer_info* bi_;
  int method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_operate_info* default_instance_;
};
// -------------------------------------------------------------------

class buffer_list : public ::google::protobuf::Message {
 public:
  buffer_list();
  virtual ~buffer_list();

  buffer_list(const buffer_list& from);

  inline buffer_list& operator=(const buffer_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_list& default_instance();

  void Swap(buffer_list* other);

  // implements Message ----------------------------------------------

  buffer_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_list& from);
  void MergeFrom(const buffer_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.buffer_operate_info boi = 1;
  inline int boi_size() const;
  inline void clear_boi();
  static const int kBoiFieldNumber = 1;
  inline const ::client::buffer_operate_info& boi(int index) const;
  inline ::client::buffer_operate_info* mutable_boi(int index);
  inline ::client::buffer_operate_info* add_boi();
  inline const ::google::protobuf::RepeatedPtrField< ::client::buffer_operate_info >&
      boi() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::buffer_operate_info >*
      mutable_boi();

  // required .client.role_data rd = 2;
  inline bool has_rd() const;
  inline void clear_rd();
  static const int kRdFieldNumber = 2;
  inline const ::client::role_data& rd() const;
  inline ::client::role_data* mutable_rd();
  inline ::client::role_data* release_rd();
  inline void set_allocated_rd(::client::role_data* rd);

  // @@protoc_insertion_point(class_scope:client.buffer_list)
 private:
  inline void set_has_rd();
  inline void clear_has_rd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::buffer_operate_info > boi_;
  ::client::role_data* rd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_list* default_instance_;
};
// -------------------------------------------------------------------

class buffer_hurt_msg : public ::google::protobuf::Message {
 public:
  buffer_hurt_msg();
  virtual ~buffer_hurt_msg();

  buffer_hurt_msg(const buffer_hurt_msg& from);

  inline buffer_hurt_msg& operator=(const buffer_hurt_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_hurt_msg& default_instance();

  void Swap(buffer_hurt_msg* other);

  // implements Message ----------------------------------------------

  buffer_hurt_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_hurt_msg& from);
  void MergeFrom(const buffer_hurt_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_data rd = 1;
  inline bool has_rd() const;
  inline void clear_rd();
  static const int kRdFieldNumber = 1;
  inline const ::client::role_data& rd() const;
  inline ::client::role_data* mutable_rd();
  inline ::client::role_data* release_rd();
  inline void set_allocated_rd(::client::role_data* rd);

  // optional int32 hp = 2 [default = 0];
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 2;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 mp = 3 [default = 0];
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 3;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // optional bool dead = 4 [default = false];
  inline bool has_dead() const;
  inline void clear_dead();
  static const int kDeadFieldNumber = 4;
  inline bool dead() const;
  inline void set_dead(bool value);

  // optional uint32 cur_hp = 5 [default = 0];
  inline bool has_cur_hp() const;
  inline void clear_cur_hp();
  static const int kCurHpFieldNumber = 5;
  inline ::google::protobuf::uint32 cur_hp() const;
  inline void set_cur_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.buffer_hurt_msg)
 private:
  inline void set_has_rd();
  inline void clear_has_rd();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_dead();
  inline void clear_has_dead();
  inline void set_has_cur_hp();
  inline void clear_has_cur_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_data* rd_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 mp_;
  bool dead_;
  ::google::protobuf::uint32 cur_hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_hurt_msg* default_instance_;
};
// -------------------------------------------------------------------

class buffer_immune_msg : public ::google::protobuf::Message {
 public:
  buffer_immune_msg();
  virtual ~buffer_immune_msg();

  buffer_immune_msg(const buffer_immune_msg& from);

  inline buffer_immune_msg& operator=(const buffer_immune_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_immune_msg& default_instance();

  void Swap(buffer_immune_msg* other);

  // implements Message ----------------------------------------------

  buffer_immune_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_immune_msg& from);
  void MergeFrom(const buffer_immune_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_data target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::client::role_data& target() const;
  inline ::client::role_data* mutable_target();
  inline ::client::role_data* release_target();
  inline void set_allocated_target(::client::role_data* target);

  // required .client.role_data caster = 2;
  inline bool has_caster() const;
  inline void clear_caster();
  static const int kCasterFieldNumber = 2;
  inline const ::client::role_data& caster() const;
  inline ::client::role_data* mutable_caster();
  inline ::client::role_data* release_caster();
  inline void set_allocated_caster(::client::role_data* caster);

  // required uint32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.buffer_immune_msg)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_caster();
  inline void clear_has_caster();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_data* target_;
  ::client::role_data* caster_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_immune_msg* default_instance_;
};
// -------------------------------------------------------------------

class buffer_rebound_msg : public ::google::protobuf::Message {
 public:
  buffer_rebound_msg();
  virtual ~buffer_rebound_msg();

  buffer_rebound_msg(const buffer_rebound_msg& from);

  inline buffer_rebound_msg& operator=(const buffer_rebound_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buffer_rebound_msg& default_instance();

  void Swap(buffer_rebound_msg* other);

  // implements Message ----------------------------------------------

  buffer_rebound_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buffer_rebound_msg& from);
  void MergeFrom(const buffer_rebound_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .client.role_data target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::client::role_data& target() const;
  inline ::client::role_data* mutable_target();
  inline ::client::role_data* release_target();
  inline void set_allocated_target(::client::role_data* target);

  // required .client.role_data caster = 2;
  inline bool has_caster() const;
  inline void clear_caster();
  static const int kCasterFieldNumber = 2;
  inline const ::client::role_data& caster() const;
  inline ::client::role_data* mutable_caster();
  inline ::client::role_data* release_caster();
  inline void set_allocated_caster(::client::role_data* caster);

  // required uint32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.buffer_rebound_msg)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_caster();
  inline void clear_has_caster();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::role_data* target_;
  ::client::role_data* caster_;
  ::google::protobuf::uint32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eeffect_2eproto();
  friend void protobuf_AssignDesc_client_2eeffect_2eproto();
  friend void protobuf_ShutdownFile_client_2eeffect_2eproto();

  void InitAsDefaultInstance();
  static buffer_rebound_msg* default_instance_;
};
// ===================================================================


// ===================================================================

// buffer_effect_val

// required uint32 type = 1 [default = 0];
inline bool buffer_effect_val::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffer_effect_val::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffer_effect_val::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffer_effect_val::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 buffer_effect_val::type() const {
  return type_;
}
inline void buffer_effect_val::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required int32 val = 2 [default = 0];
inline bool buffer_effect_val::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_effect_val::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_effect_val::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_effect_val::clear_val() {
  val_ = 0;
  clear_has_val();
}
inline ::google::protobuf::int32 buffer_effect_val::val() const {
  return val_;
}
inline void buffer_effect_val::set_val(::google::protobuf::int32 value) {
  set_has_val();
  val_ = value;
}

// optional .client.buffer_effect_val.OP operate = 3 [default = ADD];
inline bool buffer_effect_val::has_operate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void buffer_effect_val::set_has_operate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void buffer_effect_val::clear_has_operate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void buffer_effect_val::clear_operate() {
  operate_ = 0;
  clear_has_operate();
}
inline ::client::buffer_effect_val_OP buffer_effect_val::operate() const {
  return static_cast< ::client::buffer_effect_val_OP >(operate_);
}
inline void buffer_effect_val::set_operate(::client::buffer_effect_val_OP value) {
  assert(::client::buffer_effect_val_OP_IsValid(value));
  set_has_operate();
  operate_ = value;
}

// optional int32 max_val = 4;
inline bool buffer_effect_val::has_max_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void buffer_effect_val::set_has_max_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void buffer_effect_val::clear_has_max_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void buffer_effect_val::clear_max_val() {
  max_val_ = 0;
  clear_has_max_val();
}
inline ::google::protobuf::int32 buffer_effect_val::max_val() const {
  return max_val_;
}
inline void buffer_effect_val::set_max_val(::google::protobuf::int32 value) {
  set_has_max_val();
  max_val_ = value;
}

// optional int32 min_val = 5;
inline bool buffer_effect_val::has_min_val() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void buffer_effect_val::set_has_min_val() {
  _has_bits_[0] |= 0x00000010u;
}
inline void buffer_effect_val::clear_has_min_val() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void buffer_effect_val::clear_min_val() {
  min_val_ = 0;
  clear_has_min_val();
}
inline ::google::protobuf::int32 buffer_effect_val::min_val() const {
  return min_val_;
}
inline void buffer_effect_val::set_min_val(::google::protobuf::int32 value) {
  set_has_min_val();
  min_val_ = value;
}

// -------------------------------------------------------------------

// each_bear_harm

// optional int32 molecular = 1;
inline bool each_bear_harm::has_molecular() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void each_bear_harm::set_has_molecular() {
  _has_bits_[0] |= 0x00000001u;
}
inline void each_bear_harm::clear_has_molecular() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void each_bear_harm::clear_molecular() {
  molecular_ = 0;
  clear_has_molecular();
}
inline ::google::protobuf::int32 each_bear_harm::molecular() const {
  return molecular_;
}
inline void each_bear_harm::set_molecular(::google::protobuf::int32 value) {
  set_has_molecular();
  molecular_ = value;
}

// optional int32 denominator = 2;
inline bool each_bear_harm::has_denominator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void each_bear_harm::set_has_denominator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void each_bear_harm::clear_has_denominator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void each_bear_harm::clear_denominator() {
  denominator_ = 0;
  clear_has_denominator();
}
inline ::google::protobuf::int32 each_bear_harm::denominator() const {
  return denominator_;
}
inline void each_bear_harm::set_denominator(::google::protobuf::int32 value) {
  set_has_denominator();
  denominator_ = value;
}

// optional int32 val = 3;
inline bool each_bear_harm::has_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void each_bear_harm::set_has_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void each_bear_harm::clear_has_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void each_bear_harm::clear_val() {
  val_ = 0;
  clear_has_val();
}
inline ::google::protobuf::int32 each_bear_harm::val() const {
  return val_;
}
inline void each_bear_harm::set_val(::google::protobuf::int32 value) {
  set_has_val();
  val_ = value;
}

// -------------------------------------------------------------------

// buffer_effect_shield

// required uint32 effect_id = 1;
inline bool buffer_effect_shield::has_effect_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffer_effect_shield::set_has_effect_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffer_effect_shield::clear_has_effect_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffer_effect_shield::clear_effect_id() {
  effect_id_ = 0u;
  clear_has_effect_id();
}
inline ::google::protobuf::uint32 buffer_effect_shield::effect_id() const {
  return effect_id_;
}
inline void buffer_effect_shield::set_effect_id(::google::protobuf::uint32 value) {
  set_has_effect_id();
  effect_id_ = value;
}

// required int32 durable_max = 2;
inline bool buffer_effect_shield::has_durable_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_effect_shield::set_has_durable_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_effect_shield::clear_has_durable_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_effect_shield::clear_durable_max() {
  durable_max_ = 0;
  clear_has_durable_max();
}
inline ::google::protobuf::int32 buffer_effect_shield::durable_max() const {
  return durable_max_;
}
inline void buffer_effect_shield::set_durable_max(::google::protobuf::int32 value) {
  set_has_durable_max();
  durable_max_ = value;
}

// required .client.each_bear_harm ebh = 4;
inline bool buffer_effect_shield::has_ebh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void buffer_effect_shield::set_has_ebh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void buffer_effect_shield::clear_has_ebh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void buffer_effect_shield::clear_ebh() {
  if (ebh_ != NULL) ebh_->::client::each_bear_harm::Clear();
  clear_has_ebh();
}
inline const ::client::each_bear_harm& buffer_effect_shield::ebh() const {
  return ebh_ != NULL ? *ebh_ : *default_instance_->ebh_;
}
inline ::client::each_bear_harm* buffer_effect_shield::mutable_ebh() {
  set_has_ebh();
  if (ebh_ == NULL) ebh_ = new ::client::each_bear_harm;
  return ebh_;
}
inline ::client::each_bear_harm* buffer_effect_shield::release_ebh() {
  clear_has_ebh();
  ::client::each_bear_harm* temp = ebh_;
  ebh_ = NULL;
  return temp;
}
inline void buffer_effect_shield::set_allocated_ebh(::client::each_bear_harm* ebh) {
  delete ebh_;
  ebh_ = ebh;
  if (ebh) {
    set_has_ebh();
  } else {
    clear_has_ebh();
  }
}

// required float over_back_proportion = 5;
inline bool buffer_effect_shield::has_over_back_proportion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void buffer_effect_shield::set_has_over_back_proportion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void buffer_effect_shield::clear_has_over_back_proportion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void buffer_effect_shield::clear_over_back_proportion() {
  over_back_proportion_ = 0;
  clear_has_over_back_proportion();
}
inline float buffer_effect_shield::over_back_proportion() const {
  return over_back_proportion_;
}
inline void buffer_effect_shield::set_over_back_proportion(float value) {
  set_has_over_back_proportion();
  over_back_proportion_ = value;
}

// required int32 over_back_max = 6;
inline bool buffer_effect_shield::has_over_back_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void buffer_effect_shield::set_has_over_back_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void buffer_effect_shield::clear_has_over_back_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void buffer_effect_shield::clear_over_back_max() {
  over_back_max_ = 0;
  clear_has_over_back_max();
}
inline ::google::protobuf::int32 buffer_effect_shield::over_back_max() const {
  return over_back_max_;
}
inline void buffer_effect_shield::set_over_back_max(::google::protobuf::int32 value) {
  set_has_over_back_max();
  over_back_max_ = value;
}

// -------------------------------------------------------------------

// rebound_damage

// required uint32 rebound_count = 1;
inline bool rebound_damage::has_rebound_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rebound_damage::set_has_rebound_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rebound_damage::clear_has_rebound_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rebound_damage::clear_rebound_count() {
  rebound_count_ = 0u;
  clear_has_rebound_count();
}
inline ::google::protobuf::uint32 rebound_damage::rebound_count() const {
  return rebound_count_;
}
inline void rebound_damage::set_rebound_count(::google::protobuf::uint32 value) {
  set_has_rebound_count();
  rebound_count_ = value;
}

// required uint32 rebound_proportion = 2;
inline bool rebound_damage::has_rebound_proportion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rebound_damage::set_has_rebound_proportion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rebound_damage::clear_has_rebound_proportion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rebound_damage::clear_rebound_proportion() {
  rebound_proportion_ = 0u;
  clear_has_rebound_proportion();
}
inline ::google::protobuf::uint32 rebound_damage::rebound_proportion() const {
  return rebound_proportion_;
}
inline void rebound_damage::set_rebound_proportion(::google::protobuf::uint32 value) {
  set_has_rebound_proportion();
  rebound_proportion_ = value;
}

// -------------------------------------------------------------------

// trigger_skill

// required uint32 skill_id = 1;
inline bool trigger_skill::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void trigger_skill::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void trigger_skill::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void trigger_skill::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 trigger_skill::skill_id() const {
  return skill_id_;
}
inline void trigger_skill::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 cd = 2;
inline bool trigger_skill::has_cd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void trigger_skill::set_has_cd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void trigger_skill::clear_has_cd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void trigger_skill::clear_cd() {
  cd_ = 0u;
  clear_has_cd();
}
inline ::google::protobuf::uint32 trigger_skill::cd() const {
  return cd_;
}
inline void trigger_skill::set_cd(::google::protobuf::uint32 value) {
  set_has_cd();
  cd_ = value;
}

// -------------------------------------------------------------------

// immune_effect

// required uint32 type = 1;
inline bool immune_effect::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void immune_effect::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void immune_effect::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void immune_effect::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 immune_effect::type() const {
  return type_;
}
inline void immune_effect::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 proportion = 2;
inline bool immune_effect::has_proportion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void immune_effect::set_has_proportion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void immune_effect::clear_has_proportion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void immune_effect::clear_proportion() {
  proportion_ = 0u;
  clear_has_proportion();
}
inline ::google::protobuf::uint32 immune_effect::proportion() const {
  return proportion_;
}
inline void immune_effect::set_proportion(::google::protobuf::uint32 value) {
  set_has_proportion();
  proportion_ = value;
}

// -------------------------------------------------------------------

// taunt_effect

// required uint64 inst_id = 1;
inline bool taunt_effect::has_inst_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void taunt_effect::set_has_inst_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void taunt_effect::clear_has_inst_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void taunt_effect::clear_inst_id() {
  inst_id_ = GOOGLE_ULONGLONG(0);
  clear_has_inst_id();
}
inline ::google::protobuf::uint64 taunt_effect::inst_id() const {
  return inst_id_;
}
inline void taunt_effect::set_inst_id(::google::protobuf::uint64 value) {
  set_has_inst_id();
  inst_id_ = value;
}

// required uint32 ms = 2;
inline bool taunt_effect::has_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void taunt_effect::set_has_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void taunt_effect::clear_has_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void taunt_effect::clear_ms() {
  ms_ = 0u;
  clear_has_ms();
}
inline ::google::protobuf::uint32 taunt_effect::ms() const {
  return ms_;
}
inline void taunt_effect::set_ms(::google::protobuf::uint32 value) {
  set_has_ms();
  ms_ = value;
}

// -------------------------------------------------------------------

// halo_effect

// required uint32 radius = 1;
inline bool halo_effect::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void halo_effect::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void halo_effect::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void halo_effect::clear_radius() {
  radius_ = 0u;
  clear_has_radius();
}
inline ::google::protobuf::uint32 halo_effect::radius() const {
  return radius_;
}
inline void halo_effect::set_radius(::google::protobuf::uint32 value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// buffer_info

// required uint32 effect_id = 1 [default = 0];
inline bool buffer_info::has_effect_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffer_info::set_has_effect_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffer_info::clear_has_effect_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffer_info::clear_effect_id() {
  effect_id_ = 0u;
  clear_has_effect_id();
}
inline ::google::protobuf::uint32 buffer_info::effect_id() const {
  return effect_id_;
}
inline void buffer_info::set_effect_id(::google::protobuf::uint32 value) {
  set_has_effect_id();
  effect_id_ = value;
}

// required uint32 repeat_levels = 2 [default = 0];
inline bool buffer_info::has_repeat_levels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_info::set_has_repeat_levels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_info::clear_has_repeat_levels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_info::clear_repeat_levels() {
  repeat_levels_ = 0u;
  clear_has_repeat_levels();
}
inline ::google::protobuf::uint32 buffer_info::repeat_levels() const {
  return repeat_levels_;
}
inline void buffer_info::set_repeat_levels(::google::protobuf::uint32 value) {
  set_has_repeat_levels();
  repeat_levels_ = value;
}

// optional uint32 cur_stacks = 3 [default = 0];
inline bool buffer_info::has_cur_stacks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void buffer_info::set_has_cur_stacks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void buffer_info::clear_has_cur_stacks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void buffer_info::clear_cur_stacks() {
  cur_stacks_ = 0u;
  clear_has_cur_stacks();
}
inline ::google::protobuf::uint32 buffer_info::cur_stacks() const {
  return cur_stacks_;
}
inline void buffer_info::set_cur_stacks(::google::protobuf::uint32 value) {
  set_has_cur_stacks();
  cur_stacks_ = value;
}

// optional uint32 duration = 4 [default = 0];
inline bool buffer_info::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void buffer_info::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void buffer_info::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void buffer_info::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 buffer_info::duration() const {
  return duration_;
}
inline void buffer_info::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint32 interval = 5 [default = 0];
inline bool buffer_info::has_interval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void buffer_info::set_has_interval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void buffer_info::clear_has_interval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void buffer_info::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 buffer_info::interval() const {
  return interval_;
}
inline void buffer_info::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
}

// optional uint32 effect_tick = 6 [default = 0];
inline bool buffer_info::has_effect_tick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void buffer_info::set_has_effect_tick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void buffer_info::clear_has_effect_tick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void buffer_info::clear_effect_tick() {
  effect_tick_ = 0u;
  clear_has_effect_tick();
}
inline ::google::protobuf::uint32 buffer_info::effect_tick() const {
  return effect_tick_;
}
inline void buffer_info::set_effect_tick(::google::protobuf::uint32 value) {
  set_has_effect_tick();
  effect_tick_ = value;
}

// optional uint32 remain_tick = 7 [default = 0];
inline bool buffer_info::has_remain_tick() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void buffer_info::set_has_remain_tick() {
  _has_bits_[0] |= 0x00000040u;
}
inline void buffer_info::clear_has_remain_tick() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void buffer_info::clear_remain_tick() {
  remain_tick_ = 0u;
  clear_has_remain_tick();
}
inline ::google::protobuf::uint32 buffer_info::remain_tick() const {
  return remain_tick_;
}
inline void buffer_info::set_remain_tick(::google::protobuf::uint32 value) {
  set_has_remain_tick();
  remain_tick_ = value;
}

// optional uint32 max_effect_times = 8 [default = 0];
inline bool buffer_info::has_max_effect_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void buffer_info::set_has_max_effect_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void buffer_info::clear_has_max_effect_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void buffer_info::clear_max_effect_times() {
  max_effect_times_ = 0u;
  clear_has_max_effect_times();
}
inline ::google::protobuf::uint32 buffer_info::max_effect_times() const {
  return max_effect_times_;
}
inline void buffer_info::set_max_effect_times(::google::protobuf::uint32 value) {
  set_has_max_effect_times();
  max_effect_times_ = value;
}

// optional uint32 effected_times = 9 [default = 0];
inline bool buffer_info::has_effected_times() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void buffer_info::set_has_effected_times() {
  _has_bits_[0] |= 0x00000100u;
}
inline void buffer_info::clear_has_effected_times() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void buffer_info::clear_effected_times() {
  effected_times_ = 0u;
  clear_has_effected_times();
}
inline ::google::protobuf::uint32 buffer_info::effected_times() const {
  return effected_times_;
}
inline void buffer_info::set_effected_times(::google::protobuf::uint32 value) {
  set_has_effected_times();
  effected_times_ = value;
}

// repeated .client.buffer_effect_val status_val = 10;
inline int buffer_info::status_val_size() const {
  return status_val_.size();
}
inline void buffer_info::clear_status_val() {
  status_val_.Clear();
}
inline const ::client::buffer_effect_val& buffer_info::status_val(int index) const {
  return status_val_.Get(index);
}
inline ::client::buffer_effect_val* buffer_info::mutable_status_val(int index) {
  return status_val_.Mutable(index);
}
inline ::client::buffer_effect_val* buffer_info::add_status_val() {
  return status_val_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >&
buffer_info::status_val() const {
  return status_val_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >*
buffer_info::mutable_status_val() {
  return &status_val_;
}

// repeated .client.buffer_effect_val attr_val = 11;
inline int buffer_info::attr_val_size() const {
  return attr_val_.size();
}
inline void buffer_info::clear_attr_val() {
  attr_val_.Clear();
}
inline const ::client::buffer_effect_val& buffer_info::attr_val(int index) const {
  return attr_val_.Get(index);
}
inline ::client::buffer_effect_val* buffer_info::mutable_attr_val(int index) {
  return attr_val_.Mutable(index);
}
inline ::client::buffer_effect_val* buffer_info::add_attr_val() {
  return attr_val_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >&
buffer_info::attr_val() const {
  return attr_val_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::buffer_effect_val >*
buffer_info::mutable_attr_val() {
  return &attr_val_;
}

// optional .client.buffer_effect_shield shield = 12;
inline bool buffer_info::has_shield() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void buffer_info::set_has_shield() {
  _has_bits_[0] |= 0x00000800u;
}
inline void buffer_info::clear_has_shield() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void buffer_info::clear_shield() {
  if (shield_ != NULL) shield_->::client::buffer_effect_shield::Clear();
  clear_has_shield();
}
inline const ::client::buffer_effect_shield& buffer_info::shield() const {
  return shield_ != NULL ? *shield_ : *default_instance_->shield_;
}
inline ::client::buffer_effect_shield* buffer_info::mutable_shield() {
  set_has_shield();
  if (shield_ == NULL) shield_ = new ::client::buffer_effect_shield;
  return shield_;
}
inline ::client::buffer_effect_shield* buffer_info::release_shield() {
  clear_has_shield();
  ::client::buffer_effect_shield* temp = shield_;
  shield_ = NULL;
  return temp;
}
inline void buffer_info::set_allocated_shield(::client::buffer_effect_shield* shield) {
  delete shield_;
  shield_ = shield;
  if (shield) {
    set_has_shield();
  } else {
    clear_has_shield();
  }
}

// optional .client.rebound_damage rebound = 13;
inline bool buffer_info::has_rebound() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void buffer_info::set_has_rebound() {
  _has_bits_[0] |= 0x00001000u;
}
inline void buffer_info::clear_has_rebound() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void buffer_info::clear_rebound() {
  if (rebound_ != NULL) rebound_->::client::rebound_damage::Clear();
  clear_has_rebound();
}
inline const ::client::rebound_damage& buffer_info::rebound() const {
  return rebound_ != NULL ? *rebound_ : *default_instance_->rebound_;
}
inline ::client::rebound_damage* buffer_info::mutable_rebound() {
  set_has_rebound();
  if (rebound_ == NULL) rebound_ = new ::client::rebound_damage;
  return rebound_;
}
inline ::client::rebound_damage* buffer_info::release_rebound() {
  clear_has_rebound();
  ::client::rebound_damage* temp = rebound_;
  rebound_ = NULL;
  return temp;
}
inline void buffer_info::set_allocated_rebound(::client::rebound_damage* rebound) {
  delete rebound_;
  rebound_ = rebound;
  if (rebound) {
    set_has_rebound();
  } else {
    clear_has_rebound();
  }
}

// repeated .client.trigger_skill skills = 14;
inline int buffer_info::skills_size() const {
  return skills_.size();
}
inline void buffer_info::clear_skills() {
  skills_.Clear();
}
inline const ::client::trigger_skill& buffer_info::skills(int index) const {
  return skills_.Get(index);
}
inline ::client::trigger_skill* buffer_info::mutable_skills(int index) {
  return skills_.Mutable(index);
}
inline ::client::trigger_skill* buffer_info::add_skills() {
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::trigger_skill >&
buffer_info::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::trigger_skill >*
buffer_info::mutable_skills() {
  return &skills_;
}

// repeated .client.immune_effect immune = 15;
inline int buffer_info::immune_size() const {
  return immune_.size();
}
inline void buffer_info::clear_immune() {
  immune_.Clear();
}
inline const ::client::immune_effect& buffer_info::immune(int index) const {
  return immune_.Get(index);
}
inline ::client::immune_effect* buffer_info::mutable_immune(int index) {
  return immune_.Mutable(index);
}
inline ::client::immune_effect* buffer_info::add_immune() {
  return immune_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::immune_effect >&
buffer_info::immune() const {
  return immune_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::immune_effect >*
buffer_info::mutable_immune() {
  return &immune_;
}

// optional .client.taunt_effect taunt = 16;
inline bool buffer_info::has_taunt() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void buffer_info::set_has_taunt() {
  _has_bits_[0] |= 0x00008000u;
}
inline void buffer_info::clear_has_taunt() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void buffer_info::clear_taunt() {
  if (taunt_ != NULL) taunt_->::client::taunt_effect::Clear();
  clear_has_taunt();
}
inline const ::client::taunt_effect& buffer_info::taunt() const {
  return taunt_ != NULL ? *taunt_ : *default_instance_->taunt_;
}
inline ::client::taunt_effect* buffer_info::mutable_taunt() {
  set_has_taunt();
  if (taunt_ == NULL) taunt_ = new ::client::taunt_effect;
  return taunt_;
}
inline ::client::taunt_effect* buffer_info::release_taunt() {
  clear_has_taunt();
  ::client::taunt_effect* temp = taunt_;
  taunt_ = NULL;
  return temp;
}
inline void buffer_info::set_allocated_taunt(::client::taunt_effect* taunt) {
  delete taunt_;
  taunt_ = taunt;
  if (taunt) {
    set_has_taunt();
  } else {
    clear_has_taunt();
  }
}

// optional .client.buffer_effect_val seckill = 17;
inline bool buffer_info::has_seckill() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void buffer_info::set_has_seckill() {
  _has_bits_[0] |= 0x00010000u;
}
inline void buffer_info::clear_has_seckill() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void buffer_info::clear_seckill() {
  if (seckill_ != NULL) seckill_->::client::buffer_effect_val::Clear();
  clear_has_seckill();
}
inline const ::client::buffer_effect_val& buffer_info::seckill() const {
  return seckill_ != NULL ? *seckill_ : *default_instance_->seckill_;
}
inline ::client::buffer_effect_val* buffer_info::mutable_seckill() {
  set_has_seckill();
  if (seckill_ == NULL) seckill_ = new ::client::buffer_effect_val;
  return seckill_;
}
inline ::client::buffer_effect_val* buffer_info::release_seckill() {
  clear_has_seckill();
  ::client::buffer_effect_val* temp = seckill_;
  seckill_ = NULL;
  return temp;
}
inline void buffer_info::set_allocated_seckill(::client::buffer_effect_val* seckill) {
  delete seckill_;
  seckill_ = seckill;
  if (seckill) {
    set_has_seckill();
  } else {
    clear_has_seckill();
  }
}

// optional .client.halo_effect halo = 18;
inline bool buffer_info::has_halo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void buffer_info::set_has_halo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void buffer_info::clear_has_halo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void buffer_info::clear_halo() {
  if (halo_ != NULL) halo_->::client::halo_effect::Clear();
  clear_has_halo();
}
inline const ::client::halo_effect& buffer_info::halo() const {
  return halo_ != NULL ? *halo_ : *default_instance_->halo_;
}
inline ::client::halo_effect* buffer_info::mutable_halo() {
  set_has_halo();
  if (halo_ == NULL) halo_ = new ::client::halo_effect;
  return halo_;
}
inline ::client::halo_effect* buffer_info::release_halo() {
  clear_has_halo();
  ::client::halo_effect* temp = halo_;
  halo_ = NULL;
  return temp;
}
inline void buffer_info::set_allocated_halo(::client::halo_effect* halo) {
  delete halo_;
  halo_ = halo;
  if (halo) {
    set_has_halo();
  } else {
    clear_has_halo();
  }
}

// optional .client.role_data caster = 19;
inline bool buffer_info::has_caster() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void buffer_info::set_has_caster() {
  _has_bits_[0] |= 0x00040000u;
}
inline void buffer_info::clear_has_caster() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void buffer_info::clear_caster() {
  if (caster_ != NULL) caster_->::client::role_data::Clear();
  clear_has_caster();
}
inline const ::client::role_data& buffer_info::caster() const {
  return caster_ != NULL ? *caster_ : *default_instance_->caster_;
}
inline ::client::role_data* buffer_info::mutable_caster() {
  set_has_caster();
  if (caster_ == NULL) caster_ = new ::client::role_data;
  return caster_;
}
inline ::client::role_data* buffer_info::release_caster() {
  clear_has_caster();
  ::client::role_data* temp = caster_;
  caster_ = NULL;
  return temp;
}
inline void buffer_info::set_allocated_caster(::client::role_data* caster) {
  delete caster_;
  caster_ = caster;
  if (caster) {
    set_has_caster();
  } else {
    clear_has_caster();
  }
}

// -------------------------------------------------------------------

// buffer_operate_info

// required .client.BUFFER_LIST_METHOD_E method = 1;
inline bool buffer_operate_info::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffer_operate_info::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffer_operate_info::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffer_operate_info::clear_method() {
  method_ = 1;
  clear_has_method();
}
inline ::client::BUFFER_LIST_METHOD_E buffer_operate_info::method() const {
  return static_cast< ::client::BUFFER_LIST_METHOD_E >(method_);
}
inline void buffer_operate_info::set_method(::client::BUFFER_LIST_METHOD_E value) {
  assert(::client::BUFFER_LIST_METHOD_E_IsValid(value));
  set_has_method();
  method_ = value;
}

// required .client.buffer_info bi = 2;
inline bool buffer_operate_info::has_bi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_operate_info::set_has_bi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_operate_info::clear_has_bi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_operate_info::clear_bi() {
  if (bi_ != NULL) bi_->::client::buffer_info::Clear();
  clear_has_bi();
}
inline const ::client::buffer_info& buffer_operate_info::bi() const {
  return bi_ != NULL ? *bi_ : *default_instance_->bi_;
}
inline ::client::buffer_info* buffer_operate_info::mutable_bi() {
  set_has_bi();
  if (bi_ == NULL) bi_ = new ::client::buffer_info;
  return bi_;
}
inline ::client::buffer_info* buffer_operate_info::release_bi() {
  clear_has_bi();
  ::client::buffer_info* temp = bi_;
  bi_ = NULL;
  return temp;
}
inline void buffer_operate_info::set_allocated_bi(::client::buffer_info* bi) {
  delete bi_;
  bi_ = bi;
  if (bi) {
    set_has_bi();
  } else {
    clear_has_bi();
  }
}

// -------------------------------------------------------------------

// buffer_list

// repeated .client.buffer_operate_info boi = 1;
inline int buffer_list::boi_size() const {
  return boi_.size();
}
inline void buffer_list::clear_boi() {
  boi_.Clear();
}
inline const ::client::buffer_operate_info& buffer_list::boi(int index) const {
  return boi_.Get(index);
}
inline ::client::buffer_operate_info* buffer_list::mutable_boi(int index) {
  return boi_.Mutable(index);
}
inline ::client::buffer_operate_info* buffer_list::add_boi() {
  return boi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::buffer_operate_info >&
buffer_list::boi() const {
  return boi_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::buffer_operate_info >*
buffer_list::mutable_boi() {
  return &boi_;
}

// required .client.role_data rd = 2;
inline bool buffer_list::has_rd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_list::set_has_rd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_list::clear_has_rd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_list::clear_rd() {
  if (rd_ != NULL) rd_->::client::role_data::Clear();
  clear_has_rd();
}
inline const ::client::role_data& buffer_list::rd() const {
  return rd_ != NULL ? *rd_ : *default_instance_->rd_;
}
inline ::client::role_data* buffer_list::mutable_rd() {
  set_has_rd();
  if (rd_ == NULL) rd_ = new ::client::role_data;
  return rd_;
}
inline ::client::role_data* buffer_list::release_rd() {
  clear_has_rd();
  ::client::role_data* temp = rd_;
  rd_ = NULL;
  return temp;
}
inline void buffer_list::set_allocated_rd(::client::role_data* rd) {
  delete rd_;
  rd_ = rd;
  if (rd) {
    set_has_rd();
  } else {
    clear_has_rd();
  }
}

// -------------------------------------------------------------------

// buffer_hurt_msg

// required .client.role_data rd = 1;
inline bool buffer_hurt_msg::has_rd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffer_hurt_msg::set_has_rd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffer_hurt_msg::clear_has_rd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffer_hurt_msg::clear_rd() {
  if (rd_ != NULL) rd_->::client::role_data::Clear();
  clear_has_rd();
}
inline const ::client::role_data& buffer_hurt_msg::rd() const {
  return rd_ != NULL ? *rd_ : *default_instance_->rd_;
}
inline ::client::role_data* buffer_hurt_msg::mutable_rd() {
  set_has_rd();
  if (rd_ == NULL) rd_ = new ::client::role_data;
  return rd_;
}
inline ::client::role_data* buffer_hurt_msg::release_rd() {
  clear_has_rd();
  ::client::role_data* temp = rd_;
  rd_ = NULL;
  return temp;
}
inline void buffer_hurt_msg::set_allocated_rd(::client::role_data* rd) {
  delete rd_;
  rd_ = rd;
  if (rd) {
    set_has_rd();
  } else {
    clear_has_rd();
  }
}

// optional int32 hp = 2 [default = 0];
inline bool buffer_hurt_msg::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_hurt_msg::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_hurt_msg::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_hurt_msg::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 buffer_hurt_msg::hp() const {
  return hp_;
}
inline void buffer_hurt_msg::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 mp = 3 [default = 0];
inline bool buffer_hurt_msg::has_mp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void buffer_hurt_msg::set_has_mp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void buffer_hurt_msg::clear_has_mp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void buffer_hurt_msg::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 buffer_hurt_msg::mp() const {
  return mp_;
}
inline void buffer_hurt_msg::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
}

// optional bool dead = 4 [default = false];
inline bool buffer_hurt_msg::has_dead() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void buffer_hurt_msg::set_has_dead() {
  _has_bits_[0] |= 0x00000008u;
}
inline void buffer_hurt_msg::clear_has_dead() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void buffer_hurt_msg::clear_dead() {
  dead_ = false;
  clear_has_dead();
}
inline bool buffer_hurt_msg::dead() const {
  return dead_;
}
inline void buffer_hurt_msg::set_dead(bool value) {
  set_has_dead();
  dead_ = value;
}

// optional uint32 cur_hp = 5 [default = 0];
inline bool buffer_hurt_msg::has_cur_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void buffer_hurt_msg::set_has_cur_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void buffer_hurt_msg::clear_has_cur_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void buffer_hurt_msg::clear_cur_hp() {
  cur_hp_ = 0u;
  clear_has_cur_hp();
}
inline ::google::protobuf::uint32 buffer_hurt_msg::cur_hp() const {
  return cur_hp_;
}
inline void buffer_hurt_msg::set_cur_hp(::google::protobuf::uint32 value) {
  set_has_cur_hp();
  cur_hp_ = value;
}

// -------------------------------------------------------------------

// buffer_immune_msg

// required .client.role_data target = 1;
inline bool buffer_immune_msg::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffer_immune_msg::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffer_immune_msg::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffer_immune_msg::clear_target() {
  if (target_ != NULL) target_->::client::role_data::Clear();
  clear_has_target();
}
inline const ::client::role_data& buffer_immune_msg::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::client::role_data* buffer_immune_msg::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::client::role_data;
  return target_;
}
inline ::client::role_data* buffer_immune_msg::release_target() {
  clear_has_target();
  ::client::role_data* temp = target_;
  target_ = NULL;
  return temp;
}
inline void buffer_immune_msg::set_allocated_target(::client::role_data* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// required .client.role_data caster = 2;
inline bool buffer_immune_msg::has_caster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_immune_msg::set_has_caster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_immune_msg::clear_has_caster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_immune_msg::clear_caster() {
  if (caster_ != NULL) caster_->::client::role_data::Clear();
  clear_has_caster();
}
inline const ::client::role_data& buffer_immune_msg::caster() const {
  return caster_ != NULL ? *caster_ : *default_instance_->caster_;
}
inline ::client::role_data* buffer_immune_msg::mutable_caster() {
  set_has_caster();
  if (caster_ == NULL) caster_ = new ::client::role_data;
  return caster_;
}
inline ::client::role_data* buffer_immune_msg::release_caster() {
  clear_has_caster();
  ::client::role_data* temp = caster_;
  caster_ = NULL;
  return temp;
}
inline void buffer_immune_msg::set_allocated_caster(::client::role_data* caster) {
  delete caster_;
  caster_ = caster;
  if (caster) {
    set_has_caster();
  } else {
    clear_has_caster();
  }
}

// required uint32 id = 3;
inline bool buffer_immune_msg::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void buffer_immune_msg::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void buffer_immune_msg::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void buffer_immune_msg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 buffer_immune_msg::id() const {
  return id_;
}
inline void buffer_immune_msg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// buffer_rebound_msg

// required .client.role_data target = 1;
inline bool buffer_rebound_msg::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffer_rebound_msg::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffer_rebound_msg::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffer_rebound_msg::clear_target() {
  if (target_ != NULL) target_->::client::role_data::Clear();
  clear_has_target();
}
inline const ::client::role_data& buffer_rebound_msg::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::client::role_data* buffer_rebound_msg::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::client::role_data;
  return target_;
}
inline ::client::role_data* buffer_rebound_msg::release_target() {
  clear_has_target();
  ::client::role_data* temp = target_;
  target_ = NULL;
  return temp;
}
inline void buffer_rebound_msg::set_allocated_target(::client::role_data* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// required .client.role_data caster = 2;
inline bool buffer_rebound_msg::has_caster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffer_rebound_msg::set_has_caster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffer_rebound_msg::clear_has_caster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffer_rebound_msg::clear_caster() {
  if (caster_ != NULL) caster_->::client::role_data::Clear();
  clear_has_caster();
}
inline const ::client::role_data& buffer_rebound_msg::caster() const {
  return caster_ != NULL ? *caster_ : *default_instance_->caster_;
}
inline ::client::role_data* buffer_rebound_msg::mutable_caster() {
  set_has_caster();
  if (caster_ == NULL) caster_ = new ::client::role_data;
  return caster_;
}
inline ::client::role_data* buffer_rebound_msg::release_caster() {
  clear_has_caster();
  ::client::role_data* temp = caster_;
  caster_ = NULL;
  return temp;
}
inline void buffer_rebound_msg::set_allocated_caster(::client::role_data* caster) {
  delete caster_;
  caster_ = caster;
  if (caster) {
    set_has_caster();
  } else {
    clear_has_caster();
  }
}

// required uint32 hp = 3;
inline bool buffer_rebound_msg::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void buffer_rebound_msg::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void buffer_rebound_msg::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void buffer_rebound_msg::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 buffer_rebound_msg::hp() const {
  return hp_;
}
inline void buffer_rebound_msg::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::buffer_effect_val_OP>() {
  return ::client::buffer_effect_val_OP_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::BUFFER_LIST_METHOD_E>() {
  return ::client::BUFFER_LIST_METHOD_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eeffect_2eproto__INCLUDED
