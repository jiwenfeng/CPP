// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.attack.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "client.attack.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace client {

namespace {

const ::google::protobuf::Descriptor* attack_cell_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  attack_cell_reflection_ = NULL;
const ::google::protobuf::Descriptor* attack_req_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  attack_req_reflection_ = NULL;
const ::google::protobuf::Descriptor* attack_collision_data_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  attack_collision_data_reflection_ = NULL;
const ::google::protobuf::Descriptor* fight_data_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  fight_data_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* fight_data_TYPE_descriptor_ = NULL;
const ::google::protobuf::Descriptor* attack_rsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  attack_rsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* nearby_npc_pos_req_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  nearby_npc_pos_req_reflection_ = NULL;
const ::google::protobuf::Descriptor* nearby_npc_pos_rsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  nearby_npc_pos_rsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* hate_list_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  hate_list_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_client_2eattack_2eproto() {
  protobuf_AddDesc_client_2eattack_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "client.attack.proto");
  GOOGLE_CHECK(file != NULL);
  attack_cell_descriptor_ = file->message_type(0);
  static const int attack_cell_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_cell, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_cell, y_),
  };
  attack_cell_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      attack_cell_descriptor_,
      attack_cell::default_instance_,
      attack_cell_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_cell, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_cell, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(attack_cell));
  attack_req_descriptor_ = file->message_type(1);
  static const int attack_req_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_req, skill_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_req, rd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_req, ac_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_req, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_req, svr_head_),
  };
  attack_req_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      attack_req_descriptor_,
      attack_req::default_instance_,
      attack_req_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_req, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_req, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(attack_req));
  attack_collision_data_descriptor_ = file->message_type(2);
  static const int attack_collision_data_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_collision_data, move_speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_collision_data, pos_),
  };
  attack_collision_data_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      attack_collision_data_descriptor_,
      attack_collision_data::default_instance_,
      attack_collision_data_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_collision_data, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_collision_data, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(attack_collision_data));
  fight_data_descriptor_ = file->message_type(3);
  static const int fight_data_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, dst_rd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, fight_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, critical_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, acd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, dead_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, cur_hp_),
  };
  fight_data_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      fight_data_descriptor_,
      fight_data::default_instance_,
      fight_data_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(fight_data, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(fight_data));
  fight_data_TYPE_descriptor_ = fight_data_descriptor_->enum_type(0);
  attack_rsp_descriptor_ = file->message_type(4);
  static const int attack_rsp_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, src_rd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, ac_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, skill_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, fd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, def_),
  };
  attack_rsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      attack_rsp_descriptor_,
      attack_rsp::default_instance_,
      attack_rsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attack_rsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(attack_rsp));
  nearby_npc_pos_req_descriptor_ = file->message_type(5);
  static const int nearby_npc_pos_req_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_req, unixtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_req, svr_head_),
  };
  nearby_npc_pos_req_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      nearby_npc_pos_req_descriptor_,
      nearby_npc_pos_req::default_instance_,
      nearby_npc_pos_req_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_req, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_req, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(nearby_npc_pos_req));
  nearby_npc_pos_rsp_descriptor_ = file->message_type(6);
  static const int nearby_npc_pos_rsp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_rsp, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_rsp, ret_),
  };
  nearby_npc_pos_rsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      nearby_npc_pos_rsp_descriptor_,
      nearby_npc_pos_rsp::default_instance_,
      nearby_npc_pos_rsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_rsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(nearby_npc_pos_rsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(nearby_npc_pos_rsp));
  hate_list_descriptor_ = file->message_type(7);
  static const int hate_list_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(hate_list, target_),
  };
  hate_list_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      hate_list_descriptor_,
      hate_list::default_instance_,
      hate_list_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(hate_list, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(hate_list, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(hate_list));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_client_2eattack_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    attack_cell_descriptor_, &attack_cell::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    attack_req_descriptor_, &attack_req::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    attack_collision_data_descriptor_, &attack_collision_data::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    fight_data_descriptor_, &fight_data::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    attack_rsp_descriptor_, &attack_rsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    nearby_npc_pos_req_descriptor_, &nearby_npc_pos_req::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    nearby_npc_pos_rsp_descriptor_, &nearby_npc_pos_rsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    hate_list_descriptor_, &hate_list::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_client_2eattack_2eproto() {
  delete attack_cell::default_instance_;
  delete attack_cell_reflection_;
  delete attack_req::default_instance_;
  delete attack_req_reflection_;
  delete attack_collision_data::default_instance_;
  delete attack_collision_data_reflection_;
  delete fight_data::default_instance_;
  delete fight_data_reflection_;
  delete attack_rsp::default_instance_;
  delete attack_rsp_reflection_;
  delete nearby_npc_pos_req::default_instance_;
  delete nearby_npc_pos_req_reflection_;
  delete nearby_npc_pos_rsp::default_instance_;
  delete nearby_npc_pos_rsp_reflection_;
  delete hate_list::default_instance_;
  delete hate_list_reflection_;
}

void protobuf_AddDesc_client_2eattack_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::client::protobuf_AddDesc_client_2ecomm_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023client.attack.proto\022\006client\032\021client.co"
    "mm.proto\"#\n\013attack_cell\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030"
    "\002 \002(\002\"\222\001\n\nattack_req\022\020\n\010skill_id\030\001 \002(\r\022\035"
    "\n\002rd\030\002 \003(\0132\021.client.role_data\022\037\n\002ac\030\003 \001("
    "\0132\023.client.attack_cell\022\n\n\002id\030\004 \002(\r\022&\n\010sv"
    "r_head\030\350\007 \001(\0132\023.client.server_head\"P\n\025at"
    "tack_collision_data\022\022\n\nmove_speed\030\001 \002(\r\022"
    "#\n\003pos\030\002 \002(\0132\026.client.client_map_pos\"\311\003\n"
    "\nfight_data\022!\n\006dst_rd\030\001 \001(\0132\021.client.rol"
    "e_data\022+\n\nfight_type\030\002 \002(\0162\027.client.figh"
    "t_data.TYPE\022\020\n\010critical\030\003 \001(\r\022\014\n\004data\030\004 "
    "\001(\r\022*\n\003acd\030\005 \001(\0132\035.client.attack_collisi"
    "on_data\022\014\n\004dead\030\006 \001(\010\022#\n\003pos\030\007 \001(\0132\026.cli"
    "ent.client_map_pos\022\016\n\006cur_hp\030\010 \001(\r\"\333\001\n\004T"
    "YPE\022\r\n\tattk_miss\020\000\022\016\n\nattk_metal\020\001\022\r\n\tat"
    "tk_wood\020\002\022\016\n\nattk_water\020\003\022\r\n\tattk_fire\020\004"
    "\022\r\n\tattk_soil\020\005\022\017\n\013attk_normal\020\006\022\017\n\013attk"
    "_return\020\007\022\016\n\nattk_dodge\020\010\022\014\n\010attk_inc\020\t\022"
    "\014\n\010attk_dec\020\n\022\014\n\010attk_pos\020\013\022\r\n\tattk_buff"
    "\020\014\022\014\n\010attk_far\020\r\"\233\001\n\nattack_rsp\022!\n\006src_r"
    "d\030\001 \002(\0132\021.client.role_data\022\037\n\002ac\030\002 \001(\0132\023"
    ".client.attack_cell\022\020\n\010skill_id\030\003 \002(\r\022\036\n"
    "\002fd\030\004 \003(\0132\022.client.fight_data\022\n\n\002id\030\005 \002("
    "\r\022\013\n\003def\030\006 \001(\010\"N\n\022nearby_npc_pos_req\022\020\n\010"
    "unixtime\030\001 \002(\r\022&\n\010svr_head\030\350\007 \001(\0132\023.clie"
    "nt.server_head\"F\n\022nearby_npc_pos_rsp\022#\n\003"
    "pos\030\001 \003(\0132\026.client.client_map_pos\022\013\n\003ret"
    "\030\002 \002(\r\".\n\thate_list\022!\n\006target\030\001 \003(\0132\021.cl"
    "ient.role_name", 1134);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "client.attack.proto", &protobuf_RegisterTypes);
  attack_cell::default_instance_ = new attack_cell();
  attack_req::default_instance_ = new attack_req();
  attack_collision_data::default_instance_ = new attack_collision_data();
  fight_data::default_instance_ = new fight_data();
  attack_rsp::default_instance_ = new attack_rsp();
  nearby_npc_pos_req::default_instance_ = new nearby_npc_pos_req();
  nearby_npc_pos_rsp::default_instance_ = new nearby_npc_pos_rsp();
  hate_list::default_instance_ = new hate_list();
  attack_cell::default_instance_->InitAsDefaultInstance();
  attack_req::default_instance_->InitAsDefaultInstance();
  attack_collision_data::default_instance_->InitAsDefaultInstance();
  fight_data::default_instance_->InitAsDefaultInstance();
  attack_rsp::default_instance_->InitAsDefaultInstance();
  nearby_npc_pos_req::default_instance_->InitAsDefaultInstance();
  nearby_npc_pos_rsp::default_instance_->InitAsDefaultInstance();
  hate_list::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_client_2eattack_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_client_2eattack_2eproto {
  StaticDescriptorInitializer_client_2eattack_2eproto() {
    protobuf_AddDesc_client_2eattack_2eproto();
  }
} static_descriptor_initializer_client_2eattack_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int attack_cell::kXFieldNumber;
const int attack_cell::kYFieldNumber;
#endif  // !_MSC_VER

attack_cell::attack_cell()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void attack_cell::InitAsDefaultInstance() {
}

attack_cell::attack_cell(const attack_cell& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void attack_cell::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

attack_cell::~attack_cell() {
  SharedDtor();
}

void attack_cell::SharedDtor() {
  if (this != default_instance_) {
  }
}

void attack_cell::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* attack_cell::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return attack_cell_descriptor_;
}

const attack_cell& attack_cell::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

attack_cell* attack_cell::default_instance_ = NULL;

attack_cell* attack_cell::New() const {
  return new attack_cell;
}

void attack_cell::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool attack_cell::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void attack_cell::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* attack_cell::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int attack_cell::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void attack_cell::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const attack_cell* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const attack_cell*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void attack_cell::MergeFrom(const attack_cell& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void attack_cell::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void attack_cell::CopyFrom(const attack_cell& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attack_cell::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void attack_cell::Swap(attack_cell* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata attack_cell::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = attack_cell_descriptor_;
  metadata.reflection = attack_cell_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int attack_req::kSkillIdFieldNumber;
const int attack_req::kRdFieldNumber;
const int attack_req::kAcFieldNumber;
const int attack_req::kIdFieldNumber;
const int attack_req::kSvrHeadFieldNumber;
#endif  // !_MSC_VER

attack_req::attack_req()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void attack_req::InitAsDefaultInstance() {
  ac_ = const_cast< ::client::attack_cell*>(&::client::attack_cell::default_instance());
  svr_head_ = const_cast< ::client::server_head*>(&::client::server_head::default_instance());
}

attack_req::attack_req(const attack_req& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void attack_req::SharedCtor() {
  _cached_size_ = 0;
  skill_id_ = 0u;
  ac_ = NULL;
  id_ = 0u;
  svr_head_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

attack_req::~attack_req() {
  SharedDtor();
}

void attack_req::SharedDtor() {
  if (this != default_instance_) {
    delete ac_;
    delete svr_head_;
  }
}

void attack_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* attack_req::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return attack_req_descriptor_;
}

const attack_req& attack_req::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

attack_req* attack_req::default_instance_ = NULL;

attack_req* attack_req::New() const {
  return new attack_req;
}

void attack_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    skill_id_ = 0u;
    if (has_ac()) {
      if (ac_ != NULL) ac_->::client::attack_cell::Clear();
    }
    id_ = 0u;
    if (has_svr_head()) {
      if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
    }
  }
  rd_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool attack_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 skill_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rd;
        break;
      }

      // repeated .client.role_data rd = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rd;
        if (input->ExpectTag(26)) goto parse_ac;
        break;
      }

      // optional .client.attack_cell ac = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ac:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ac()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_id;
        break;
      }

      // required uint32 id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8002)) goto parse_svr_head;
        break;
      }

      // optional .client.server_head svr_head = 1000;
      case 1000: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_svr_head:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_svr_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void attack_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 skill_id = 1;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->skill_id(), output);
  }

  // repeated .client.role_data rd = 2;
  for (int i = 0; i < this->rd_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rd(i), output);
  }

  // optional .client.attack_cell ac = 3;
  if (has_ac()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->ac(), output);
  }

  // required uint32 id = 4;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->id(), output);
  }

  // optional .client.server_head svr_head = 1000;
  if (has_svr_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1000, this->svr_head(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* attack_req::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 skill_id = 1;
  if (has_skill_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->skill_id(), target);
  }

  // repeated .client.role_data rd = 2;
  for (int i = 0; i < this->rd_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rd(i), target);
  }

  // optional .client.attack_cell ac = 3;
  if (has_ac()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->ac(), target);
  }

  // required uint32 id = 4;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->id(), target);
  }

  // optional .client.server_head svr_head = 1000;
  if (has_svr_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1000, this->svr_head(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int attack_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 skill_id = 1;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id());
    }

    // optional .client.attack_cell ac = 3;
    if (has_ac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ac());
    }

    // required uint32 id = 4;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional .client.server_head svr_head = 1000;
    if (has_svr_head()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->svr_head());
    }

  }
  // repeated .client.role_data rd = 2;
  total_size += 1 * this->rd_size();
  for (int i = 0; i < this->rd_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rd(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void attack_req::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const attack_req* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const attack_req*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void attack_req::MergeFrom(const attack_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  rd_.MergeFrom(from.rd_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
    if (from.has_ac()) {
      mutable_ac()->::client::attack_cell::MergeFrom(from.ac());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_svr_head()) {
      mutable_svr_head()->::client::server_head::MergeFrom(from.svr_head());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void attack_req::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void attack_req::CopyFrom(const attack_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attack_req::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  for (int i = 0; i < rd_size(); i++) {
    if (!this->rd(i).IsInitialized()) return false;
  }
  if (has_ac()) {
    if (!this->ac().IsInitialized()) return false;
  }
  return true;
}

void attack_req::Swap(attack_req* other) {
  if (other != this) {
    std::swap(skill_id_, other->skill_id_);
    rd_.Swap(&other->rd_);
    std::swap(ac_, other->ac_);
    std::swap(id_, other->id_);
    std::swap(svr_head_, other->svr_head_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata attack_req::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = attack_req_descriptor_;
  metadata.reflection = attack_req_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int attack_collision_data::kMoveSpeedFieldNumber;
const int attack_collision_data::kPosFieldNumber;
#endif  // !_MSC_VER

attack_collision_data::attack_collision_data()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void attack_collision_data::InitAsDefaultInstance() {
  pos_ = const_cast< ::client::client_map_pos*>(&::client::client_map_pos::default_instance());
}

attack_collision_data::attack_collision_data(const attack_collision_data& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void attack_collision_data::SharedCtor() {
  _cached_size_ = 0;
  move_speed_ = 0u;
  pos_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

attack_collision_data::~attack_collision_data() {
  SharedDtor();
}

void attack_collision_data::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
  }
}

void attack_collision_data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* attack_collision_data::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return attack_collision_data_descriptor_;
}

const attack_collision_data& attack_collision_data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

attack_collision_data* attack_collision_data::default_instance_ = NULL;

attack_collision_data* attack_collision_data::New() const {
  return new attack_collision_data;
}

void attack_collision_data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    move_speed_ = 0u;
    if (has_pos()) {
      if (pos_ != NULL) pos_->::client::client_map_pos::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool attack_collision_data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 move_speed = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &move_speed_)));
          set_has_move_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pos;
        break;
      }

      // required .client.client_map_pos pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void attack_collision_data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 move_speed = 1;
  if (has_move_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->move_speed(), output);
  }

  // required .client.client_map_pos pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->pos(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* attack_collision_data::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 move_speed = 1;
  if (has_move_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->move_speed(), target);
  }

  // required .client.client_map_pos pos = 2;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->pos(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int attack_collision_data::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 move_speed = 1;
    if (has_move_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->move_speed());
    }

    // required .client.client_map_pos pos = 2;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void attack_collision_data::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const attack_collision_data* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const attack_collision_data*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void attack_collision_data::MergeFrom(const attack_collision_data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_move_speed()) {
      set_move_speed(from.move_speed());
    }
    if (from.has_pos()) {
      mutable_pos()->::client::client_map_pos::MergeFrom(from.pos());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void attack_collision_data::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void attack_collision_data::CopyFrom(const attack_collision_data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attack_collision_data::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_pos()) {
    if (!this->pos().IsInitialized()) return false;
  }
  return true;
}

void attack_collision_data::Swap(attack_collision_data* other) {
  if (other != this) {
    std::swap(move_speed_, other->move_speed_);
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata attack_collision_data::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = attack_collision_data_descriptor_;
  metadata.reflection = attack_collision_data_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* fight_data_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return fight_data_TYPE_descriptor_;
}
bool fight_data_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const fight_data_TYPE fight_data::attk_miss;
const fight_data_TYPE fight_data::attk_metal;
const fight_data_TYPE fight_data::attk_wood;
const fight_data_TYPE fight_data::attk_water;
const fight_data_TYPE fight_data::attk_fire;
const fight_data_TYPE fight_data::attk_soil;
const fight_data_TYPE fight_data::attk_normal;
const fight_data_TYPE fight_data::attk_return;
const fight_data_TYPE fight_data::attk_dodge;
const fight_data_TYPE fight_data::attk_inc;
const fight_data_TYPE fight_data::attk_dec;
const fight_data_TYPE fight_data::attk_pos;
const fight_data_TYPE fight_data::attk_buff;
const fight_data_TYPE fight_data::attk_far;
const fight_data_TYPE fight_data::TYPE_MIN;
const fight_data_TYPE fight_data::TYPE_MAX;
const int fight_data::TYPE_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int fight_data::kDstRdFieldNumber;
const int fight_data::kFightTypeFieldNumber;
const int fight_data::kCriticalFieldNumber;
const int fight_data::kDataFieldNumber;
const int fight_data::kAcdFieldNumber;
const int fight_data::kDeadFieldNumber;
const int fight_data::kPosFieldNumber;
const int fight_data::kCurHpFieldNumber;
#endif  // !_MSC_VER

fight_data::fight_data()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void fight_data::InitAsDefaultInstance() {
  dst_rd_ = const_cast< ::client::role_data*>(&::client::role_data::default_instance());
  acd_ = const_cast< ::client::attack_collision_data*>(&::client::attack_collision_data::default_instance());
  pos_ = const_cast< ::client::client_map_pos*>(&::client::client_map_pos::default_instance());
}

fight_data::fight_data(const fight_data& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void fight_data::SharedCtor() {
  _cached_size_ = 0;
  dst_rd_ = NULL;
  fight_type_ = 0;
  critical_ = 0u;
  data_ = 0u;
  acd_ = NULL;
  dead_ = false;
  pos_ = NULL;
  cur_hp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

fight_data::~fight_data() {
  SharedDtor();
}

void fight_data::SharedDtor() {
  if (this != default_instance_) {
    delete dst_rd_;
    delete acd_;
    delete pos_;
  }
}

void fight_data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* fight_data::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return fight_data_descriptor_;
}

const fight_data& fight_data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

fight_data* fight_data::default_instance_ = NULL;

fight_data* fight_data::New() const {
  return new fight_data;
}

void fight_data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dst_rd()) {
      if (dst_rd_ != NULL) dst_rd_->::client::role_data::Clear();
    }
    fight_type_ = 0;
    critical_ = 0u;
    data_ = 0u;
    if (has_acd()) {
      if (acd_ != NULL) acd_->::client::attack_collision_data::Clear();
    }
    dead_ = false;
    if (has_pos()) {
      if (pos_ != NULL) pos_->::client::client_map_pos::Clear();
    }
    cur_hp_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool fight_data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .client.role_data dst_rd = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dst_rd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fight_type;
        break;
      }

      // required .client.fight_data.TYPE fight_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::client::fight_data_TYPE_IsValid(value)) {
            set_fight_type(static_cast< ::client::fight_data_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_critical;
        break;
      }

      // optional uint32 critical = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_critical:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &critical_)));
          set_has_critical();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_data;
        break;
      }

      // optional uint32 data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_)));
          set_has_data();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_acd;
        break;
      }

      // optional .client.attack_collision_data acd = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_acd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_acd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_dead;
        break;
      }

      // optional bool dead = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dead:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &dead_)));
          set_has_dead();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_pos;
        break;
      }

      // optional .client.client_map_pos pos = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_cur_hp;
        break;
      }

      // optional uint32 cur_hp = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cur_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_hp_)));
          set_has_cur_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void fight_data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .client.role_data dst_rd = 1;
  if (has_dst_rd()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dst_rd(), output);
  }

  // required .client.fight_data.TYPE fight_type = 2;
  if (has_fight_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->fight_type(), output);
  }

  // optional uint32 critical = 3;
  if (has_critical()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->critical(), output);
  }

  // optional uint32 data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->data(), output);
  }

  // optional .client.attack_collision_data acd = 5;
  if (has_acd()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->acd(), output);
  }

  // optional bool dead = 6;
  if (has_dead()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->dead(), output);
  }

  // optional .client.client_map_pos pos = 7;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->pos(), output);
  }

  // optional uint32 cur_hp = 8;
  if (has_cur_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->cur_hp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* fight_data::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .client.role_data dst_rd = 1;
  if (has_dst_rd()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dst_rd(), target);
  }

  // required .client.fight_data.TYPE fight_type = 2;
  if (has_fight_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->fight_type(), target);
  }

  // optional uint32 critical = 3;
  if (has_critical()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->critical(), target);
  }

  // optional uint32 data = 4;
  if (has_data()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->data(), target);
  }

  // optional .client.attack_collision_data acd = 5;
  if (has_acd()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->acd(), target);
  }

  // optional bool dead = 6;
  if (has_dead()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->dead(), target);
  }

  // optional .client.client_map_pos pos = 7;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->pos(), target);
  }

  // optional uint32 cur_hp = 8;
  if (has_cur_hp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->cur_hp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int fight_data::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .client.role_data dst_rd = 1;
    if (has_dst_rd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dst_rd());
    }

    // required .client.fight_data.TYPE fight_type = 2;
    if (has_fight_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->fight_type());
    }

    // optional uint32 critical = 3;
    if (has_critical()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->critical());
    }

    // optional uint32 data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data());
    }

    // optional .client.attack_collision_data acd = 5;
    if (has_acd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->acd());
    }

    // optional bool dead = 6;
    if (has_dead()) {
      total_size += 1 + 1;
    }

    // optional .client.client_map_pos pos = 7;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

    // optional uint32 cur_hp = 8;
    if (has_cur_hp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cur_hp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void fight_data::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const fight_data* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const fight_data*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void fight_data::MergeFrom(const fight_data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dst_rd()) {
      mutable_dst_rd()->::client::role_data::MergeFrom(from.dst_rd());
    }
    if (from.has_fight_type()) {
      set_fight_type(from.fight_type());
    }
    if (from.has_critical()) {
      set_critical(from.critical());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_acd()) {
      mutable_acd()->::client::attack_collision_data::MergeFrom(from.acd());
    }
    if (from.has_dead()) {
      set_dead(from.dead());
    }
    if (from.has_pos()) {
      mutable_pos()->::client::client_map_pos::MergeFrom(from.pos());
    }
    if (from.has_cur_hp()) {
      set_cur_hp(from.cur_hp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void fight_data::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void fight_data::CopyFrom(const fight_data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool fight_data::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_dst_rd()) {
    if (!this->dst_rd().IsInitialized()) return false;
  }
  if (has_acd()) {
    if (!this->acd().IsInitialized()) return false;
  }
  if (has_pos()) {
    if (!this->pos().IsInitialized()) return false;
  }
  return true;
}

void fight_data::Swap(fight_data* other) {
  if (other != this) {
    std::swap(dst_rd_, other->dst_rd_);
    std::swap(fight_type_, other->fight_type_);
    std::swap(critical_, other->critical_);
    std::swap(data_, other->data_);
    std::swap(acd_, other->acd_);
    std::swap(dead_, other->dead_);
    std::swap(pos_, other->pos_);
    std::swap(cur_hp_, other->cur_hp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata fight_data::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = fight_data_descriptor_;
  metadata.reflection = fight_data_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int attack_rsp::kSrcRdFieldNumber;
const int attack_rsp::kAcFieldNumber;
const int attack_rsp::kSkillIdFieldNumber;
const int attack_rsp::kFdFieldNumber;
const int attack_rsp::kIdFieldNumber;
const int attack_rsp::kDefFieldNumber;
#endif  // !_MSC_VER

attack_rsp::attack_rsp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void attack_rsp::InitAsDefaultInstance() {
  src_rd_ = const_cast< ::client::role_data*>(&::client::role_data::default_instance());
  ac_ = const_cast< ::client::attack_cell*>(&::client::attack_cell::default_instance());
}

attack_rsp::attack_rsp(const attack_rsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void attack_rsp::SharedCtor() {
  _cached_size_ = 0;
  src_rd_ = NULL;
  ac_ = NULL;
  skill_id_ = 0u;
  id_ = 0u;
  def_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

attack_rsp::~attack_rsp() {
  SharedDtor();
}

void attack_rsp::SharedDtor() {
  if (this != default_instance_) {
    delete src_rd_;
    delete ac_;
  }
}

void attack_rsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* attack_rsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return attack_rsp_descriptor_;
}

const attack_rsp& attack_rsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

attack_rsp* attack_rsp::default_instance_ = NULL;

attack_rsp* attack_rsp::New() const {
  return new attack_rsp;
}

void attack_rsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_src_rd()) {
      if (src_rd_ != NULL) src_rd_->::client::role_data::Clear();
    }
    if (has_ac()) {
      if (ac_ != NULL) ac_->::client::attack_cell::Clear();
    }
    skill_id_ = 0u;
    id_ = 0u;
    def_ = false;
  }
  fd_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool attack_rsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .client.role_data src_rd = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_src_rd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ac;
        break;
      }

      // optional .client.attack_cell ac = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ac:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ac()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skill_id;
        break;
      }

      // required uint32 skill_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_fd;
        break;
      }

      // repeated .client.fight_data fd = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_fd;
        if (input->ExpectTag(40)) goto parse_id;
        break;
      }

      // required uint32 id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_def;
        break;
      }

      // optional bool def = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_def:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &def_)));
          set_has_def();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void attack_rsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .client.role_data src_rd = 1;
  if (has_src_rd()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->src_rd(), output);
  }

  // optional .client.attack_cell ac = 2;
  if (has_ac()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->ac(), output);
  }

  // required uint32 skill_id = 3;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->skill_id(), output);
  }

  // repeated .client.fight_data fd = 4;
  for (int i = 0; i < this->fd_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->fd(i), output);
  }

  // required uint32 id = 5;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->id(), output);
  }

  // optional bool def = 6;
  if (has_def()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->def(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* attack_rsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .client.role_data src_rd = 1;
  if (has_src_rd()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->src_rd(), target);
  }

  // optional .client.attack_cell ac = 2;
  if (has_ac()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->ac(), target);
  }

  // required uint32 skill_id = 3;
  if (has_skill_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->skill_id(), target);
  }

  // repeated .client.fight_data fd = 4;
  for (int i = 0; i < this->fd_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->fd(i), target);
  }

  // required uint32 id = 5;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->id(), target);
  }

  // optional bool def = 6;
  if (has_def()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->def(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int attack_rsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .client.role_data src_rd = 1;
    if (has_src_rd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->src_rd());
    }

    // optional .client.attack_cell ac = 2;
    if (has_ac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ac());
    }

    // required uint32 skill_id = 3;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id());
    }

    // required uint32 id = 5;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional bool def = 6;
    if (has_def()) {
      total_size += 1 + 1;
    }

  }
  // repeated .client.fight_data fd = 4;
  total_size += 1 * this->fd_size();
  for (int i = 0; i < this->fd_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fd(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void attack_rsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const attack_rsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const attack_rsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void attack_rsp::MergeFrom(const attack_rsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  fd_.MergeFrom(from.fd_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_src_rd()) {
      mutable_src_rd()->::client::role_data::MergeFrom(from.src_rd());
    }
    if (from.has_ac()) {
      mutable_ac()->::client::attack_cell::MergeFrom(from.ac());
    }
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_def()) {
      set_def(from.def());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void attack_rsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void attack_rsp::CopyFrom(const attack_rsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attack_rsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000015) != 0x00000015) return false;

  if (has_src_rd()) {
    if (!this->src_rd().IsInitialized()) return false;
  }
  if (has_ac()) {
    if (!this->ac().IsInitialized()) return false;
  }
  for (int i = 0; i < fd_size(); i++) {
    if (!this->fd(i).IsInitialized()) return false;
  }
  return true;
}

void attack_rsp::Swap(attack_rsp* other) {
  if (other != this) {
    std::swap(src_rd_, other->src_rd_);
    std::swap(ac_, other->ac_);
    std::swap(skill_id_, other->skill_id_);
    fd_.Swap(&other->fd_);
    std::swap(id_, other->id_);
    std::swap(def_, other->def_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata attack_rsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = attack_rsp_descriptor_;
  metadata.reflection = attack_rsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int nearby_npc_pos_req::kUnixtimeFieldNumber;
const int nearby_npc_pos_req::kSvrHeadFieldNumber;
#endif  // !_MSC_VER

nearby_npc_pos_req::nearby_npc_pos_req()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void nearby_npc_pos_req::InitAsDefaultInstance() {
  svr_head_ = const_cast< ::client::server_head*>(&::client::server_head::default_instance());
}

nearby_npc_pos_req::nearby_npc_pos_req(const nearby_npc_pos_req& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void nearby_npc_pos_req::SharedCtor() {
  _cached_size_ = 0;
  unixtime_ = 0u;
  svr_head_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

nearby_npc_pos_req::~nearby_npc_pos_req() {
  SharedDtor();
}

void nearby_npc_pos_req::SharedDtor() {
  if (this != default_instance_) {
    delete svr_head_;
  }
}

void nearby_npc_pos_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* nearby_npc_pos_req::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return nearby_npc_pos_req_descriptor_;
}

const nearby_npc_pos_req& nearby_npc_pos_req::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

nearby_npc_pos_req* nearby_npc_pos_req::default_instance_ = NULL;

nearby_npc_pos_req* nearby_npc_pos_req::New() const {
  return new nearby_npc_pos_req;
}

void nearby_npc_pos_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    unixtime_ = 0u;
    if (has_svr_head()) {
      if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool nearby_npc_pos_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unixtime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unixtime_)));
          set_has_unixtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8002)) goto parse_svr_head;
        break;
      }

      // optional .client.server_head svr_head = 1000;
      case 1000: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_svr_head:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_svr_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void nearby_npc_pos_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 unixtime = 1;
  if (has_unixtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unixtime(), output);
  }

  // optional .client.server_head svr_head = 1000;
  if (has_svr_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1000, this->svr_head(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* nearby_npc_pos_req::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 unixtime = 1;
  if (has_unixtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->unixtime(), target);
  }

  // optional .client.server_head svr_head = 1000;
  if (has_svr_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1000, this->svr_head(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int nearby_npc_pos_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unixtime = 1;
    if (has_unixtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unixtime());
    }

    // optional .client.server_head svr_head = 1000;
    if (has_svr_head()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->svr_head());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void nearby_npc_pos_req::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const nearby_npc_pos_req* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const nearby_npc_pos_req*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void nearby_npc_pos_req::MergeFrom(const nearby_npc_pos_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unixtime()) {
      set_unixtime(from.unixtime());
    }
    if (from.has_svr_head()) {
      mutable_svr_head()->::client::server_head::MergeFrom(from.svr_head());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void nearby_npc_pos_req::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void nearby_npc_pos_req::CopyFrom(const nearby_npc_pos_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool nearby_npc_pos_req::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void nearby_npc_pos_req::Swap(nearby_npc_pos_req* other) {
  if (other != this) {
    std::swap(unixtime_, other->unixtime_);
    std::swap(svr_head_, other->svr_head_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata nearby_npc_pos_req::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = nearby_npc_pos_req_descriptor_;
  metadata.reflection = nearby_npc_pos_req_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int nearby_npc_pos_rsp::kPosFieldNumber;
const int nearby_npc_pos_rsp::kRetFieldNumber;
#endif  // !_MSC_VER

nearby_npc_pos_rsp::nearby_npc_pos_rsp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void nearby_npc_pos_rsp::InitAsDefaultInstance() {
}

nearby_npc_pos_rsp::nearby_npc_pos_rsp(const nearby_npc_pos_rsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void nearby_npc_pos_rsp::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

nearby_npc_pos_rsp::~nearby_npc_pos_rsp() {
  SharedDtor();
}

void nearby_npc_pos_rsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void nearby_npc_pos_rsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* nearby_npc_pos_rsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return nearby_npc_pos_rsp_descriptor_;
}

const nearby_npc_pos_rsp& nearby_npc_pos_rsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

nearby_npc_pos_rsp* nearby_npc_pos_rsp::default_instance_ = NULL;

nearby_npc_pos_rsp* nearby_npc_pos_rsp::New() const {
  return new nearby_npc_pos_rsp;
}

void nearby_npc_pos_rsp::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    ret_ = 0u;
  }
  pos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool nearby_npc_pos_rsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .client.client_map_pos pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_pos;
        if (input->ExpectTag(16)) goto parse_ret;
        break;
      }

      // required uint32 ret = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void nearby_npc_pos_rsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .client.client_map_pos pos = 1;
  for (int i = 0; i < this->pos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pos(i), output);
  }

  // required uint32 ret = 2;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* nearby_npc_pos_rsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .client.client_map_pos pos = 1;
  for (int i = 0; i < this->pos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pos(i), target);
  }

  // required uint32 ret = 2;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int nearby_npc_pos_rsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 ret = 2;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

  }
  // repeated .client.client_map_pos pos = 1;
  total_size += 1 * this->pos_size();
  for (int i = 0; i < this->pos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pos(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void nearby_npc_pos_rsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const nearby_npc_pos_rsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const nearby_npc_pos_rsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void nearby_npc_pos_rsp::MergeFrom(const nearby_npc_pos_rsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  pos_.MergeFrom(from.pos_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void nearby_npc_pos_rsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void nearby_npc_pos_rsp::CopyFrom(const nearby_npc_pos_rsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool nearby_npc_pos_rsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  for (int i = 0; i < pos_size(); i++) {
    if (!this->pos(i).IsInitialized()) return false;
  }
  return true;
}

void nearby_npc_pos_rsp::Swap(nearby_npc_pos_rsp* other) {
  if (other != this) {
    pos_.Swap(&other->pos_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata nearby_npc_pos_rsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = nearby_npc_pos_rsp_descriptor_;
  metadata.reflection = nearby_npc_pos_rsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int hate_list::kTargetFieldNumber;
#endif  // !_MSC_VER

hate_list::hate_list()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void hate_list::InitAsDefaultInstance() {
}

hate_list::hate_list(const hate_list& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void hate_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

hate_list::~hate_list() {
  SharedDtor();
}

void hate_list::SharedDtor() {
  if (this != default_instance_) {
  }
}

void hate_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* hate_list::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return hate_list_descriptor_;
}

const hate_list& hate_list::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eattack_2eproto();
  return *default_instance_;
}

hate_list* hate_list::default_instance_ = NULL;

hate_list* hate_list::New() const {
  return new hate_list;
}

void hate_list::Clear() {
  target_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool hate_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .client.role_name target = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_target()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_target;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void hate_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .client.role_name target = 1;
  for (int i = 0; i < this->target_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->target(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* hate_list::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .client.role_name target = 1;
  for (int i = 0; i < this->target_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->target(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int hate_list::ByteSize() const {
  int total_size = 0;

  // repeated .client.role_name target = 1;
  total_size += 1 * this->target_size();
  for (int i = 0; i < this->target_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->target(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void hate_list::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const hate_list* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const hate_list*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void hate_list::MergeFrom(const hate_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_.MergeFrom(from.target_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void hate_list::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void hate_list::CopyFrom(const hate_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool hate_list::IsInitialized() const {

  for (int i = 0; i < target_size(); i++) {
    if (!this->target(i).IsInitialized()) return false;
  }
  return true;
}

void hate_list::Swap(hate_list* other) {
  if (other != this) {
    target_.Swap(&other->target_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata hate_list::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = hate_list_descriptor_;
  metadata.reflection = hate_list_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

// @@protoc_insertion_point(global_scope)
