// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.arena.proto

#ifndef PROTOBUF_client_2earena_2eproto__INCLUDED
#define PROTOBUF_client_2earena_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "client.comm.pb.h"
#include "client.pets.pb.h"
#include "client.role_skill_msg.pb.h"
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2earena_2eproto();
void protobuf_AssignDesc_client_2earena_2eproto();
void protobuf_ShutdownFile_client_2earena_2eproto();

class role_info;
class arena_fight_ret;
class arena_info_req;
class arena_info_rsp;
class arena_personal_info_req;
class arena_personal_info_rsp;
class arena_record_req;
class arena_record_info;
class arena_record_rsp;
class arena_refresh_req;
class arena_refresh_rsp;
class arena_speed_up_req;
class arena_speed_up_rsp;
class arena_challenge_req;
class arena_challenge_result;
class robot_attr;
class load_target_data_req;
class load_target_data_rsp;
class load_online_target_data_req;
class arena_reward_req;
class reward_info;
class arena_reward_item;
class arena_reward_rsp;
class arena_rank_list_req;
class rank_list_item;
class arena_rank_list_rsp;
class arena_fight_begin;

enum FIGHT_RET_E {
  FIGHT_WIN = 0,
  FIGHT_LOSE = 1
};
bool FIGHT_RET_E_IsValid(int value);
const FIGHT_RET_E FIGHT_RET_E_MIN = FIGHT_WIN;
const FIGHT_RET_E FIGHT_RET_E_MAX = FIGHT_LOSE;
const int FIGHT_RET_E_ARRAYSIZE = FIGHT_RET_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* FIGHT_RET_E_descriptor();
inline const ::std::string& FIGHT_RET_E_Name(FIGHT_RET_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    FIGHT_RET_E_descriptor(), value);
}
inline bool FIGHT_RET_E_Parse(
    const ::std::string& name, FIGHT_RET_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FIGHT_RET_E>(
    FIGHT_RET_E_descriptor(), name, value);
}
// ===================================================================

class role_info : public ::google::protobuf::Message {
 public:
  role_info();
  virtual ~role_info();

  role_info(const role_info& from);

  inline role_info& operator=(const role_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_info& default_instance();

  void Swap(role_info* other);

  // implements Message ----------------------------------------------

  role_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_info& from);
  void MergeFrom(const role_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required uint32 rank = 2;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 profession = 5;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 5;
  inline ::google::protobuf::uint32 profession() const;
  inline void set_profession(::google::protobuf::uint32 value);

  // optional uint32 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 weapon_id = 7;
  inline bool has_weapon_id() const;
  inline void clear_weapon_id();
  static const int kWeaponIdFieldNumber = 7;
  inline ::google::protobuf::uint32 weapon_id() const;
  inline void set_weapon_id(::google::protobuf::uint32 value);

  // optional uint32 armor_id = 8;
  inline bool has_armor_id() const;
  inline void clear_armor_id();
  static const int kArmorIdFieldNumber = 8;
  inline ::google::protobuf::uint32 armor_id() const;
  inline void set_armor_id(::google::protobuf::uint32 value);

  // optional uint32 fighting_power = 9;
  inline bool has_fighting_power() const;
  inline void clear_fighting_power();
  static const int kFightingPowerFieldNumber = 9;
  inline ::google::protobuf::uint32 fighting_power() const;
  inline void set_fighting_power(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.role_info)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_weapon_id();
  inline void clear_has_weapon_id();
  inline void set_has_armor_id();
  inline void clear_has_armor_id();
  inline void set_has_fighting_power();
  inline void clear_has_fighting_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 rank_;
  ::std::string* name_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 profession_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 weapon_id_;
  ::google::protobuf::uint32 armor_id_;
  ::google::protobuf::uint32 fighting_power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static role_info* default_instance_;
};
// -------------------------------------------------------------------

class arena_fight_ret : public ::google::protobuf::Message {
 public:
  arena_fight_ret();
  virtual ~arena_fight_ret();

  arena_fight_ret(const arena_fight_ret& from);

  inline arena_fight_ret& operator=(const arena_fight_ret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_fight_ret& default_instance();

  void Swap(arena_fight_ret* other);

  // implements Message ----------------------------------------------

  arena_fight_ret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_fight_ret& from);
  void MergeFrom(const arena_fight_ret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required uint32 target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);

  // required .client.FIGHT_RET_E ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline ::client::FIGHT_RET_E ret() const;
  inline void set_ret(::client::FIGHT_RET_E value);

  // optional string r_name = 4;
  inline bool has_r_name() const;
  inline void clear_r_name();
  static const int kRNameFieldNumber = 4;
  inline const ::std::string& r_name() const;
  inline void set_r_name(const ::std::string& value);
  inline void set_r_name(const char* value);
  inline void set_r_name(const char* value, size_t size);
  inline ::std::string* mutable_r_name();
  inline ::std::string* release_r_name();
  inline void set_allocated_r_name(::std::string* r_name);

  // optional string t_name = 5;
  inline bool has_t_name() const;
  inline void clear_t_name();
  static const int kTNameFieldNumber = 5;
  inline const ::std::string& t_name() const;
  inline void set_t_name(const ::std::string& value);
  inline void set_t_name(const char* value);
  inline void set_t_name(const char* value, size_t size);
  inline ::std::string* mutable_t_name();
  inline ::std::string* release_t_name();
  inline void set_allocated_t_name(::std::string* t_name);

  // @@protoc_insertion_point(class_scope:client.arena_fight_ret)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_r_name();
  inline void clear_has_r_name();
  inline void set_has_t_name();
  inline void clear_has_t_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 target_;
  ::std::string* r_name_;
  ::std::string* t_name_;
  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_fight_ret* default_instance_;
};
// -------------------------------------------------------------------

class arena_info_req : public ::google::protobuf::Message {
 public:
  arena_info_req();
  virtual ~arena_info_req();

  arena_info_req(const arena_info_req& from);

  inline arena_info_req& operator=(const arena_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_info_req& default_instance();

  void Swap(arena_info_req* other);

  // implements Message ----------------------------------------------

  arena_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_info_req& from);
  void MergeFrom(const arena_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_info_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_info_req* default_instance_;
};
// -------------------------------------------------------------------

class arena_info_rsp : public ::google::protobuf::Message {
 public:
  arena_info_rsp();
  virtual ~arena_info_rsp();

  arena_info_rsp(const arena_info_rsp& from);

  inline arena_info_rsp& operator=(const arena_info_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_info_rsp& default_instance();

  void Swap(arena_info_rsp* other);

  // implements Message ----------------------------------------------

  arena_info_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_info_rsp& from);
  void MergeFrom(const arena_info_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 history = 1;
  inline bool has_history() const;
  inline void clear_history();
  static const int kHistoryFieldNumber = 1;
  inline ::google::protobuf::uint32 history() const;
  inline void set_history(::google::protobuf::uint32 value);

  // required uint32 rank = 2;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // required uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // repeated .client.role_info ri = 4;
  inline int ri_size() const;
  inline void clear_ri();
  static const int kRiFieldNumber = 4;
  inline const ::client::role_info& ri(int index) const;
  inline ::client::role_info* mutable_ri(int index);
  inline ::client::role_info* add_ri();
  inline const ::google::protobuf::RepeatedPtrField< ::client::role_info >&
      ri() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::role_info >*
      mutable_ri();

  // @@protoc_insertion_point(class_scope:client.arena_info_rsp)
 private:
  inline void set_has_history();
  inline void clear_has_history();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 history_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::RepeatedPtrField< ::client::role_info > ri_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_info_rsp* default_instance_;
};
// -------------------------------------------------------------------

class arena_personal_info_req : public ::google::protobuf::Message {
 public:
  arena_personal_info_req();
  virtual ~arena_personal_info_req();

  arena_personal_info_req(const arena_personal_info_req& from);

  inline arena_personal_info_req& operator=(const arena_personal_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_personal_info_req& default_instance();

  void Swap(arena_personal_info_req* other);

  // implements Message ----------------------------------------------

  arena_personal_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_personal_info_req& from);
  void MergeFrom(const arena_personal_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_personal_info_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_personal_info_req* default_instance_;
};
// -------------------------------------------------------------------

class arena_personal_info_rsp : public ::google::protobuf::Message {
 public:
  arena_personal_info_rsp();
  virtual ~arena_personal_info_rsp();

  arena_personal_info_rsp(const arena_personal_info_rsp& from);

  inline arena_personal_info_rsp& operator=(const arena_personal_info_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_personal_info_rsp& default_instance();

  void Swap(arena_personal_info_rsp* other);

  // implements Message ----------------------------------------------

  arena_personal_info_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_personal_info_rsp& from);
  void MergeFrom(const arena_personal_info_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 used = 1;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 1;
  inline ::google::protobuf::uint32 used() const;
  inline void set_used(::google::protobuf::uint32 value);

  // required uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // required uint32 left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline ::google::protobuf::uint32 left() const;
  inline void set_left(::google::protobuf::uint32 value);

  // optional uint32 timelong = 4;
  inline bool has_timelong() const;
  inline void clear_timelong();
  static const int kTimelongFieldNumber = 4;
  inline ::google::protobuf::uint32 timelong() const;
  inline void set_timelong(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.arena_personal_info_rsp)
 private:
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_timelong();
  inline void clear_has_timelong();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 used_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 left_;
  ::google::protobuf::uint32 timelong_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_personal_info_rsp* default_instance_;
};
// -------------------------------------------------------------------

class arena_record_req : public ::google::protobuf::Message {
 public:
  arena_record_req();
  virtual ~arena_record_req();

  arena_record_req(const arena_record_req& from);

  inline arena_record_req& operator=(const arena_record_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_record_req& default_instance();

  void Swap(arena_record_req* other);

  // implements Message ----------------------------------------------

  arena_record_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_record_req& from);
  void MergeFrom(const arena_record_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_record_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_record_req* default_instance_;
};
// -------------------------------------------------------------------

class arena_record_info : public ::google::protobuf::Message {
 public:
  arena_record_info();
  virtual ~arena_record_info();

  arena_record_info(const arena_record_info& from);

  inline arena_record_info& operator=(const arena_record_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_record_info& default_instance();

  void Swap(arena_record_info* other);

  // implements Message ----------------------------------------------

  arena_record_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_record_info& from);
  void MergeFrom(const arena_record_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required uint32 action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // required int32 ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // required int32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:client.arena_record_info)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 action_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 rank_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_record_info* default_instance_;
};
// -------------------------------------------------------------------

class arena_record_rsp : public ::google::protobuf::Message {
 public:
  arena_record_rsp();
  virtual ~arena_record_rsp();

  arena_record_rsp(const arena_record_rsp& from);

  inline arena_record_rsp& operator=(const arena_record_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_record_rsp& default_instance();

  void Swap(arena_record_rsp* other);

  // implements Message ----------------------------------------------

  arena_record_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_record_rsp& from);
  void MergeFrom(const arena_record_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.arena_record_info ar = 1;
  inline int ar_size() const;
  inline void clear_ar();
  static const int kArFieldNumber = 1;
  inline const ::client::arena_record_info& ar(int index) const;
  inline ::client::arena_record_info* mutable_ar(int index);
  inline ::client::arena_record_info* add_ar();
  inline const ::google::protobuf::RepeatedPtrField< ::client::arena_record_info >&
      ar() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::arena_record_info >*
      mutable_ar();

  // @@protoc_insertion_point(class_scope:client.arena_record_rsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::arena_record_info > ar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_record_rsp* default_instance_;
};
// -------------------------------------------------------------------

class arena_refresh_req : public ::google::protobuf::Message {
 public:
  arena_refresh_req();
  virtual ~arena_refresh_req();

  arena_refresh_req(const arena_refresh_req& from);

  inline arena_refresh_req& operator=(const arena_refresh_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_refresh_req& default_instance();

  void Swap(arena_refresh_req* other);

  // implements Message ----------------------------------------------

  arena_refresh_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_refresh_req& from);
  void MergeFrom(const arena_refresh_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_refresh_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_refresh_req* default_instance_;
};
// -------------------------------------------------------------------

class arena_refresh_rsp : public ::google::protobuf::Message {
 public:
  arena_refresh_rsp();
  virtual ~arena_refresh_rsp();

  arena_refresh_rsp(const arena_refresh_rsp& from);

  inline arena_refresh_rsp& operator=(const arena_refresh_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_refresh_rsp& default_instance();

  void Swap(arena_refresh_rsp* other);

  // implements Message ----------------------------------------------

  arena_refresh_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_refresh_rsp& from);
  void MergeFrom(const arena_refresh_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 times = 1;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 1;
  inline ::google::protobuf::uint32 times() const;
  inline void set_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.arena_refresh_rsp)
 private:
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_refresh_rsp* default_instance_;
};
// -------------------------------------------------------------------

class arena_speed_up_req : public ::google::protobuf::Message {
 public:
  arena_speed_up_req();
  virtual ~arena_speed_up_req();

  arena_speed_up_req(const arena_speed_up_req& from);

  inline arena_speed_up_req& operator=(const arena_speed_up_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_speed_up_req& default_instance();

  void Swap(arena_speed_up_req* other);

  // implements Message ----------------------------------------------

  arena_speed_up_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_speed_up_req& from);
  void MergeFrom(const arena_speed_up_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_speed_up_req)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_speed_up_req* default_instance_;
};
// -------------------------------------------------------------------

class arena_speed_up_rsp : public ::google::protobuf::Message {
 public:
  arena_speed_up_rsp();
  virtual ~arena_speed_up_rsp();

  arena_speed_up_rsp(const arena_speed_up_rsp& from);

  inline arena_speed_up_rsp& operator=(const arena_speed_up_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_speed_up_rsp& default_instance();

  void Swap(arena_speed_up_rsp* other);

  // implements Message ----------------------------------------------

  arena_speed_up_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_speed_up_rsp& from);
  void MergeFrom(const arena_speed_up_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.arena_speed_up_rsp)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_speed_up_rsp* default_instance_;
};
// -------------------------------------------------------------------

class arena_challenge_req : public ::google::protobuf::Message {
 public:
  arena_challenge_req();
  virtual ~arena_challenge_req();

  arena_challenge_req(const arena_challenge_req& from);

  inline arena_challenge_req& operator=(const arena_challenge_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_challenge_req& default_instance();

  void Swap(arena_challenge_req* other);

  // implements Message ----------------------------------------------

  arena_challenge_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_challenge_req& from);
  void MergeFrom(const arena_challenge_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_challenge_req)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 target_;
  ::google::protobuf::uint32 type_;
  ::client::server_head* svr_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_challenge_req* default_instance_;
};
// -------------------------------------------------------------------

class arena_challenge_result : public ::google::protobuf::Message {
 public:
  arena_challenge_result();
  virtual ~arena_challenge_result();

  arena_challenge_result(const arena_challenge_result& from);

  inline arena_challenge_result& operator=(const arena_challenge_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_challenge_result& default_instance();

  void Swap(arena_challenge_result* other);

  // implements Message ----------------------------------------------

  arena_challenge_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_challenge_result& from);
  void MergeFrom(const arena_challenge_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // required .client.FIGHT_RET_E ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::client::FIGHT_RET_E ret() const;
  inline void set_ret(::client::FIGHT_RET_E value);

  // optional uint32 history = 3;
  inline bool has_history() const;
  inline void clear_history();
  static const int kHistoryFieldNumber = 3;
  inline ::google::protobuf::uint32 history() const;
  inline void set_history(::google::protobuf::uint32 value);

  // optional uint32 current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline ::google::protobuf::uint32 current() const;
  inline void set_current(::google::protobuf::uint32 value);

  // optional uint32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.arena_challenge_result)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_history();
  inline void clear_has_history();
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 num_;
  int ret_;
  ::google::protobuf::uint32 history_;
  ::google::protobuf::uint32 current_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_challenge_result* default_instance_;
};
// -------------------------------------------------------------------

class robot_attr : public ::google::protobuf::Message {
 public:
  robot_attr();
  virtual ~robot_attr();

  robot_attr(const robot_attr& from);

  inline robot_attr& operator=(const robot_attr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const robot_attr& default_instance();

  void Swap(robot_attr* other);

  // implements Message ----------------------------------------------

  robot_attr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const robot_attr& from);
  void MergeFrom(const robot_attr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 profession = 5;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 5;
  inline ::google::protobuf::uint32 profession() const;
  inline void set_profession(::google::protobuf::uint32 value);

  // optional uint32 fighting_power = 6;
  inline bool has_fighting_power() const;
  inline void clear_fighting_power();
  static const int kFightingPowerFieldNumber = 6;
  inline ::google::protobuf::uint32 fighting_power() const;
  inline void set_fighting_power(::google::protobuf::uint32 value);

  // optional uint32 hp_max = 7;
  inline bool has_hp_max() const;
  inline void clear_hp_max();
  static const int kHpMaxFieldNumber = 7;
  inline ::google::protobuf::uint32 hp_max() const;
  inline void set_hp_max(::google::protobuf::uint32 value);

  // optional uint32 attack_min = 8;
  inline bool has_attack_min() const;
  inline void clear_attack_min();
  static const int kAttackMinFieldNumber = 8;
  inline ::google::protobuf::uint32 attack_min() const;
  inline void set_attack_min(::google::protobuf::uint32 value);

  // optional uint32 attack_max = 9;
  inline bool has_attack_max() const;
  inline void clear_attack_max();
  static const int kAttackMaxFieldNumber = 9;
  inline ::google::protobuf::uint32 attack_max() const;
  inline void set_attack_max(::google::protobuf::uint32 value);

  // optional uint32 defense_min = 10;
  inline bool has_defense_min() const;
  inline void clear_defense_min();
  static const int kDefenseMinFieldNumber = 10;
  inline ::google::protobuf::uint32 defense_min() const;
  inline void set_defense_min(::google::protobuf::uint32 value);

  // optional uint32 defense_max = 11;
  inline bool has_defense_max() const;
  inline void clear_defense_max();
  static const int kDefenseMaxFieldNumber = 11;
  inline ::google::protobuf::uint32 defense_max() const;
  inline void set_defense_max(::google::protobuf::uint32 value);

  // optional uint32 hit = 12;
  inline bool has_hit() const;
  inline void clear_hit();
  static const int kHitFieldNumber = 12;
  inline ::google::protobuf::uint32 hit() const;
  inline void set_hit(::google::protobuf::uint32 value);

  // optional uint32 dodge = 13;
  inline bool has_dodge() const;
  inline void clear_dodge();
  static const int kDodgeFieldNumber = 13;
  inline ::google::protobuf::uint32 dodge() const;
  inline void set_dodge(::google::protobuf::uint32 value);

  // optional uint32 recover = 14;
  inline bool has_recover() const;
  inline void clear_recover();
  static const int kRecoverFieldNumber = 14;
  inline ::google::protobuf::uint32 recover() const;
  inline void set_recover(::google::protobuf::uint32 value);

  // optional uint32 move_speed = 15;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 15;
  inline ::google::protobuf::uint32 move_speed() const;
  inline void set_move_speed(::google::protobuf::uint32 value);

  // optional uint32 stable = 16;
  inline bool has_stable() const;
  inline void clear_stable();
  static const int kStableFieldNumber = 16;
  inline ::google::protobuf::uint32 stable() const;
  inline void set_stable(::google::protobuf::uint32 value);

  // optional uint32 mount_id = 17;
  inline bool has_mount_id() const;
  inline void clear_mount_id();
  static const int kMountIdFieldNumber = 17;
  inline ::google::protobuf::uint32 mount_id() const;
  inline void set_mount_id(::google::protobuf::uint32 value);

  // optional uint32 weapon_id = 18;
  inline bool has_weapon_id() const;
  inline void clear_weapon_id();
  static const int kWeaponIdFieldNumber = 18;
  inline ::google::protobuf::uint32 weapon_id() const;
  inline void set_weapon_id(::google::protobuf::uint32 value);

  // optional uint32 armor_id = 19;
  inline bool has_armor_id() const;
  inline void clear_armor_id();
  static const int kArmorIdFieldNumber = 19;
  inline ::google::protobuf::uint32 armor_id() const;
  inline void set_armor_id(::google::protobuf::uint32 value);

  // optional .client.pet_db_info pet = 20;
  inline bool has_pet() const;
  inline void clear_pet();
  static const int kPetFieldNumber = 20;
  inline const ::client::pet_db_info& pet() const;
  inline ::client::pet_db_info* mutable_pet();
  inline ::client::pet_db_info* release_pet();
  inline void set_allocated_pet(::client::pet_db_info* pet);

  // optional uint32 config_id = 21;
  inline bool has_config_id() const;
  inline void clear_config_id();
  static const int kConfigIdFieldNumber = 21;
  inline ::google::protobuf::uint32 config_id() const;
  inline void set_config_id(::google::protobuf::uint32 value);

  // optional .client.skills sk = 22;
  inline bool has_sk() const;
  inline void clear_sk();
  static const int kSkFieldNumber = 22;
  inline const ::client::skills& sk() const;
  inline ::client::skills* mutable_sk();
  inline ::client::skills* release_sk();
  inline void set_allocated_sk(::client::skills* sk);

  // optional .client.pet_db_info backup = 23;
  inline bool has_backup() const;
  inline void clear_backup();
  static const int kBackupFieldNumber = 23;
  inline const ::client::pet_db_info& backup() const;
  inline ::client::pet_db_info* mutable_backup();
  inline ::client::pet_db_info* release_backup();
  inline void set_allocated_backup(::client::pet_db_info* backup);

  // optional uint32 x = 24;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 24;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 25;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 25;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // optional uint32 family_id = 26;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 26;
  inline ::google::protobuf::uint32 family_id() const;
  inline void set_family_id(::google::protobuf::uint32 value);

  // optional uint32 vip_level = 27;
  inline bool has_vip_level() const;
  inline void clear_vip_level();
  static const int kVipLevelFieldNumber = 27;
  inline ::google::protobuf::uint32 vip_level() const;
  inline void set_vip_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.robot_attr)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_fighting_power();
  inline void clear_has_fighting_power();
  inline void set_has_hp_max();
  inline void clear_has_hp_max();
  inline void set_has_attack_min();
  inline void clear_has_attack_min();
  inline void set_has_attack_max();
  inline void clear_has_attack_max();
  inline void set_has_defense_min();
  inline void clear_has_defense_min();
  inline void set_has_defense_max();
  inline void clear_has_defense_max();
  inline void set_has_hit();
  inline void clear_has_hit();
  inline void set_has_dodge();
  inline void clear_has_dodge();
  inline void set_has_recover();
  inline void clear_has_recover();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();
  inline void set_has_stable();
  inline void clear_has_stable();
  inline void set_has_mount_id();
  inline void clear_has_mount_id();
  inline void set_has_weapon_id();
  inline void clear_has_weapon_id();
  inline void set_has_armor_id();
  inline void clear_has_armor_id();
  inline void set_has_pet();
  inline void clear_has_pet();
  inline void set_has_config_id();
  inline void clear_has_config_id();
  inline void set_has_sk();
  inline void clear_has_sk();
  inline void set_has_backup();
  inline void clear_has_backup();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_vip_level();
  inline void clear_has_vip_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 profession_;
  ::google::protobuf::uint32 fighting_power_;
  ::google::protobuf::uint32 hp_max_;
  ::google::protobuf::uint32 attack_min_;
  ::google::protobuf::uint32 attack_max_;
  ::google::protobuf::uint32 defense_min_;
  ::google::protobuf::uint32 defense_max_;
  ::google::protobuf::uint32 hit_;
  ::google::protobuf::uint32 dodge_;
  ::google::protobuf::uint32 recover_;
  ::google::protobuf::uint32 move_speed_;
  ::google::protobuf::uint32 stable_;
  ::google::protobuf::uint32 mount_id_;
  ::google::protobuf::uint32 weapon_id_;
  ::google::protobuf::uint32 armor_id_;
  ::client::pet_db_info* pet_;
  ::client::skills* sk_;
  ::google::protobuf::uint32 config_id_;
  ::google::protobuf::uint32 x_;
  ::client::pet_db_info* backup_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 family_id_;
  ::google::protobuf::uint32 vip_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static robot_attr* default_instance_;
};
// -------------------------------------------------------------------

class load_target_data_req : public ::google::protobuf::Message {
 public:
  load_target_data_req();
  virtual ~load_target_data_req();

  load_target_data_req(const load_target_data_req& from);

  inline load_target_data_req& operator=(const load_target_data_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const load_target_data_req& default_instance();

  void Swap(load_target_data_req* other);

  // implements Message ----------------------------------------------

  load_target_data_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const load_target_data_req& from);
  void MergeFrom(const load_target_data_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);

  // required uint32 scene_id = 2;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 2;
  inline ::google::protobuf::uint32 scene_id() const;
  inline void set_scene_id(::google::protobuf::uint32 value);

  // required uint32 role_id = 3;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 3;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.load_target_data_req)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_role_id();
  inline void clear_has_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 target_;
  ::google::protobuf::uint32 scene_id_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static load_target_data_req* default_instance_;
};
// -------------------------------------------------------------------

class load_target_data_rsp : public ::google::protobuf::Message {
 public:
  load_target_data_rsp();
  virtual ~load_target_data_rsp();

  load_target_data_rsp(const load_target_data_rsp& from);

  inline load_target_data_rsp& operator=(const load_target_data_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const load_target_data_rsp& default_instance();

  void Swap(load_target_data_rsp* other);

  // implements Message ----------------------------------------------

  load_target_data_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const load_target_data_rsp& from);
  void MergeFrom(const load_target_data_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required .client.robot_attr attr = 2;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 2;
  inline const ::client::robot_attr& attr() const;
  inline ::client::robot_attr* mutable_attr();
  inline ::client::robot_attr* release_attr();
  inline void set_allocated_attr(::client::robot_attr* attr);

  // @@protoc_insertion_point(class_scope:client.load_target_data_rsp)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_attr();
  inline void clear_has_attr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::robot_attr* attr_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static load_target_data_rsp* default_instance_;
};
// -------------------------------------------------------------------

class load_online_target_data_req : public ::google::protobuf::Message {
 public:
  load_online_target_data_req();
  virtual ~load_online_target_data_req();

  load_online_target_data_req(const load_online_target_data_req& from);

  inline load_online_target_data_req& operator=(const load_online_target_data_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const load_online_target_data_req& default_instance();

  void Swap(load_online_target_data_req* other);

  // implements Message ----------------------------------------------

  load_online_target_data_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const load_online_target_data_req& from);
  void MergeFrom(const load_online_target_data_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);

  // required uint32 role_id = 2;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 2;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required uint32 svr_scene_id = 3;
  inline bool has_svr_scene_id() const;
  inline void clear_svr_scene_id();
  static const int kSvrSceneIdFieldNumber = 3;
  inline ::google::protobuf::uint32 svr_scene_id() const;
  inline void set_svr_scene_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.load_online_target_data_req)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_scene_id();
  inline void clear_has_svr_scene_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 target_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 svr_scene_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static load_online_target_data_req* default_instance_;
};
// -------------------------------------------------------------------

class arena_reward_req : public ::google::protobuf::Message {
 public:
  arena_reward_req();
  virtual ~arena_reward_req();

  arena_reward_req(const arena_reward_req& from);

  inline arena_reward_req& operator=(const arena_reward_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_reward_req& default_instance();

  void Swap(arena_reward_req* other);

  // implements Message ----------------------------------------------

  arena_reward_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_reward_req& from);
  void MergeFrom(const arena_reward_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_reward_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_reward_req* default_instance_;
};
// -------------------------------------------------------------------

class reward_info : public ::google::protobuf::Message {
 public:
  reward_info();
  virtual ~reward_info();

  reward_info(const reward_info& from);

  inline reward_info& operator=(const reward_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reward_info& default_instance();

  void Swap(reward_info* other);

  // implements Message ----------------------------------------------

  reward_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reward_info& from);
  void MergeFrom(const reward_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.reward_info)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static reward_info* default_instance_;
};
// -------------------------------------------------------------------

class arena_reward_item : public ::google::protobuf::Message {
 public:
  arena_reward_item();
  virtual ~arena_reward_item();

  arena_reward_item(const arena_reward_item& from);

  inline arena_reward_item& operator=(const arena_reward_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_reward_item& default_instance();

  void Swap(arena_reward_item* other);

  // implements Message ----------------------------------------------

  arena_reward_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_reward_item& from);
  void MergeFrom(const arena_reward_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 min_rank = 1;
  inline bool has_min_rank() const;
  inline void clear_min_rank();
  static const int kMinRankFieldNumber = 1;
  inline ::google::protobuf::uint32 min_rank() const;
  inline void set_min_rank(::google::protobuf::uint32 value);

  // required uint32 max_rank = 2;
  inline bool has_max_rank() const;
  inline void clear_max_rank();
  static const int kMaxRankFieldNumber = 2;
  inline ::google::protobuf::uint32 max_rank() const;
  inline void set_max_rank(::google::protobuf::uint32 value);

  // repeated .client.reward_info ri = 3;
  inline int ri_size() const;
  inline void clear_ri();
  static const int kRiFieldNumber = 3;
  inline const ::client::reward_info& ri(int index) const;
  inline ::client::reward_info* mutable_ri(int index);
  inline ::client::reward_info* add_ri();
  inline const ::google::protobuf::RepeatedPtrField< ::client::reward_info >&
      ri() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::reward_info >*
      mutable_ri();

  // @@protoc_insertion_point(class_scope:client.arena_reward_item)
 private:
  inline void set_has_min_rank();
  inline void clear_has_min_rank();
  inline void set_has_max_rank();
  inline void clear_has_max_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 min_rank_;
  ::google::protobuf::uint32 max_rank_;
  ::google::protobuf::RepeatedPtrField< ::client::reward_info > ri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_reward_item* default_instance_;
};
// -------------------------------------------------------------------

class arena_reward_rsp : public ::google::protobuf::Message {
 public:
  arena_reward_rsp();
  virtual ~arena_reward_rsp();

  arena_reward_rsp(const arena_reward_rsp& from);

  inline arena_reward_rsp& operator=(const arena_reward_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_reward_rsp& default_instance();

  void Swap(arena_reward_rsp* other);

  // implements Message ----------------------------------------------

  arena_reward_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_reward_rsp& from);
  void MergeFrom(const arena_reward_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .client.arena_reward_item ari = 1;
  inline int ari_size() const;
  inline void clear_ari();
  static const int kAriFieldNumber = 1;
  inline const ::client::arena_reward_item& ari(int index) const;
  inline ::client::arena_reward_item* mutable_ari(int index);
  inline ::client::arena_reward_item* add_ari();
  inline const ::google::protobuf::RepeatedPtrField< ::client::arena_reward_item >&
      ari() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::arena_reward_item >*
      mutable_ari();

  // @@protoc_insertion_point(class_scope:client.arena_reward_rsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::arena_reward_item > ari_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_reward_rsp* default_instance_;
};
// -------------------------------------------------------------------

class arena_rank_list_req : public ::google::protobuf::Message {
 public:
  arena_rank_list_req();
  virtual ~arena_rank_list_req();

  arena_rank_list_req(const arena_rank_list_req& from);

  inline arena_rank_list_req& operator=(const arena_rank_list_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_rank_list_req& default_instance();

  void Swap(arena_rank_list_req* other);

  // implements Message ----------------------------------------------

  arena_rank_list_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_rank_list_req& from);
  void MergeFrom(const arena_rank_list_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_rank_list_req)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_rank_list_req* default_instance_;
};
// -------------------------------------------------------------------

class rank_list_item : public ::google::protobuf::Message {
 public:
  rank_list_item();
  virtual ~rank_list_item();

  rank_list_item(const rank_list_item& from);

  inline rank_list_item& operator=(const rank_list_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_list_item& default_instance();

  void Swap(rank_list_item* other);

  // implements Message ----------------------------------------------

  rank_list_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_list_item& from);
  void MergeFrom(const rank_list_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 power = 3;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 3;
  inline ::google::protobuf::uint32 power() const;
  inline void set_power(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:client.rank_list_item)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static rank_list_item* default_instance_;
};
// -------------------------------------------------------------------

class arena_rank_list_rsp : public ::google::protobuf::Message {
 public:
  arena_rank_list_rsp();
  virtual ~arena_rank_list_rsp();

  arena_rank_list_rsp(const arena_rank_list_rsp& from);

  inline arena_rank_list_rsp& operator=(const arena_rank_list_rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_rank_list_rsp& default_instance();

  void Swap(arena_rank_list_rsp* other);

  // implements Message ----------------------------------------------

  arena_rank_list_rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_rank_list_rsp& from);
  void MergeFrom(const arena_rank_list_rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // repeated .client.rank_list_item rli = 2;
  inline int rli_size() const;
  inline void clear_rli();
  static const int kRliFieldNumber = 2;
  inline const ::client::rank_list_item& rli(int index) const;
  inline ::client::rank_list_item* mutable_rli(int index);
  inline ::client::rank_list_item* add_rli();
  inline const ::google::protobuf::RepeatedPtrField< ::client::rank_list_item >&
      rli() const;
  inline ::google::protobuf::RepeatedPtrField< ::client::rank_list_item >*
      mutable_rli();

  // @@protoc_insertion_point(class_scope:client.arena_rank_list_rsp)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::client::rank_list_item > rli_;
  ::google::protobuf::int32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_rank_list_rsp* default_instance_;
};
// -------------------------------------------------------------------

class arena_fight_begin : public ::google::protobuf::Message {
 public:
  arena_fight_begin();
  virtual ~arena_fight_begin();

  arena_fight_begin(const arena_fight_begin& from);

  inline arena_fight_begin& operator=(const arena_fight_begin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_fight_begin& default_instance();

  void Swap(arena_fight_begin* other);

  // implements Message ----------------------------------------------

  arena_fight_begin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_fight_begin& from);
  void MergeFrom(const arena_fight_begin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .client.server_head svr_head = 1000;
  inline bool has_svr_head() const;
  inline void clear_svr_head();
  static const int kSvrHeadFieldNumber = 1000;
  inline const ::client::server_head& svr_head() const;
  inline ::client::server_head* mutable_svr_head();
  inline ::client::server_head* release_svr_head();
  inline void set_allocated_svr_head(::client::server_head* svr_head);

  // @@protoc_insertion_point(class_scope:client.arena_fight_begin)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_svr_head();
  inline void clear_has_svr_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::server_head* svr_head_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2earena_2eproto();
  friend void protobuf_AssignDesc_client_2earena_2eproto();
  friend void protobuf_ShutdownFile_client_2earena_2eproto();

  void InitAsDefaultInstance();
  static arena_fight_begin* default_instance_;
};
// ===================================================================


// ===================================================================

// role_info

// required uint32 role_id = 1;
inline bool role_info::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_info::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_info::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_info::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 role_info::role_id() const {
  return role_id_;
}
inline void role_info::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required uint32 rank = 2;
inline bool role_info::has_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_info::set_has_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_info::clear_has_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_info::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 role_info::rank() const {
  return rank_;
}
inline void role_info::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}

// required uint32 type = 3;
inline bool role_info::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_info::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_info::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 role_info::type() const {
  return type_;
}
inline void role_info::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string name = 4;
inline bool role_info::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_info::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& role_info::name() const {
  return *name_;
}
inline void role_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void role_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void role_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* role_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 profession = 5;
inline bool role_info::has_profession() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_info::set_has_profession() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_info::clear_has_profession() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_info::clear_profession() {
  profession_ = 0u;
  clear_has_profession();
}
inline ::google::protobuf::uint32 role_info::profession() const {
  return profession_;
}
inline void role_info::set_profession(::google::protobuf::uint32 value) {
  set_has_profession();
  profession_ = value;
}

// optional uint32 sex = 6;
inline bool role_info::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_info::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_info::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_info::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 role_info::sex() const {
  return sex_;
}
inline void role_info::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 weapon_id = 7;
inline bool role_info::has_weapon_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_info::set_has_weapon_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_info::clear_has_weapon_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_info::clear_weapon_id() {
  weapon_id_ = 0u;
  clear_has_weapon_id();
}
inline ::google::protobuf::uint32 role_info::weapon_id() const {
  return weapon_id_;
}
inline void role_info::set_weapon_id(::google::protobuf::uint32 value) {
  set_has_weapon_id();
  weapon_id_ = value;
}

// optional uint32 armor_id = 8;
inline bool role_info::has_armor_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void role_info::set_has_armor_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void role_info::clear_has_armor_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void role_info::clear_armor_id() {
  armor_id_ = 0u;
  clear_has_armor_id();
}
inline ::google::protobuf::uint32 role_info::armor_id() const {
  return armor_id_;
}
inline void role_info::set_armor_id(::google::protobuf::uint32 value) {
  set_has_armor_id();
  armor_id_ = value;
}

// optional uint32 fighting_power = 9;
inline bool role_info::has_fighting_power() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void role_info::set_has_fighting_power() {
  _has_bits_[0] |= 0x00000100u;
}
inline void role_info::clear_has_fighting_power() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void role_info::clear_fighting_power() {
  fighting_power_ = 0u;
  clear_has_fighting_power();
}
inline ::google::protobuf::uint32 role_info::fighting_power() const {
  return fighting_power_;
}
inline void role_info::set_fighting_power(::google::protobuf::uint32 value) {
  set_has_fighting_power();
  fighting_power_ = value;
}

// -------------------------------------------------------------------

// arena_fight_ret

// required uint32 role_id = 1;
inline bool arena_fight_ret::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_fight_ret::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_fight_ret::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_fight_ret::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 arena_fight_ret::role_id() const {
  return role_id_;
}
inline void arena_fight_ret::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required uint32 target = 2;
inline bool arena_fight_ret::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_fight_ret::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_fight_ret::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_fight_ret::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 arena_fight_ret::target() const {
  return target_;
}
inline void arena_fight_ret::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
}

// required .client.FIGHT_RET_E ret = 3;
inline bool arena_fight_ret::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_fight_ret::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_fight_ret::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_fight_ret::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::FIGHT_RET_E arena_fight_ret::ret() const {
  return static_cast< ::client::FIGHT_RET_E >(ret_);
}
inline void arena_fight_ret::set_ret(::client::FIGHT_RET_E value) {
  assert(::client::FIGHT_RET_E_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// optional string r_name = 4;
inline bool arena_fight_ret::has_r_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void arena_fight_ret::set_has_r_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void arena_fight_ret::clear_has_r_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void arena_fight_ret::clear_r_name() {
  if (r_name_ != &::google::protobuf::internal::kEmptyString) {
    r_name_->clear();
  }
  clear_has_r_name();
}
inline const ::std::string& arena_fight_ret::r_name() const {
  return *r_name_;
}
inline void arena_fight_ret::set_r_name(const ::std::string& value) {
  set_has_r_name();
  if (r_name_ == &::google::protobuf::internal::kEmptyString) {
    r_name_ = new ::std::string;
  }
  r_name_->assign(value);
}
inline void arena_fight_ret::set_r_name(const char* value) {
  set_has_r_name();
  if (r_name_ == &::google::protobuf::internal::kEmptyString) {
    r_name_ = new ::std::string;
  }
  r_name_->assign(value);
}
inline void arena_fight_ret::set_r_name(const char* value, size_t size) {
  set_has_r_name();
  if (r_name_ == &::google::protobuf::internal::kEmptyString) {
    r_name_ = new ::std::string;
  }
  r_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* arena_fight_ret::mutable_r_name() {
  set_has_r_name();
  if (r_name_ == &::google::protobuf::internal::kEmptyString) {
    r_name_ = new ::std::string;
  }
  return r_name_;
}
inline ::std::string* arena_fight_ret::release_r_name() {
  clear_has_r_name();
  if (r_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = r_name_;
    r_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void arena_fight_ret::set_allocated_r_name(::std::string* r_name) {
  if (r_name_ != &::google::protobuf::internal::kEmptyString) {
    delete r_name_;
  }
  if (r_name) {
    set_has_r_name();
    r_name_ = r_name;
  } else {
    clear_has_r_name();
    r_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string t_name = 5;
inline bool arena_fight_ret::has_t_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void arena_fight_ret::set_has_t_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void arena_fight_ret::clear_has_t_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void arena_fight_ret::clear_t_name() {
  if (t_name_ != &::google::protobuf::internal::kEmptyString) {
    t_name_->clear();
  }
  clear_has_t_name();
}
inline const ::std::string& arena_fight_ret::t_name() const {
  return *t_name_;
}
inline void arena_fight_ret::set_t_name(const ::std::string& value) {
  set_has_t_name();
  if (t_name_ == &::google::protobuf::internal::kEmptyString) {
    t_name_ = new ::std::string;
  }
  t_name_->assign(value);
}
inline void arena_fight_ret::set_t_name(const char* value) {
  set_has_t_name();
  if (t_name_ == &::google::protobuf::internal::kEmptyString) {
    t_name_ = new ::std::string;
  }
  t_name_->assign(value);
}
inline void arena_fight_ret::set_t_name(const char* value, size_t size) {
  set_has_t_name();
  if (t_name_ == &::google::protobuf::internal::kEmptyString) {
    t_name_ = new ::std::string;
  }
  t_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* arena_fight_ret::mutable_t_name() {
  set_has_t_name();
  if (t_name_ == &::google::protobuf::internal::kEmptyString) {
    t_name_ = new ::std::string;
  }
  return t_name_;
}
inline ::std::string* arena_fight_ret::release_t_name() {
  clear_has_t_name();
  if (t_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = t_name_;
    t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void arena_fight_ret::set_allocated_t_name(::std::string* t_name) {
  if (t_name_ != &::google::protobuf::internal::kEmptyString) {
    delete t_name_;
  }
  if (t_name) {
    set_has_t_name();
    t_name_ = t_name;
  } else {
    clear_has_t_name();
    t_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// arena_info_req

// required uint32 time = 1;
inline bool arena_info_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_info_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_info_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_info_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_info_req::time() const {
  return time_;
}
inline void arena_info_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_info_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_info_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_info_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_info_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_info_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_info_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_info_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_info_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// arena_info_rsp

// required uint32 history = 1;
inline bool arena_info_rsp::has_history() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_info_rsp::set_has_history() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_info_rsp::clear_has_history() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_info_rsp::clear_history() {
  history_ = 0u;
  clear_has_history();
}
inline ::google::protobuf::uint32 arena_info_rsp::history() const {
  return history_;
}
inline void arena_info_rsp::set_history(::google::protobuf::uint32 value) {
  set_has_history();
  history_ = value;
}

// required uint32 rank = 2;
inline bool arena_info_rsp::has_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_info_rsp::set_has_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_info_rsp::clear_has_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_info_rsp::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 arena_info_rsp::rank() const {
  return rank_;
}
inline void arena_info_rsp::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}

// required uint32 status = 3;
inline bool arena_info_rsp::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_info_rsp::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_info_rsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_info_rsp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 arena_info_rsp::status() const {
  return status_;
}
inline void arena_info_rsp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// repeated .client.role_info ri = 4;
inline int arena_info_rsp::ri_size() const {
  return ri_.size();
}
inline void arena_info_rsp::clear_ri() {
  ri_.Clear();
}
inline const ::client::role_info& arena_info_rsp::ri(int index) const {
  return ri_.Get(index);
}
inline ::client::role_info* arena_info_rsp::mutable_ri(int index) {
  return ri_.Mutable(index);
}
inline ::client::role_info* arena_info_rsp::add_ri() {
  return ri_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::role_info >&
arena_info_rsp::ri() const {
  return ri_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::role_info >*
arena_info_rsp::mutable_ri() {
  return &ri_;
}

// -------------------------------------------------------------------

// arena_personal_info_req

// required uint32 role_id = 1;
inline bool arena_personal_info_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_personal_info_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_personal_info_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_personal_info_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 arena_personal_info_req::role_id() const {
  return role_id_;
}
inline void arena_personal_info_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_personal_info_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_personal_info_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_personal_info_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_personal_info_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_personal_info_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_personal_info_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_personal_info_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_personal_info_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// arena_personal_info_rsp

// required uint32 used = 1;
inline bool arena_personal_info_rsp::has_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_personal_info_rsp::set_has_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_personal_info_rsp::clear_has_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_personal_info_rsp::clear_used() {
  used_ = 0u;
  clear_has_used();
}
inline ::google::protobuf::uint32 arena_personal_info_rsp::used() const {
  return used_;
}
inline void arena_personal_info_rsp::set_used(::google::protobuf::uint32 value) {
  set_has_used();
  used_ = value;
}

// required uint32 total = 2;
inline bool arena_personal_info_rsp::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_personal_info_rsp::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_personal_info_rsp::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_personal_info_rsp::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 arena_personal_info_rsp::total() const {
  return total_;
}
inline void arena_personal_info_rsp::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// required uint32 left = 3;
inline bool arena_personal_info_rsp::has_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_personal_info_rsp::set_has_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_personal_info_rsp::clear_has_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_personal_info_rsp::clear_left() {
  left_ = 0u;
  clear_has_left();
}
inline ::google::protobuf::uint32 arena_personal_info_rsp::left() const {
  return left_;
}
inline void arena_personal_info_rsp::set_left(::google::protobuf::uint32 value) {
  set_has_left();
  left_ = value;
}

// optional uint32 timelong = 4;
inline bool arena_personal_info_rsp::has_timelong() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void arena_personal_info_rsp::set_has_timelong() {
  _has_bits_[0] |= 0x00000008u;
}
inline void arena_personal_info_rsp::clear_has_timelong() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void arena_personal_info_rsp::clear_timelong() {
  timelong_ = 0u;
  clear_has_timelong();
}
inline ::google::protobuf::uint32 arena_personal_info_rsp::timelong() const {
  return timelong_;
}
inline void arena_personal_info_rsp::set_timelong(::google::protobuf::uint32 value) {
  set_has_timelong();
  timelong_ = value;
}

// -------------------------------------------------------------------

// arena_record_req

// required uint32 time = 1;
inline bool arena_record_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_record_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_record_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_record_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_record_req::time() const {
  return time_;
}
inline void arena_record_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_record_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_record_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_record_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_record_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_record_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_record_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_record_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_record_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// arena_record_info

// required uint32 time = 1;
inline bool arena_record_info::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_record_info::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_record_info::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_record_info::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_record_info::time() const {
  return time_;
}
inline void arena_record_info::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 action = 2;
inline bool arena_record_info::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_record_info::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_record_info::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_record_info::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 arena_record_info::action() const {
  return action_;
}
inline void arena_record_info::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// required int32 ret = 3;
inline bool arena_record_info::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_record_info::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_record_info::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_record_info::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 arena_record_info::ret() const {
  return ret_;
}
inline void arena_record_info::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// required int32 rank = 4;
inline bool arena_record_info::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void arena_record_info::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void arena_record_info::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void arena_record_info::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 arena_record_info::rank() const {
  return rank_;
}
inline void arena_record_info::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required string name = 5;
inline bool arena_record_info::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void arena_record_info::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void arena_record_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void arena_record_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& arena_record_info::name() const {
  return *name_;
}
inline void arena_record_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void arena_record_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void arena_record_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* arena_record_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* arena_record_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void arena_record_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// arena_record_rsp

// repeated .client.arena_record_info ar = 1;
inline int arena_record_rsp::ar_size() const {
  return ar_.size();
}
inline void arena_record_rsp::clear_ar() {
  ar_.Clear();
}
inline const ::client::arena_record_info& arena_record_rsp::ar(int index) const {
  return ar_.Get(index);
}
inline ::client::arena_record_info* arena_record_rsp::mutable_ar(int index) {
  return ar_.Mutable(index);
}
inline ::client::arena_record_info* arena_record_rsp::add_ar() {
  return ar_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::arena_record_info >&
arena_record_rsp::ar() const {
  return ar_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::arena_record_info >*
arena_record_rsp::mutable_ar() {
  return &ar_;
}

// -------------------------------------------------------------------

// arena_refresh_req

// required uint32 time = 1;
inline bool arena_refresh_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_refresh_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_refresh_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_refresh_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_refresh_req::time() const {
  return time_;
}
inline void arena_refresh_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_refresh_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_refresh_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_refresh_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_refresh_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_refresh_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_refresh_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_refresh_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_refresh_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// arena_refresh_rsp

// required uint32 times = 1;
inline bool arena_refresh_rsp::has_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_refresh_rsp::set_has_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_refresh_rsp::clear_has_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_refresh_rsp::clear_times() {
  times_ = 0u;
  clear_has_times();
}
inline ::google::protobuf::uint32 arena_refresh_rsp::times() const {
  return times_;
}
inline void arena_refresh_rsp::set_times(::google::protobuf::uint32 value) {
  set_has_times();
  times_ = value;
}

// -------------------------------------------------------------------

// arena_speed_up_req

// required uint32 time = 1;
inline bool arena_speed_up_req::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_speed_up_req::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_speed_up_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_speed_up_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_speed_up_req::time() const {
  return time_;
}
inline void arena_speed_up_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_speed_up_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_speed_up_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_speed_up_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_speed_up_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_speed_up_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_speed_up_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_speed_up_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_speed_up_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// arena_speed_up_rsp

// required uint32 time = 1;
inline bool arena_speed_up_rsp::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_speed_up_rsp::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_speed_up_rsp::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_speed_up_rsp::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_speed_up_rsp::time() const {
  return time_;
}
inline void arena_speed_up_rsp::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// arena_challenge_req

// required uint32 target = 1;
inline bool arena_challenge_req::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_challenge_req::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_challenge_req::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_challenge_req::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 arena_challenge_req::target() const {
  return target_;
}
inline void arena_challenge_req::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
}

// required uint32 type = 2;
inline bool arena_challenge_req::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_challenge_req::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_challenge_req::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_challenge_req::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 arena_challenge_req::type() const {
  return type_;
}
inline void arena_challenge_req::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_challenge_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_challenge_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_challenge_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_challenge_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_challenge_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_challenge_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_challenge_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_challenge_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// arena_challenge_result

// required uint32 num = 1;
inline bool arena_challenge_result::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_challenge_result::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_challenge_result::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_challenge_result::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 arena_challenge_result::num() const {
  return num_;
}
inline void arena_challenge_result::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// required .client.FIGHT_RET_E ret = 2;
inline bool arena_challenge_result::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_challenge_result::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_challenge_result::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_challenge_result::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::client::FIGHT_RET_E arena_challenge_result::ret() const {
  return static_cast< ::client::FIGHT_RET_E >(ret_);
}
inline void arena_challenge_result::set_ret(::client::FIGHT_RET_E value) {
  assert(::client::FIGHT_RET_E_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// optional uint32 history = 3;
inline bool arena_challenge_result::has_history() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_challenge_result::set_has_history() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_challenge_result::clear_has_history() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_challenge_result::clear_history() {
  history_ = 0u;
  clear_has_history();
}
inline ::google::protobuf::uint32 arena_challenge_result::history() const {
  return history_;
}
inline void arena_challenge_result::set_history(::google::protobuf::uint32 value) {
  set_has_history();
  history_ = value;
}

// optional uint32 current = 4;
inline bool arena_challenge_result::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void arena_challenge_result::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void arena_challenge_result::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void arena_challenge_result::clear_current() {
  current_ = 0u;
  clear_has_current();
}
inline ::google::protobuf::uint32 arena_challenge_result::current() const {
  return current_;
}
inline void arena_challenge_result::set_current(::google::protobuf::uint32 value) {
  set_has_current();
  current_ = value;
}

// optional uint32 status = 5;
inline bool arena_challenge_result::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void arena_challenge_result::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void arena_challenge_result::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void arena_challenge_result::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 arena_challenge_result::status() const {
  return status_;
}
inline void arena_challenge_result::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// robot_attr

// optional uint32 role_id = 1;
inline bool robot_attr::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void robot_attr::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void robot_attr::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void robot_attr::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 robot_attr::role_id() const {
  return role_id_;
}
inline void robot_attr::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional string role_name = 2;
inline bool robot_attr::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void robot_attr::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void robot_attr::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void robot_attr::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& robot_attr::role_name() const {
  return *role_name_;
}
inline void robot_attr::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void robot_attr::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void robot_attr::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* robot_attr::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* robot_attr::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void robot_attr::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 3;
inline bool robot_attr::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void robot_attr::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void robot_attr::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void robot_attr::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 robot_attr::level() const {
  return level_;
}
inline void robot_attr::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 sex = 4;
inline bool robot_attr::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void robot_attr::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void robot_attr::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void robot_attr::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 robot_attr::sex() const {
  return sex_;
}
inline void robot_attr::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 profession = 5;
inline bool robot_attr::has_profession() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void robot_attr::set_has_profession() {
  _has_bits_[0] |= 0x00000010u;
}
inline void robot_attr::clear_has_profession() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void robot_attr::clear_profession() {
  profession_ = 0u;
  clear_has_profession();
}
inline ::google::protobuf::uint32 robot_attr::profession() const {
  return profession_;
}
inline void robot_attr::set_profession(::google::protobuf::uint32 value) {
  set_has_profession();
  profession_ = value;
}

// optional uint32 fighting_power = 6;
inline bool robot_attr::has_fighting_power() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void robot_attr::set_has_fighting_power() {
  _has_bits_[0] |= 0x00000020u;
}
inline void robot_attr::clear_has_fighting_power() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void robot_attr::clear_fighting_power() {
  fighting_power_ = 0u;
  clear_has_fighting_power();
}
inline ::google::protobuf::uint32 robot_attr::fighting_power() const {
  return fighting_power_;
}
inline void robot_attr::set_fighting_power(::google::protobuf::uint32 value) {
  set_has_fighting_power();
  fighting_power_ = value;
}

// optional uint32 hp_max = 7;
inline bool robot_attr::has_hp_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void robot_attr::set_has_hp_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void robot_attr::clear_has_hp_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void robot_attr::clear_hp_max() {
  hp_max_ = 0u;
  clear_has_hp_max();
}
inline ::google::protobuf::uint32 robot_attr::hp_max() const {
  return hp_max_;
}
inline void robot_attr::set_hp_max(::google::protobuf::uint32 value) {
  set_has_hp_max();
  hp_max_ = value;
}

// optional uint32 attack_min = 8;
inline bool robot_attr::has_attack_min() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void robot_attr::set_has_attack_min() {
  _has_bits_[0] |= 0x00000080u;
}
inline void robot_attr::clear_has_attack_min() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void robot_attr::clear_attack_min() {
  attack_min_ = 0u;
  clear_has_attack_min();
}
inline ::google::protobuf::uint32 robot_attr::attack_min() const {
  return attack_min_;
}
inline void robot_attr::set_attack_min(::google::protobuf::uint32 value) {
  set_has_attack_min();
  attack_min_ = value;
}

// optional uint32 attack_max = 9;
inline bool robot_attr::has_attack_max() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void robot_attr::set_has_attack_max() {
  _has_bits_[0] |= 0x00000100u;
}
inline void robot_attr::clear_has_attack_max() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void robot_attr::clear_attack_max() {
  attack_max_ = 0u;
  clear_has_attack_max();
}
inline ::google::protobuf::uint32 robot_attr::attack_max() const {
  return attack_max_;
}
inline void robot_attr::set_attack_max(::google::protobuf::uint32 value) {
  set_has_attack_max();
  attack_max_ = value;
}

// optional uint32 defense_min = 10;
inline bool robot_attr::has_defense_min() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void robot_attr::set_has_defense_min() {
  _has_bits_[0] |= 0x00000200u;
}
inline void robot_attr::clear_has_defense_min() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void robot_attr::clear_defense_min() {
  defense_min_ = 0u;
  clear_has_defense_min();
}
inline ::google::protobuf::uint32 robot_attr::defense_min() const {
  return defense_min_;
}
inline void robot_attr::set_defense_min(::google::protobuf::uint32 value) {
  set_has_defense_min();
  defense_min_ = value;
}

// optional uint32 defense_max = 11;
inline bool robot_attr::has_defense_max() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void robot_attr::set_has_defense_max() {
  _has_bits_[0] |= 0x00000400u;
}
inline void robot_attr::clear_has_defense_max() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void robot_attr::clear_defense_max() {
  defense_max_ = 0u;
  clear_has_defense_max();
}
inline ::google::protobuf::uint32 robot_attr::defense_max() const {
  return defense_max_;
}
inline void robot_attr::set_defense_max(::google::protobuf::uint32 value) {
  set_has_defense_max();
  defense_max_ = value;
}

// optional uint32 hit = 12;
inline bool robot_attr::has_hit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void robot_attr::set_has_hit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void robot_attr::clear_has_hit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void robot_attr::clear_hit() {
  hit_ = 0u;
  clear_has_hit();
}
inline ::google::protobuf::uint32 robot_attr::hit() const {
  return hit_;
}
inline void robot_attr::set_hit(::google::protobuf::uint32 value) {
  set_has_hit();
  hit_ = value;
}

// optional uint32 dodge = 13;
inline bool robot_attr::has_dodge() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void robot_attr::set_has_dodge() {
  _has_bits_[0] |= 0x00001000u;
}
inline void robot_attr::clear_has_dodge() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void robot_attr::clear_dodge() {
  dodge_ = 0u;
  clear_has_dodge();
}
inline ::google::protobuf::uint32 robot_attr::dodge() const {
  return dodge_;
}
inline void robot_attr::set_dodge(::google::protobuf::uint32 value) {
  set_has_dodge();
  dodge_ = value;
}

// optional uint32 recover = 14;
inline bool robot_attr::has_recover() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void robot_attr::set_has_recover() {
  _has_bits_[0] |= 0x00002000u;
}
inline void robot_attr::clear_has_recover() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void robot_attr::clear_recover() {
  recover_ = 0u;
  clear_has_recover();
}
inline ::google::protobuf::uint32 robot_attr::recover() const {
  return recover_;
}
inline void robot_attr::set_recover(::google::protobuf::uint32 value) {
  set_has_recover();
  recover_ = value;
}

// optional uint32 move_speed = 15;
inline bool robot_attr::has_move_speed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void robot_attr::set_has_move_speed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void robot_attr::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void robot_attr::clear_move_speed() {
  move_speed_ = 0u;
  clear_has_move_speed();
}
inline ::google::protobuf::uint32 robot_attr::move_speed() const {
  return move_speed_;
}
inline void robot_attr::set_move_speed(::google::protobuf::uint32 value) {
  set_has_move_speed();
  move_speed_ = value;
}

// optional uint32 stable = 16;
inline bool robot_attr::has_stable() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void robot_attr::set_has_stable() {
  _has_bits_[0] |= 0x00008000u;
}
inline void robot_attr::clear_has_stable() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void robot_attr::clear_stable() {
  stable_ = 0u;
  clear_has_stable();
}
inline ::google::protobuf::uint32 robot_attr::stable() const {
  return stable_;
}
inline void robot_attr::set_stable(::google::protobuf::uint32 value) {
  set_has_stable();
  stable_ = value;
}

// optional uint32 mount_id = 17;
inline bool robot_attr::has_mount_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void robot_attr::set_has_mount_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void robot_attr::clear_has_mount_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void robot_attr::clear_mount_id() {
  mount_id_ = 0u;
  clear_has_mount_id();
}
inline ::google::protobuf::uint32 robot_attr::mount_id() const {
  return mount_id_;
}
inline void robot_attr::set_mount_id(::google::protobuf::uint32 value) {
  set_has_mount_id();
  mount_id_ = value;
}

// optional uint32 weapon_id = 18;
inline bool robot_attr::has_weapon_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void robot_attr::set_has_weapon_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void robot_attr::clear_has_weapon_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void robot_attr::clear_weapon_id() {
  weapon_id_ = 0u;
  clear_has_weapon_id();
}
inline ::google::protobuf::uint32 robot_attr::weapon_id() const {
  return weapon_id_;
}
inline void robot_attr::set_weapon_id(::google::protobuf::uint32 value) {
  set_has_weapon_id();
  weapon_id_ = value;
}

// optional uint32 armor_id = 19;
inline bool robot_attr::has_armor_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void robot_attr::set_has_armor_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void robot_attr::clear_has_armor_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void robot_attr::clear_armor_id() {
  armor_id_ = 0u;
  clear_has_armor_id();
}
inline ::google::protobuf::uint32 robot_attr::armor_id() const {
  return armor_id_;
}
inline void robot_attr::set_armor_id(::google::protobuf::uint32 value) {
  set_has_armor_id();
  armor_id_ = value;
}

// optional .client.pet_db_info pet = 20;
inline bool robot_attr::has_pet() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void robot_attr::set_has_pet() {
  _has_bits_[0] |= 0x00080000u;
}
inline void robot_attr::clear_has_pet() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void robot_attr::clear_pet() {
  if (pet_ != NULL) pet_->::client::pet_db_info::Clear();
  clear_has_pet();
}
inline const ::client::pet_db_info& robot_attr::pet() const {
  return pet_ != NULL ? *pet_ : *default_instance_->pet_;
}
inline ::client::pet_db_info* robot_attr::mutable_pet() {
  set_has_pet();
  if (pet_ == NULL) pet_ = new ::client::pet_db_info;
  return pet_;
}
inline ::client::pet_db_info* robot_attr::release_pet() {
  clear_has_pet();
  ::client::pet_db_info* temp = pet_;
  pet_ = NULL;
  return temp;
}
inline void robot_attr::set_allocated_pet(::client::pet_db_info* pet) {
  delete pet_;
  pet_ = pet;
  if (pet) {
    set_has_pet();
  } else {
    clear_has_pet();
  }
}

// optional uint32 config_id = 21;
inline bool robot_attr::has_config_id() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void robot_attr::set_has_config_id() {
  _has_bits_[0] |= 0x00100000u;
}
inline void robot_attr::clear_has_config_id() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void robot_attr::clear_config_id() {
  config_id_ = 0u;
  clear_has_config_id();
}
inline ::google::protobuf::uint32 robot_attr::config_id() const {
  return config_id_;
}
inline void robot_attr::set_config_id(::google::protobuf::uint32 value) {
  set_has_config_id();
  config_id_ = value;
}

// optional .client.skills sk = 22;
inline bool robot_attr::has_sk() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void robot_attr::set_has_sk() {
  _has_bits_[0] |= 0x00200000u;
}
inline void robot_attr::clear_has_sk() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void robot_attr::clear_sk() {
  if (sk_ != NULL) sk_->::client::skills::Clear();
  clear_has_sk();
}
inline const ::client::skills& robot_attr::sk() const {
  return sk_ != NULL ? *sk_ : *default_instance_->sk_;
}
inline ::client::skills* robot_attr::mutable_sk() {
  set_has_sk();
  if (sk_ == NULL) sk_ = new ::client::skills;
  return sk_;
}
inline ::client::skills* robot_attr::release_sk() {
  clear_has_sk();
  ::client::skills* temp = sk_;
  sk_ = NULL;
  return temp;
}
inline void robot_attr::set_allocated_sk(::client::skills* sk) {
  delete sk_;
  sk_ = sk;
  if (sk) {
    set_has_sk();
  } else {
    clear_has_sk();
  }
}

// optional .client.pet_db_info backup = 23;
inline bool robot_attr::has_backup() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void robot_attr::set_has_backup() {
  _has_bits_[0] |= 0x00400000u;
}
inline void robot_attr::clear_has_backup() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void robot_attr::clear_backup() {
  if (backup_ != NULL) backup_->::client::pet_db_info::Clear();
  clear_has_backup();
}
inline const ::client::pet_db_info& robot_attr::backup() const {
  return backup_ != NULL ? *backup_ : *default_instance_->backup_;
}
inline ::client::pet_db_info* robot_attr::mutable_backup() {
  set_has_backup();
  if (backup_ == NULL) backup_ = new ::client::pet_db_info;
  return backup_;
}
inline ::client::pet_db_info* robot_attr::release_backup() {
  clear_has_backup();
  ::client::pet_db_info* temp = backup_;
  backup_ = NULL;
  return temp;
}
inline void robot_attr::set_allocated_backup(::client::pet_db_info* backup) {
  delete backup_;
  backup_ = backup;
  if (backup) {
    set_has_backup();
  } else {
    clear_has_backup();
  }
}

// optional uint32 x = 24;
inline bool robot_attr::has_x() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void robot_attr::set_has_x() {
  _has_bits_[0] |= 0x00800000u;
}
inline void robot_attr::clear_has_x() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void robot_attr::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 robot_attr::x() const {
  return x_;
}
inline void robot_attr::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// optional uint32 y = 25;
inline bool robot_attr::has_y() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void robot_attr::set_has_y() {
  _has_bits_[0] |= 0x01000000u;
}
inline void robot_attr::clear_has_y() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void robot_attr::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 robot_attr::y() const {
  return y_;
}
inline void robot_attr::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// optional uint32 family_id = 26;
inline bool robot_attr::has_family_id() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void robot_attr::set_has_family_id() {
  _has_bits_[0] |= 0x02000000u;
}
inline void robot_attr::clear_has_family_id() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void robot_attr::clear_family_id() {
  family_id_ = 0u;
  clear_has_family_id();
}
inline ::google::protobuf::uint32 robot_attr::family_id() const {
  return family_id_;
}
inline void robot_attr::set_family_id(::google::protobuf::uint32 value) {
  set_has_family_id();
  family_id_ = value;
}

// optional uint32 vip_level = 27;
inline bool robot_attr::has_vip_level() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void robot_attr::set_has_vip_level() {
  _has_bits_[0] |= 0x04000000u;
}
inline void robot_attr::clear_has_vip_level() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void robot_attr::clear_vip_level() {
  vip_level_ = 0u;
  clear_has_vip_level();
}
inline ::google::protobuf::uint32 robot_attr::vip_level() const {
  return vip_level_;
}
inline void robot_attr::set_vip_level(::google::protobuf::uint32 value) {
  set_has_vip_level();
  vip_level_ = value;
}

// -------------------------------------------------------------------

// load_target_data_req

// required uint32 target = 1;
inline bool load_target_data_req::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void load_target_data_req::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void load_target_data_req::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void load_target_data_req::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 load_target_data_req::target() const {
  return target_;
}
inline void load_target_data_req::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
}

// required uint32 scene_id = 2;
inline bool load_target_data_req::has_scene_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void load_target_data_req::set_has_scene_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void load_target_data_req::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void load_target_data_req::clear_scene_id() {
  scene_id_ = 0u;
  clear_has_scene_id();
}
inline ::google::protobuf::uint32 load_target_data_req::scene_id() const {
  return scene_id_;
}
inline void load_target_data_req::set_scene_id(::google::protobuf::uint32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// required uint32 role_id = 3;
inline bool load_target_data_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void load_target_data_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void load_target_data_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void load_target_data_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 load_target_data_req::role_id() const {
  return role_id_;
}
inline void load_target_data_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// -------------------------------------------------------------------

// load_target_data_rsp

// required uint32 role_id = 1;
inline bool load_target_data_rsp::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void load_target_data_rsp::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void load_target_data_rsp::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void load_target_data_rsp::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 load_target_data_rsp::role_id() const {
  return role_id_;
}
inline void load_target_data_rsp::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required .client.robot_attr attr = 2;
inline bool load_target_data_rsp::has_attr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void load_target_data_rsp::set_has_attr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void load_target_data_rsp::clear_has_attr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void load_target_data_rsp::clear_attr() {
  if (attr_ != NULL) attr_->::client::robot_attr::Clear();
  clear_has_attr();
}
inline const ::client::robot_attr& load_target_data_rsp::attr() const {
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
}
inline ::client::robot_attr* load_target_data_rsp::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) attr_ = new ::client::robot_attr;
  return attr_;
}
inline ::client::robot_attr* load_target_data_rsp::release_attr() {
  clear_has_attr();
  ::client::robot_attr* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void load_target_data_rsp::set_allocated_attr(::client::robot_attr* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
}

// -------------------------------------------------------------------

// load_online_target_data_req

// required uint32 target = 1;
inline bool load_online_target_data_req::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void load_online_target_data_req::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void load_online_target_data_req::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void load_online_target_data_req::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 load_online_target_data_req::target() const {
  return target_;
}
inline void load_online_target_data_req::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
}

// required uint32 role_id = 2;
inline bool load_online_target_data_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void load_online_target_data_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void load_online_target_data_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void load_online_target_data_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 load_online_target_data_req::role_id() const {
  return role_id_;
}
inline void load_online_target_data_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// required uint32 svr_scene_id = 3;
inline bool load_online_target_data_req::has_svr_scene_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void load_online_target_data_req::set_has_svr_scene_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void load_online_target_data_req::clear_has_svr_scene_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void load_online_target_data_req::clear_svr_scene_id() {
  svr_scene_id_ = 0u;
  clear_has_svr_scene_id();
}
inline ::google::protobuf::uint32 load_online_target_data_req::svr_scene_id() const {
  return svr_scene_id_;
}
inline void load_online_target_data_req::set_svr_scene_id(::google::protobuf::uint32 value) {
  set_has_svr_scene_id();
  svr_scene_id_ = value;
}

// -------------------------------------------------------------------

// arena_reward_req

// required uint32 role_id = 1;
inline bool arena_reward_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_reward_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_reward_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_reward_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 arena_reward_req::role_id() const {
  return role_id_;
}
inline void arena_reward_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_reward_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_reward_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_reward_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_reward_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_reward_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_reward_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_reward_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_reward_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// reward_info

// required uint32 type = 1;
inline bool reward_info::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reward_info::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reward_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reward_info::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 reward_info::type() const {
  return type_;
}
inline void reward_info::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 value = 2;
inline bool reward_info::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reward_info::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reward_info::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reward_info::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 reward_info::value() const {
  return value_;
}
inline void reward_info::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// arena_reward_item

// required uint32 min_rank = 1;
inline bool arena_reward_item::has_min_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_reward_item::set_has_min_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_reward_item::clear_has_min_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_reward_item::clear_min_rank() {
  min_rank_ = 0u;
  clear_has_min_rank();
}
inline ::google::protobuf::uint32 arena_reward_item::min_rank() const {
  return min_rank_;
}
inline void arena_reward_item::set_min_rank(::google::protobuf::uint32 value) {
  set_has_min_rank();
  min_rank_ = value;
}

// required uint32 max_rank = 2;
inline bool arena_reward_item::has_max_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_reward_item::set_has_max_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_reward_item::clear_has_max_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_reward_item::clear_max_rank() {
  max_rank_ = 0u;
  clear_has_max_rank();
}
inline ::google::protobuf::uint32 arena_reward_item::max_rank() const {
  return max_rank_;
}
inline void arena_reward_item::set_max_rank(::google::protobuf::uint32 value) {
  set_has_max_rank();
  max_rank_ = value;
}

// repeated .client.reward_info ri = 3;
inline int arena_reward_item::ri_size() const {
  return ri_.size();
}
inline void arena_reward_item::clear_ri() {
  ri_.Clear();
}
inline const ::client::reward_info& arena_reward_item::ri(int index) const {
  return ri_.Get(index);
}
inline ::client::reward_info* arena_reward_item::mutable_ri(int index) {
  return ri_.Mutable(index);
}
inline ::client::reward_info* arena_reward_item::add_ri() {
  return ri_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::reward_info >&
arena_reward_item::ri() const {
  return ri_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::reward_info >*
arena_reward_item::mutable_ri() {
  return &ri_;
}

// -------------------------------------------------------------------

// arena_reward_rsp

// repeated .client.arena_reward_item ari = 1;
inline int arena_reward_rsp::ari_size() const {
  return ari_.size();
}
inline void arena_reward_rsp::clear_ari() {
  ari_.Clear();
}
inline const ::client::arena_reward_item& arena_reward_rsp::ari(int index) const {
  return ari_.Get(index);
}
inline ::client::arena_reward_item* arena_reward_rsp::mutable_ari(int index) {
  return ari_.Mutable(index);
}
inline ::client::arena_reward_item* arena_reward_rsp::add_ari() {
  return ari_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::arena_reward_item >&
arena_reward_rsp::ari() const {
  return ari_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::arena_reward_item >*
arena_reward_rsp::mutable_ari() {
  return &ari_;
}

// -------------------------------------------------------------------

// arena_rank_list_req

// required uint32 role_id = 1;
inline bool arena_rank_list_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_rank_list_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_rank_list_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_rank_list_req::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 arena_rank_list_req::role_id() const {
  return role_id_;
}
inline void arena_rank_list_req::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_rank_list_req::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_rank_list_req::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_rank_list_req::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_rank_list_req::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_rank_list_req::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_rank_list_req::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_rank_list_req::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_rank_list_req::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}

// -------------------------------------------------------------------

// rank_list_item

// required string name = 1;
inline bool rank_list_item::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_list_item::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_list_item::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_list_item::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& rank_list_item::name() const {
  return *name_;
}
inline void rank_list_item::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void rank_list_item::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void rank_list_item::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rank_list_item::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* rank_list_item::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rank_list_item::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 level = 2;
inline bool rank_list_item::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_list_item::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_list_item::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_list_item::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 rank_list_item::level() const {
  return level_;
}
inline void rank_list_item::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 power = 3;
inline bool rank_list_item::has_power() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rank_list_item::set_has_power() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rank_list_item::clear_has_power() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rank_list_item::clear_power() {
  power_ = 0u;
  clear_has_power();
}
inline ::google::protobuf::uint32 rank_list_item::power() const {
  return power_;
}
inline void rank_list_item::set_power(::google::protobuf::uint32 value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// arena_rank_list_rsp

// required int32 rank = 1;
inline bool arena_rank_list_rsp::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_rank_list_rsp::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_rank_list_rsp::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_rank_list_rsp::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 arena_rank_list_rsp::rank() const {
  return rank_;
}
inline void arena_rank_list_rsp::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// repeated .client.rank_list_item rli = 2;
inline int arena_rank_list_rsp::rli_size() const {
  return rli_.size();
}
inline void arena_rank_list_rsp::clear_rli() {
  rli_.Clear();
}
inline const ::client::rank_list_item& arena_rank_list_rsp::rli(int index) const {
  return rli_.Get(index);
}
inline ::client::rank_list_item* arena_rank_list_rsp::mutable_rli(int index) {
  return rli_.Mutable(index);
}
inline ::client::rank_list_item* arena_rank_list_rsp::add_rli() {
  return rli_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::client::rank_list_item >&
arena_rank_list_rsp::rli() const {
  return rli_;
}
inline ::google::protobuf::RepeatedPtrField< ::client::rank_list_item >*
arena_rank_list_rsp::mutable_rli() {
  return &rli_;
}

// -------------------------------------------------------------------

// arena_fight_begin

// required uint32 time = 1;
inline bool arena_fight_begin::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_fight_begin::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_fight_begin::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_fight_begin::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_fight_begin::time() const {
  return time_;
}
inline void arena_fight_begin::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .client.server_head svr_head = 1000;
inline bool arena_fight_begin::has_svr_head() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_fight_begin::set_has_svr_head() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_fight_begin::clear_has_svr_head() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_fight_begin::clear_svr_head() {
  if (svr_head_ != NULL) svr_head_->::client::server_head::Clear();
  clear_has_svr_head();
}
inline const ::client::server_head& arena_fight_begin::svr_head() const {
  return svr_head_ != NULL ? *svr_head_ : *default_instance_->svr_head_;
}
inline ::client::server_head* arena_fight_begin::mutable_svr_head() {
  set_has_svr_head();
  if (svr_head_ == NULL) svr_head_ = new ::client::server_head;
  return svr_head_;
}
inline ::client::server_head* arena_fight_begin::release_svr_head() {
  clear_has_svr_head();
  ::client::server_head* temp = svr_head_;
  svr_head_ = NULL;
  return temp;
}
inline void arena_fight_begin::set_allocated_svr_head(::client::server_head* svr_head) {
  delete svr_head_;
  svr_head_ = svr_head;
  if (svr_head) {
    set_has_svr_head();
  } else {
    clear_has_svr_head();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::FIGHT_RET_E>() {
  return ::client::FIGHT_RET_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2earena_2eproto__INCLUDED
