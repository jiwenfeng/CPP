!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	posix/Makefile	/^A= $(MYLIB).tar.gz$/;"	m
AR	luamongodb/Makefile	/^AR= ar rcu$/;"	m
AddArg	luacall.cpp	/^void TArgPool::AddArg()$/;"	f	class:TArgPool
AddArg	luacall.cpp	/^void TArgPool::AddArg(bool Value)$/;"	f	class:TArgPool
AddArg	luacall.cpp	/^void TArgPool::AddArg(const std::string& Str)$/;"	f	class:TArgPool
AddArg	luacall.cpp	/^void TArgPool::AddArg(double Value)$/;"	f	class:TArgPool
AddBeSeen	scene.cpp	/^inline void CGrid::AddBeSeen(const char * char_id)$/;"	f	class:CGrid
AddBeSeen	scene.cpp	/^void CScene::AddBeSeen(const char * char_id, const std::vector<CGrid *> *p_enter_grid)$/;"	f	class:CScene
AddPlayer	scene.cpp	/^bool CScene::AddPlayer(const char * char_id, const struct Point *p_point, int lua_aoi, void *p_context)$/;"	f	class:CScene
AddPlayer	scene.cpp	/^inline void CGrid::AddPlayer(const char * char_id)$/;"	f	class:CGrid
AddPlayer	scene.cpp	/^void AddPlayer(int id, const char * char_id, int pos_x, int pos_y, int lua_aoi, void *p_context)$/;"	f
AddRemoveCommon	scene.cpp	/^int CScene::AddRemoveCommon(const struct Point *p_point, int lua_aoi, std::vector<CGrid *> *p_grid, std::vector<const char *> *p_other)$/;"	f	class:CScene
AllSize	lmemory.cpp	/^size_t AllSize[] = {12, 20, 24, 27, 28, 32, 36, 48, 56, 112, 224, 448};$/;"	v
ArgList	luacall.hpp	/^	std::vector<TArg*> ArgList;$/;"	m	class:TArgPool
BASE64_CHARS	base64.cpp	/^const char *BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
BASE64_H	base64.hpp	20;"	d
BASE64_LENGTH	base64.hpp	28;"	d
BLOCKSIZE	lmemory.hpp	16;"	d
CC	Makefile	/^CC=g++$/;"	m
CC	luamongodb/Makefile	/^CC= g++$/;"	m
CFLAGS	luamongodb/Makefile	/^CFLAGS= -g -O2 -shared -fpic -I\/usr\/include\/ -I \/usr\/local\/mongo\/include\/mongo\/ -I \/usr\/local\/mongo\/include\/ -I \/usr\/include\/mongo\/$/;"	m
CFLAGS	luamongodb/Makefile	/^CFLAGS= -g -O2 -shared -fpic -I\/usr\/local\/include\/ -I \/usr\/local\/include\/mongo\/ -I \/usr\/local\/include\/lua51$/;"	m
CFLAGS	luamongodb/Makefile	/^old: CFLAGS := $(CFLAGS) -DMONGO_PRE_1_5$/;"	m
CFLAGS	posix/Makefile	/^CFLAGS= -fPIC $(INCS) $(WARN) -g -O2 $G$/;"	m
CGrid	scene.cpp	/^CGrid::CGrid()$/;"	f	class:CGrid
CGrid	scene.hpp	/^class CGrid {$/;"	c
CHUNK	luamongodb/common.h	26;"	d
CHUNK	luamongodb/common.h	28;"	d
CLIENT	netlib.hpp	12;"	d
CLK_TCK	posix/lposix.c	36;"	d	file:
CPPFLAGS	Makefile	/^CPPFLAGS= -Wall -g -O0 -I \/usr\/local\/include\/ -I \/usr\/include\/ -I \/usr\/local\/include -I \/usr\/local\/ssl\/include -I \/usr\/local\/include\/lua51$/;"	m
CScene	scene.cpp	/^CScene::CScene(int id, int _screen_width, int _screen_height):scene_id(id), screen_width(_screen_width), screen_height(_screen_height)$/;"	f	class:CScene
CScene	scene.hpp	/^class CScene {$/;"	c
CURL_DATA_LEN	netlib.cpp	11;"	d	file:
CalSubBeSeen	scene.cpp	/^inline void CScene::CalSubBeSeen(int src_index, int dst_index, std::vector<const char *> *p_sub_result)$/;"	f	class:CScene
CalSubSee	scene.cpp	/^inline void CScene::CalSubSee(struct GridRect *p_src_rect, struct GridRect *p_dst_rect, std::vector<CGrid *> *p_sub_result)$/;"	f	class:CScene
CalculateAOIRect	scene.cpp	/^inline void CScene::CalculateAOIRect(struct GridRect *p_ret_rect, int x, int y, int lua_aoi)$/;"	f	class:CScene
CallLua	luacall.cpp	/^int CallLua(lua_State* L, const char* fname)$/;"	f
CallLua	luacall.cpp	/^int CallLua(lua_State* L, const char* fname, const TArgPool& ArgPoolObj)$/;"	f
CallLua	luacall.cpp	/^int CallLua(lua_State* L, int funref, const TArgPool& ArgPoolObj)$/;"	f
ChangeGrid	scene.cpp	/^inline bool CScene::ChangeGrid(int src_x_index, int src_y_index, int dst_x_index, int dst_y_index)$/;"	f	class:CScene
ChangeGridAOI	scene.cpp	/^inline bool CScene::ChangeGridAOI(const struct GridRect *p_src_rect, const struct GridRect *p_dst_rect)$/;"	f	class:CScene
CheckPosition	scene.cpp	/^inline bool CScene::CheckPosition(const struct Point *p_point)$/;"	f	class:CScene
CheckPosition	scene.cpp	/^inline bool CScene::CheckPosition(int x, int y)$/;"	f	class:CScene
CurlGetCallback	netlib.cpp	/^static size_t CurlGetCallback(void *ptr, size_t size, size_t nmemb, void *userdata)$/;"	f	file:
CurlHttpGet	netlib.cpp	/^int CurlHttpGet(lua_State *L)$/;"	f
CurlHttpPost	netlib.cpp	/^int CurlHttpPost(lua_State *L)$/;"	f
D	posix/Makefile	/^D= $(MYNAME)$/;"	m
DelReadBufferData	netlib.cpp	/^int TClientSocket::DelReadBufferData(unsigned int length)$/;"	f	class:TClientSocket
Desc	luacall.cpp	/^		virtual std::string Desc() const {$/;"	f	class:TArgBool
Desc	luacall.cpp	/^		virtual std::string Desc() const {$/;"	f	class:TArgNil
Desc	luacall.cpp	/^		virtual std::string Desc() const {$/;"	f	class:TArgNumber
Desc	luacall.cpp	/^		virtual std::string Desc() const {$/;"	f	class:TArgStr
Desc	luacall.cpp	/^std::string TArgPool::Desc() const{$/;"	f	class:TArgPool
EXIT_SCRIPT	main.cpp	/^const char* EXIT_SCRIPT = "signal_exit";$/;"	v
EnterPos	scene.cpp	/^bool CScene::EnterPos(const char * char_id, int enter_index, const std::vector<CGrid *> *p_enter_grid, const std::vector<const char *> *p_enter_other, void *p_context)$/;"	f	class:CScene
FHEADER_SIZE	lmemory.cpp	12;"	d	file:
FREELIST_T	lmemory.cpp	13;"	d	file:
FTP	posix/Makefile	/^FTP= $(HOME)\/public\/ftp\/lua$/;"	m
FgetID	posix/lposix.c	/^static int FgetID(lua_State *L, int i, const void *data)$/;"	f	file:
Fgetpasswd	posix/lposix.c	/^static int Fgetpasswd(lua_State *L, int i, const void *data)$/;"	f	file:
Fpathconf	posix/lposix.c	/^static int Fpathconf(lua_State *L, int i, const void *data)$/;"	f	file:
Fstat	posix/lposix.c	/^static int Fstat(lua_State *L, int i, const void *data)$/;"	f	file:
Fsysconf	posix/lposix.c	/^static int Fsysconf(lua_State *L, int i, const void *data)$/;"	f	file:
Ftimes	posix/lposix.c	/^static int Ftimes(lua_State *L, int i, const void *data)$/;"	f	file:
GMAKE	Makefile	/^	GMAKE = gmake$/;"	m
GMAKE	Makefile	/^	GMAKE = make$/;"	m
GOLDEN	hash.cpp	69;"	d	file:
GenericHandler	netlib.cpp	/^void GenericHandler(evhttp_request *req, void *arg)$/;"	f
GetBeSeenSet	scene.hpp	/^		std::set<const char *> * GetBeSeenSet()$/;"	f	class:CGrid
GetExNeighbor	scene.cpp	/^void CScene::GetExNeighbor(lua_State *L, const char * char_id, int x, int y)$/;"	f	class:CScene
GetExNeighbor	scene.cpp	/^void GetExNeighbor(lua_State *L, const char * char_id, int id, int x, int y)$/;"	f
GetNeighbor	scene.cpp	/^void CScene::GetNeighbor(lua_State *L, const char * char_id, int x, int y, int lua_aoi)$/;"	f	class:CScene
GetNeighbor	scene.cpp	/^void GetNeighbor(lua_State *L, const char * char_id, int id, int x, int y, int lua_aoi)$/;"	f
GetReadBuffer	netlib.cpp	/^char* TClientSocket::GetReadBuffer()$/;"	f	class:TClientSocket
GetSeeSet	scene.hpp	/^		std::set<const char *> * GetSeeSet()$/;"	f	class:CGrid
GridHeight	scene.hpp	/^const int GridHeight = 32;$/;"	v
GridRect	scene.hpp	/^struct GridRect {$/;"	s
GridWidth	scene.hpp	/^const int GridWidth = 32;$/;"	v
Head	netlib.hpp	/^}__attribute__((packed)) Head;$/;"	t	typeref:struct:Head_t
Head_t	netlib.hpp	/^typedef struct Head_t{$/;"	s
IHASH	hash.hpp	18;"	d
INCS	posix/Makefile	/^INCS= -I$(LUAINC) -I\/usr\/local\/include\/lua51\/$/;"	m
InRect	scene.cpp	/^inline bool InRect(int x, int y, const struct GridRect *p_rect)$/;"	f
InfiniteLoop	lstack.cpp	/^static void InfiniteLoop(lua_State *L, lua_Debug *de)$/;"	f	file:
InitHttp	netlib.cpp	/^int InitHttp(lua_State *L, int Port)$/;"	f
IsEffectiveRect	scene.cpp	/^inline bool IsEffectiveRect(const struct GridRect *p_rect)$/;"	f
IsGateWayDataThrowed	netlib.cpp	/^bool TClientSocket::IsGateWayDataThrowed()$/;"	f	class:TClientSocket
IsSocketFd	netlib.cpp	/^int IsSocketFd(lua_State* L)$/;"	f
Kpathconf	posix/lposix.c	/^static const int Kpathconf[] =$/;"	v	file:
Ksysconf	posix/lposix.c	/^static const int Ksysconf[] =$/;"	v	file:
LDFLAGS	luamongodb/Makefile	/^LDFLAGS= $(LIBS)$/;"	m
LIB	Makefile	/^	LIB = -static -L\/usr\/lib -L\/usr\/local\/lib -L\/usr\/local\/ssl\/lib\/ -L\/usr\/lib64\/ -L\/usr\/local\/mongo\/lib\/ -llua -levent  -lmsgpack -lmongoclient -lboost_thread-mt -lboost_system -lboost_program_options -lboost_filesystem -lpthread -lreadline -lrt -lz -loauth -lcurl -lssl -lidn -lcrypto -ldl$/;"	m
LIB	Makefile	/^	LIB=--static -L\/usr\/local\/lib\/lua51 -L\/usr\/local\/lib -llua -lreadline -levent -liconv -lz -lmongoclient -lboost_thread -lboost_system -lboost_filesystem -lboost_program_options -lpthread -lmsgpack -loauth -lcurl -lssl  -lidn -lcrypto -lintl$/;"	m
LIBS	luamongodb/Makefile	/^LIBS=-L\/usr\/local\/lib -L\/usr\/local\/lib\/lua51\/ -L\/usr\/local\/mongo\/lib -lmongoclient -lboost_thread-mt -lboost_filesystem -lboost_program_options -llua$/;"	m
LIBS	luamongodb/Makefile	/^LIBS=-L\/usr\/local\/lib -L\/usr\/local\/lib\/lua51\/ -lmongoclient -lboost_thread -lboost_filesystem -lboost_program_options -llua$/;"	m
LM_EXPORT	luamongodb/utils.h	86;"	d
LM_EXPORT	luamongodb/utils.h	88;"	d
LNEW_AOI	lscene.hpp	2;"	d
LState	main.cpp	/^lua_State* LState = NULL;$/;"	v
LUA	posix/Makefile	/^LUA= \/usr$/;"	m
LUABIN	posix/Makefile	/^LUABIN= $(LUA)\/bin$/;"	m
LUAINC	posix/Makefile	/^LUAINC= $(LUA)\/include$/;"	m
LUALIB	posix/Makefile	/^LUALIB= $(LUA)\/lib$/;"	m
LUAMONGO_CONNECTION	luamongodb/common.h	2;"	d
LUAMONGO_CURSOR	luamongodb/common.h	3;"	d
LUAMONGO_ERR_CALLING	luamongodb/common.h	23;"	d
LUAMONGO_ERR_CONNECTION_FAILED	luamongodb/common.h	9;"	d
LUAMONGO_ERR_CONNECT_FAILED	luamongodb/common.h	14;"	d
LUAMONGO_ERR_COUNT_FAILED	luamongodb/common.h	15;"	d
LUAMONGO_ERR_GRIDFSCHUNK_FAILED	luamongodb/common.h	11;"	d
LUAMONGO_ERR_GRIDFS_FAILED	luamongodb/common.h	10;"	d
LUAMONGO_ERR_INSERT_FAILED	luamongodb/common.h	13;"	d
LUAMONGO_ERR_QUERY_FAILED	luamongodb/common.h	12;"	d
LUAMONGO_ERR_REMOVE_FAILED	luamongodb/common.h	16;"	d
LUAMONGO_ERR_UPDATE_FAILED	luamongodb/common.h	17;"	d
LUAMONGO_GRIDFILE	luamongodb/common.h	6;"	d
LUAMONGO_GRIDFS	luamongodb/common.h	5;"	d
LUAMONGO_GRIDFSCHUNK	luamongodb/common.h	7;"	d
LUAMONGO_NOT_IMPLEMENTED	luamongodb/common.h	22;"	d
LUAMONGO_QUERY	luamongodb/common.h	4;"	d
LUAMONGO_REQUIRES_JSON_OR_TABLE	luamongodb/common.h	20;"	d
LUAMONGO_REQUIRES_QUERY	luamongodb/common.h	21;"	d
LUAMONGO_ROOT	luamongodb/common.h	1;"	d
LUAMONGO_UNSUPPORTED_BSON_TYPE	luamongodb/common.h	18;"	d
LUAMONGO_UNSUPPORTED_LUA_TYPE	luamongodb/common.h	19;"	d
LUA_PUSH_ARRAY_BOOL	luamongodb/utils.h	74;"	d
LUA_PUSH_ARRAY_FLOAT	luamongodb/utils.h	64;"	d
LUA_PUSH_ARRAY_INT	luamongodb/utils.h	59;"	d
LUA_PUSH_ARRAY_NIL	luamongodb/utils.h	79;"	d
LUA_PUSH_ARRAY_STRING	luamongodb/utils.h	69;"	d
LUA_PUSH_ATTRIB_BOOL	luamongodb/utils.h	47;"	d
LUA_PUSH_ATTRIB_FLOAT	luamongodb/utils.h	37;"	d
LUA_PUSH_ATTRIB_INT	luamongodb/utils.h	32;"	d
LUA_PUSH_ATTRIB_NIL	luamongodb/utils.h	52;"	d
LUA_PUSH_ATTRIB_STRING	luamongodb/utils.h	42;"	d
LeavePos	scene.cpp	/^bool CScene::LeavePos(const char * char_id, int leave_index, const std::vector<CGrid *> *p_leave_grid, const std::vector<const char *> *p_leave_other, void *p_context, int flag)$/;"	f	class:CScene
LeftAOIProc	scene.cpp	/^static void LeftAOIProc(const char * char_id, const std::vector<CGrid *> *p_grid, lua_State *L, int flag)$/;"	f	file:
Logfile	main.cpp	/^FILE* Logfile = NULL;$/;"	v
MD5_LENGTH	api.cpp	18;"	d	file:
MYBUFSIZ	posix/lposix.c	33;"	d	file:
MYLIB	posix/Makefile	/^MYLIB= l$(MYNAME)$/;"	m
MYNAME	posix/Makefile	/^MYNAME= posix$/;"	m
MYNAME	posix/lposix.c	26;"	d	file:
MYVERSION	posix/lposix.c	27;"	d	file:
Move	scene.cpp	/^bool CScene::Move(const char * char_id, const struct Point *p_src_point, const struct Point *p_dst_point, int lua_aoi, void *p_context)$/;"	f	class:CScene
Move	scene.cpp	/^void Move(int id, const char * char_id, int src_x, int src_y, int dst_x, int dst_y, int lua_aoi, void *p_context)$/;"	f
NBUCKETS	lmemory.cpp	16;"	d	file:
NEW_AOI	scene.hpp	2;"	d
NewScene	scene.cpp	/^void NewScene(int id, int screen_width, int screen_height)$/;"	f
Now	main.cpp	/^const char * Now()$/;"	f
OBJ	Makefile	/^OBJ=${SRC:%.cpp=%.o}$/;"	m
OBJS	luamongodb/Makefile	/^OBJS = main.o mongo_bsontypes.o mongo_connection.o mongo_cursor.o mongo_gridfile.o mongo_gridfs.o mongo_gridfschunk.o mongo_query.o utils.o$/;"	m
OBJS	posix/Makefile	/^OBJS= $(MYLIB).o$/;"	m
ONCE	callout.hpp	9;"	d
OUTLIB	luamongodb/Makefile	/^OUTLIB=mongo.so$/;"	m
OnEnterLeftAOI	scene.cpp	/^static void OnEnterLeftAOI(const char * enter_char_id, const std::vector<CGrid *> *p_enter_grid, void *p_context)$/;"	f	file:
OnEnterRightAOI	scene.cpp	/^static void OnEnterRightAOI(const char * enter_char_id, const std::vector<const char *> *p_enter_other, void *p_context)$/;"	f	file:
OnLeaveLeftAOI	scene.cpp	/^static void OnLeaveLeftAOI(const char * leave_char_id, const std::vector<CGrid *> *p_leave_grid, void *p_context, int flag)$/;"	f	file:
OnLeaveRightAOI	scene.cpp	/^static void OnLeaveRightAOI(const char * leave_char_id, const std::vector<const char *> *p_leave_other, void *p_context)$/;"	f	file:
PERSIST	callout.hpp	10;"	d
PUSHRUSAGE	api.cpp	502;"	d	file:
Paccess	posix/lposix.c	/^static int Paccess(lua_State *L)		\/** access(path,[mode]) *\/$/;"	f	file:
Pchdir	posix/lposix.c	/^static int Pchdir(lua_State *L)			\/** chdir(path) *\/$/;"	f	file:
Pchmod	posix/lposix.c	/^static int Pchmod(lua_State *L)			\/** chmod(path,mode) *\/$/;"	f	file:
Pchown	posix/lposix.c	/^static int Pchown(lua_State *L)			\/** chown(path,uid,gid) *\/$/;"	f	file:
Pctermid	posix/lposix.c	/^static int Pctermid(lua_State *L)		\/** ctermid() *\/$/;"	f	file:
Pdir	posix/lposix.c	/^static int Pdir(lua_State *L)			\/** dir([path]) *\/$/;"	f	file:
Perrno	posix/lposix.c	/^static int Perrno(lua_State *L)			\/** errno() *\/$/;"	f	file:
Pexec	posix/lposix.c	/^static int Pexec(lua_State *L)			\/** exec(path,[args]) *\/$/;"	f	file:
Pfiles	posix/lposix.c	/^static int Pfiles(lua_State *L)			\/** files([path]) *\/$/;"	f	file:
Pfork	posix/lposix.c	/^static int Pfork(lua_State *L)			\/** fork() *\/$/;"	f	file:
Pgetcwd	posix/lposix.c	/^static int Pgetcwd(lua_State *L)		\/** getcwd() *\/$/;"	f	file:
Pgetenv	posix/lposix.c	/^static int Pgetenv(lua_State *L)		\/** getenv([name]) *\/$/;"	f	file:
Pgetgroup	posix/lposix.c	/^static int Pgetgroup(lua_State *L)		\/** getgroup(name or id) *\/$/;"	f	file:
Pgetlogin	posix/lposix.c	/^static int Pgetlogin(lua_State *L)		\/** getlogin() *\/$/;"	f	file:
Pgetpasswd	posix/lposix.c	/^static int Pgetpasswd(lua_State *L)		\/** getpasswd(name or id) *\/$/;"	f	file:
Pgetprocessid	posix/lposix.c	/^static int Pgetprocessid(lua_State *L)		\/** getprocessid([selector]) *\/$/;"	f	file:
Pkill	posix/lposix.c	/^static int Pkill(lua_State *L)			\/** kill(pid,[sig]) *\/$/;"	f	file:
Plink	posix/lposix.c	/^static int Plink(lua_State *L)			\/** link(oldpath,newpath) *\/$/;"	f	file:
Pmkdir	posix/lposix.c	/^static int Pmkdir(lua_State *L)			\/** mkdir(path) *\/$/;"	f	file:
Pmkfifo	posix/lposix.c	/^static int Pmkfifo(lua_State *L)		\/** mkfifo(path) *\/$/;"	f	file:
Point	scene.hpp	/^struct Point {$/;"	s
Ppathconf	posix/lposix.c	/^static int Ppathconf(lua_State *L)		\/** pathconf(path,[selector]) *\/$/;"	f	file:
Pputenv	posix/lposix.c	/^static int Pputenv(lua_State *L)		\/** putenv(string) *\/$/;"	f	file:
Preadlink	posix/lposix.c	/^static int Preadlink(lua_State *L)		\/** readlink(path) *\/$/;"	f	file:
Prmdir	posix/lposix.c	/^static int Prmdir(lua_State *L)			\/** rmdir(path) *\/$/;"	f	file:
Psetenv	posix/lposix.c	/^static int Psetenv(lua_State *L)		\/** setenv(name,value,[over]) *\/$/;"	f	file:
Psetgid	posix/lposix.c	/^static int Psetgid(lua_State *L)		\/** setgid(name or id) *\/$/;"	f	file:
Psetuid	posix/lposix.c	/^static int Psetuid(lua_State *L)		\/** setuid(name or id) *\/$/;"	f	file:
Psleep	posix/lposix.c	/^static int Psleep(lua_State *L)			\/** sleep(seconds) *\/$/;"	f	file:
Pstat	posix/lposix.c	/^static int Pstat(lua_State *L)			\/** stat(path,[selector]) *\/$/;"	f	file:
Psymlink	posix/lposix.c	/^static int Psymlink(lua_State *L)		\/** symlink(oldpath,newpath) *\/$/;"	f	file:
Psysconf	posix/lposix.c	/^static int Psysconf(lua_State *L)		\/** sysconf([selector]) *\/$/;"	f	file:
Ptimes	posix/lposix.c	/^static int Ptimes(lua_State *L)			\/** times() *\/$/;"	f	file:
PtoNode	netlib.hpp	/^	PtoNode(const char* ptr, size_t len, unsigned char z, unsigned short p):data(ptr, len), zip(z), proid(p){}$/;"	f	struct:PtoNode
PtoNode	netlib.hpp	/^struct PtoNode{$/;"	s
Pttyname	posix/lposix.c	/^static int Pttyname(lua_State *L)		\/** ttyname(fd) *\/$/;"	f	file:
Pumask	posix/lposix.c	/^static int Pumask(lua_State *L)			\/** umask([mode]) *\/$/;"	f	file:
Puname	posix/lposix.c	/^static int Puname(lua_State *L)			\/** uname([string]) *\/$/;"	f	file:
Punlink	posix/lposix.c	/^static int Punlink(lua_State *L)		\/** unlink(path) *\/$/;"	f	file:
Punsetenv	posix/lposix.c	/^static int Punsetenv(lua_State *L)		\/** unsetenv(name) *\/$/;"	f	file:
Push	luacall.cpp	/^int TArgPool::Push(lua_State* L)const$/;"	f	class:TArgPool
Putime	posix/lposix.c	/^static int Putime(lua_State *L)			\/** utime(path,[mtime,atime]) *\/$/;"	f	file:
Pwait	posix/lposix.c	/^static int Pwait(lua_State *L)			\/** wait([pid]) *\/$/;"	f	file:
QueryGrid	scene.cpp	/^CGrid * CScene::QueryGrid(int grid_index)$/;"	f	class:CScene
R	posix/lposix.c	/^static const luaL_reg R[] =$/;"	v	file:
RANLIB	luamongodb/Makefile	/^RANLIB= ranlib$/;"	m
RESOLV	netlib.cpp	10;"	d	file:
RM	luamongodb/Makefile	/^RM= rm -f$/;"	m
ReadBuffer	netlib.hpp	/^		char *ReadBuffer;$/;"	m	class:TClientSocket
RemoveBeSeen	scene.cpp	/^inline void CGrid::RemoveBeSeen(const char * char_id)$/;"	f	class:CGrid
RemoveBeSeen	scene.cpp	/^void CScene::RemoveBeSeen(const char * char_id, const std::vector<CGrid *> *p_leave_grid)$/;"	f	class:CScene
RemovePlayer	scene.cpp	/^bool CScene::RemovePlayer(const char * char_id, const struct Point *p_point, int lua_aoi, void *p_context)$/;"	f	class:CScene
RemovePlayer	scene.cpp	/^inline void CGrid::RemovePlayer(const char * char_id)$/;"	f	class:CGrid
RemovePlayer	scene.cpp	/^void RemovePlayer(int id, const char * char_id, int pos_x, int pos_y, int lua_aoi, void *p_context)$/;"	f
RemoveScene	scene.cpp	/^void RemoveScene(int id)$/;"	f
RightAOIProc	scene.cpp	/^static void RightAOIProc(const char * char_id, const std::vector<const char *> *p_other, lua_State *L)$/;"	f	file:
SERVER	netlib.hpp	13;"	d
SHASH	hash.hpp	26;"	d
SHASH_MAXLEN	hash.hpp	25;"	d
SRC	Makefile	/^SRC=callout.cpp hash.cpp lmemory.cpp luacall.cpp main.cpp netlib.cpp api.cpp cjson.cpp lstack.cpp base64.cpp scene.cpp lscene.cpp msgpackLua.cpp$/;"	m
STATIC	posix/Makefile	/^STATIC=$(MYLIB).a$/;"	m
Selector	posix/lposix.c	/^typedef int (*Selector)(lua_State *L, int i, const void *data);$/;"	t	file:
SetGateWayDataThrowed	netlib.cpp	/^void TClientSocket::SetGateWayDataThrowed()$/;"	f	class:TClientSocket
SgetID	posix/lposix.c	/^static const char *const SgetID[] =$/;"	v	file:
Sgetpasswd	posix/lposix.c	/^static const char *const Sgetpasswd[] =$/;"	v	file:
Size	luacall.hpp	/^		size_t Size() const { return ArgList.size();}$/;"	f	class:TArgPool
SizeMap	lmemory.cpp	/^char * SizeMap;$/;"	v
Spathconf	posix/lposix.c	/^static const char *const Spathconf[] =$/;"	v	file:
Sstat	posix/lposix.c	/^static const char *const Sstat[] =$/;"	v	file:
Ssysconf	posix/lposix.c	/^static const char *const Ssysconf[] =$/;"	v	file:
Stimes	posix/lposix.c	/^static const char *const Stimes[] =$/;"	v	file:
T	hash.cpp	/^static int T[] =$/;"	v	file:
T	posix/Makefile	/^T= $(MYLIB).so$/;"	m
TArg	luacall.hpp	/^		TArg(){}$/;"	f	class:TArg
TArg	luacall.hpp	/^class TArg$/;"	c
TArgBool	luacall.cpp	/^		explicit TArgBool(bool v):_boolv(v){}$/;"	f	class:TArgBool
TArgBool	luacall.cpp	/^class TArgBool:public TArg$/;"	c	file:
TArgNil	luacall.cpp	/^		explicit TArgNil(){}$/;"	f	class:TArgNil
TArgNil	luacall.cpp	/^class TArgNil:public TArg$/;"	c	file:
TArgNumber	luacall.cpp	/^		explicit TArgNumber(double v):_number(v){}$/;"	f	class:TArgNumber
TArgNumber	luacall.cpp	/^class TArgNumber:public TArg$/;"	c	file:
TArgPool	luacall.hpp	/^		TArgPool(){}$/;"	f	class:TArgPool
TArgPool	luacall.hpp	/^class TArgPool$/;"	c
TArgStr	luacall.cpp	/^		explicit TArgStr(const std::string& v):_strv(v){}$/;"	f	class:TArgStr
TArgStr	luacall.cpp	/^class TArgStr:public TArg$/;"	c	file:
TClientSocket	netlib.cpp	/^TClientSocket::TClientSocket(int _socket_fd, int type, int _read_ref, int _write_ref, int _error_ref):TSocket(_socket_fd),type(type)$/;"	f	class:TClientSocket
TClientSocket	netlib.hpp	/^class TClientSocket:public TSocket$/;"	c
TNUMBER	hash.hpp	8;"	d
TOTAR	posix/Makefile	/^TOTAR= Makefile,README,$(MYLIB).c,$(MYNAME).lua,test.lua,modemuncher.c,tree.lua$/;"	m
TSTRING	hash.hpp	9;"	d
TServerSocket	netlib.cpp	/^TServerSocket::TServerSocket(int _socket_fd, int _read_ref):TSocket(_socket_fd)$/;"	f	class:TServerSocket
TServerSocket	netlib.hpp	/^class TServerSocket:public TSocket$/;"	c
TSocket	netlib.hpp	/^		TSocket(int _socket_fd):socket_fd(_socket_fd){}$/;"	f	class:TSocket
TSocket	netlib.hpp	/^class TSocket$/;"	c
UNAME	Makefile	/^UNAME = $(shell uname)$/;"	m
UNAME	luamongodb/Makefile	/^UNAME = $(shell uname)$/;"	m
USER_DEFINED_ERR_CODE	netlib.cpp	12;"	d	file:
WARN	posix/Makefile	/^WARN= -pedantic -Wall$/;"	m
_ERROR	global.hpp	25;"	d
_LBACKTRACE_H	lstack.hpp	3;"	d
_RUNTIME_ERROR	global.hpp	24;"	d
_WARN	global.hpp	23;"	d
__CALLOUT_H_	callout.hpp	3;"	d
__HASH_H_	hash.hpp	6;"	d
__LMEMORY_H__	lmemory.hpp	6;"	d
__LUA_CALL_HPP__	luacall.hpp	2;"	d
__LUA_SOCKET_HPP__	netlib.hpp	10;"	d
__MSGPACK_LUA_HPP__	msgpackLua.hpp	5;"	d
_base64_char_value	base64.cpp	/^int _base64_char_value(char base64char)$/;"	f
_base64_decode	api.cpp	/^static int _base64_decode(lua_State* L)$/;"	f	file:
_base64_decode_triple	base64.cpp	/^int _base64_decode_triple(unsigned char quadruple[4], unsigned char *result)$/;"	f
_base64_encode	api.cpp	/^static int _base64_encode(lua_State* L)$/;"	f	file:
_base64_encode_triple	base64.cpp	/^void _base64_encode_triple(const unsigned char triple[3], char result[4])$/;"	f
_boolv	luacall.cpp	/^	bool _boolv;$/;"	m	class:TArgBool	file:
_call	api.cpp	/^static int _call(lua_State * L, call_func func, callcb cb)$/;"	f	file:
_call_multi	api.cpp	/^static int _call_multi(lua_State * L)$/;"	f	file:
_call_once	api.cpp	/^static int _call_once(lua_State * L)$/;"	f	file:
_delete_node	hash.cpp	/^bool _delete_node(hash_table * h,  int key, size_t klen, unsigned char type)$/;"	f
_evdata	callout.hpp	/^typedef struct _evdata$/;"	s
_find_node	hash.cpp	/^bool _find_node(hash_table * h, int key, size_t klen, unsigned char type, void * *val)$/;"	f
_get_n	lmemory.cpp	/^int _get_n(size_t size)$/;"	f
_getrusage	api.cpp	/^static int _getrusage(lua_State* L)$/;"	f	file:
_hamc_sha1	api.cpp	/^static int _hamc_sha1(lua_State *L)$/;"	f	file:
_init_n_map	lmemory.cpp	/^void _init_n_map()$/;"	f
_insert_node	hash.cpp	/^bool _insert_node(hash_table * h,  int key, size_t klen, unsigned char type, void * val, bool update)$/;"	f
_json_decode	api.cpp	/^static int _json_decode(lua_State* L)$/;"	f	file:
_lengine_exit	api.cpp	/^static int _lengine_exit(lua_State* L)$/;"	f	file:
_md5_sum	api.cpp	/^static int _md5_sum(lua_State* L)$/;"	f	file:
_multicb	callout.cpp	/^static void _multicb(int fd, short event, void * arg)$/;"	f	file:
_number	luacall.cpp	/^	double _number;$/;"	m	class:TArgNumber	file:
_oncecb	callout.cpp	/^static void _oncecb(int fd, short event, void * arg)$/;"	f	file:
_rm_call	api.cpp	/^static int _rm_call(lua_State * L)$/;"	f	file:
_rsa_sign	api.cpp	/^static int _rsa_sign(lua_State *L)$/;"	f	file:
_rsa_verify	api.cpp	/^static int _rsa_verify(lua_State *L)$/;"	f	file:
_strv	luacall.cpp	/^	std::string _strv;$/;"	m	class:TArgStr	file:
_utf8_encode	api.cpp	/^static int _utf8_encode(lua_State* L)$/;"	f	file:
_zlib_compress	api.cpp	/^static int _zlib_compress(lua_State *L)$/;"	f	file:
_zlib_uncompress	api.cpp	/^static int _zlib_uncompress(lua_State *L)$/;"	f	file:
accept_socket	netlib.cpp	/^static int accept_socket(lua_State* L)$/;"	f	file:
acceptcb	netlib.cpp	/^void TServerSocket::acceptcb()$/;"	f	class:TServerSocket
add_object	lscene.cpp	/^static int add_object(lua_State *L)$/;"	f	file:
arg	callout.hpp	/^	void * arg;$/;"	m	struct:_evdata
aux_files	posix/lposix.c	/^static int aux_files(lua_State *L)$/;"	f	file:
badoption	posix/lposix.c	/^static void badoption(lua_State *L, int i, const char *what, int option)$/;"	f	file:
base64_decode	base64.cpp	/^int base64_decode(const char *source, unsigned char *target, size_t targetlen)$/;"	f
base64_encode	base64.cpp	/^int base64_encode(const unsigned char *source, size_t sourcelen, char *target, size_t targetlen)$/;"	f
be_seen_set	scene.hpp	/^		std::set<const char *> be_seen_set; \/\/ 能看到该网格的玩家set$/;"	m	class:CGrid
bev	netlib.hpp	/^		struct bufferevent* bev;$/;"	m	class:TClientSocket	typeref:struct:TClientSocket::bufferevent
big_msize	lmemory.hpp	/^	size_t big_msize;$/;"	m	struct:buckets
bind_socket	netlib.cpp	/^static int bind_socket(lua_State* L)$/;"	f	file:
bits	posix/modemuncher.c	/^	mode_t bits;$/;"	m	struct:modeLookup	file:
bottom_index	scene.hpp	/^	int bottom_index;$/;"	m	struct:GridRect
bson_fromjson	luamongodb/mongo_bsontypes.cpp	/^static int bson_fromjson(lua_State *L) {$/;"	f	file:
bson_name	luamongodb/utils.cpp	/^const char *bson_name(int type) {$/;"	f
bson_to_array	luamongodb/utils.cpp	/^static void bson_to_array(lua_State *L, const BSONObj &obj) {$/;"	f	file:
bson_to_lua	luamongodb/utils.cpp	/^void bson_to_lua(lua_State *L, const BSONObj &obj) {$/;"	f
bson_to_table	luamongodb/utils.cpp	/^static void bson_to_table(lua_State *L, const BSONObj &obj) {$/;"	f	file:
bson_tojson	luamongodb/mongo_bsontypes.cpp	/^static int bson_tojson(lua_State *L) {$/;"	f	file:
bson_tonumber	luamongodb/mongo_bsontypes.cpp	/^static int bson_tonumber(lua_State *L) {$/;"	f	file:
bson_type_Date	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_Date(lua_State *L) {$/;"	f	file:
bson_type_NULL	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_NULL(lua_State *L) {$/;"	f	file:
bson_type_NumberInt	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_NumberInt(lua_State *L) {$/;"	f	file:
bson_type_NumberLong	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_NumberLong(lua_State *L) {$/;"	f	file:
bson_type_ObjectID	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_ObjectID(lua_State *L) {$/;"	f	file:
bson_type_RegEx	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_RegEx(lua_State *L) {$/;"	f	file:
bson_type_Symbol	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_Symbol(lua_State *L) {$/;"	f	file:
bson_type_Timestamp	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_Timestamp(lua_State*L) {$/;"	f	file:
bson_type_name	luamongodb/mongo_bsontypes.cpp	/^static int bson_type_name(lua_State *L) {$/;"	f	file:
buckets	lmemory.hpp	/^typedef struct buckets$/;"	s
buckets_t	lmemory.hpp	/^} buckets_t;$/;"	t	typeref:struct:buckets
buffer	msgpackLua.hpp	/^		msgpack_sbuffer* buffer;$/;"	m	class:msgpackLua_pack
cJSON	cjson.hpp	/^typedef struct cJSON {$/;"	s
cJSON	cjson.hpp	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddFalseToObject	cjson.hpp	115;"	d
cJSON_AddItemReferenceToArray	cjson.cpp	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f
cJSON_AddItemReferenceToObject	cjson.cpp	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f
cJSON_AddItemToArray	cjson.cpp	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f
cJSON_AddItemToObject	cjson.cpp	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddNullToObject	cjson.hpp	113;"	d
cJSON_AddNumberToObject	cjson.hpp	116;"	d
cJSON_AddStringToObject	cjson.hpp	117;"	d
cJSON_AddTrueToObject	cjson.hpp	114;"	d
cJSON_Array	cjson.hpp	37;"	d
cJSON_CreateArray	cjson.cpp	/^cJSON *cJSON_CreateArray()						{cJSON *item=cJSON_New_Item();item->type=cJSON_Array;return item;}$/;"	f
cJSON_CreateDoubleArray	cjson.cpp	/^cJSON *cJSON_CreateDoubleArray(double *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateFalse	cjson.cpp	/^cJSON *cJSON_CreateFalse()						{cJSON *item=cJSON_New_Item();item->type=cJSON_False;return item;}$/;"	f
cJSON_CreateFloatArray	cjson.cpp	/^cJSON *cJSON_CreateFloatArray(float *numbers,int count)			{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateIntArray	cjson.cpp	/^cJSON *cJSON_CreateIntArray(int *numbers,int count)				{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateNull	cjson.cpp	/^cJSON *cJSON_CreateNull()						{cJSON *item=cJSON_New_Item();item->type=cJSON_NULL;return item;}$/;"	f
cJSON_CreateNumber	cjson.cpp	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;return item;}$/;"	f
cJSON_CreateObject	cjson.cpp	/^cJSON *cJSON_CreateObject()						{cJSON *item=cJSON_New_Item();item->type=cJSON_Object;return item;}$/;"	f
cJSON_CreateString	cjson.cpp	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();item->type=cJSON_String;item->valuestring=cJSON_strdup(string);return item;}$/;"	f
cJSON_CreateStringArray	cjson.cpp	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateTrue	cjson.cpp	/^cJSON *cJSON_CreateTrue()						{cJSON *item=cJSON_New_Item();item->type=cJSON_True;return item;}$/;"	f
cJSON_Delete	cjson.cpp	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	cjson.cpp	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f
cJSON_DeleteItemFromObject	cjson.cpp	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f
cJSON_DetachItemFromArray	cjson.cpp	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f
cJSON_DetachItemFromObject	cjson.cpp	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f
cJSON_False	cjson.hpp	32;"	d
cJSON_GetArrayItem	cjson.cpp	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f
cJSON_GetArraySize	cjson.cpp	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f
cJSON_GetObjectItem	cjson.cpp	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f
cJSON_Hooks	cjson.hpp	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	cjson.hpp	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_InitHooks	cjson.cpp	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_IsReference	cjson.hpp	40;"	d
cJSON_NULL	cjson.hpp	34;"	d
cJSON_New_Item	cjson.cpp	/^static cJSON *cJSON_New_Item()$/;"	f	file:
cJSON_Number	cjson.hpp	35;"	d
cJSON_Object	cjson.hpp	38;"	d
cJSON_Parse	cjson.cpp	/^cJSON *cJSON_Parse(const char *value)$/;"	f
cJSON_Print	cjson.cpp	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}$/;"	f
cJSON_PrintUnformatted	cjson.cpp	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}$/;"	f
cJSON_ReplaceItemInArray	cjson.cpp	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f
cJSON_ReplaceItemInObject	cjson.cpp	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f
cJSON_String	cjson.hpp	36;"	d
cJSON_True	cjson.hpp	33;"	d
cJSON__h	cjson.hpp	24;"	d
cJSON_free	cjson.cpp	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cjson.cpp	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cjson.cpp	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:
cJSON_strdup	cjson.cpp	/^static char* cJSON_strdup(const char* str)$/;"	f	file:
call_func	api.cpp	/^typedef unsigned int (*call_func)(callcb cb, void * arg, float timeout);$/;"	t	file:
call_hash	callout.cpp	/^hash_table * call_hash; $/;"	v
call_multi	callout.cpp	/^unsigned int call_multi(callcb cb, void * arg, float timeout)$/;"	f
call_once	callout.cpp	/^unsigned int call_once(callcb cb, void * arg, float timeout)$/;"	f
callcb	callout.hpp	/^typedef void (*callcb)(void *);$/;"	t
callscript	lstack.cpp	/^int callscript(lua_State *L, int narg, int nresults)$/;"	f
cb	callout.hpp	/^	callcb cb;$/;"	m	struct:_evdata
cb	netlib.cpp	/^	int cb;$/;"	m	struct:http_data	file:
check_array	luamongodb/utils.cpp	/^static int check_array(lua_State *L, int stackpos) {$/;"	f	file:
checksocketfd	netlib.cpp	/^int checksocketfd(lua_State* L, int narg)$/;"	f
child	cjson.hpp	/^	struct cJSON *child;		\/\/ An array or object item will have a child pointer pointing to a chain of the items in the array\/object.$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
close_socket	netlib.cpp	/^static int close_socket(lua_State* L)$/;"	f	file:
conn	netlib.cpp	/^	struct evhttp_connection * conn;$/;"	m	struct:http_data	typeref:struct:http_data::evhttp_connection	file:
connect_socket	netlib.cpp	/^static int connect_socket(lua_State* L)$/;"	f	file:
connection_auth	luamongodb/mongo_connection.cpp	/^static int connection_auth(lua_State *L) {$/;"	f	file:
connection_connect	luamongodb/mongo_connection.cpp	/^static int connection_connect(lua_State *L) {$/;"	f	file:
connection_count	luamongodb/mongo_connection.cpp	/^static int connection_count(lua_State *L) {$/;"	f	file:
connection_drop_collection	luamongodb/mongo_connection.cpp	/^static int connection_drop_collection(lua_State *L) {$/;"	f	file:
connection_drop_index_by_fields	luamongodb/mongo_connection.cpp	/^static int connection_drop_index_by_fields(lua_State *L) {$/;"	f	file:
connection_drop_index_by_name	luamongodb/mongo_connection.cpp	/^static int connection_drop_index_by_name(lua_State *L) {$/;"	f	file:
connection_drop_indexes	luamongodb/mongo_connection.cpp	/^static int connection_drop_indexes(lua_State *L) {$/;"	f	file:
connection_ensure_index	luamongodb/mongo_connection.cpp	/^static int connection_ensure_index(lua_State *L) {$/;"	f	file:
connection_eval	luamongodb/mongo_connection.cpp	/^static int connection_eval(lua_State *L) {$/;"	f	file:
connection_exists	luamongodb/mongo_connection.cpp	/^static int connection_exists(lua_State *L) {$/;"	f	file:
connection_gc	luamongodb/mongo_connection.cpp	/^static int connection_gc(lua_State *L) {$/;"	f	file:
connection_gen_index_name	luamongodb/mongo_connection.cpp	/^static int connection_gen_index_name(lua_State *L) {$/;"	f	file:
connection_get_indexes	luamongodb/mongo_connection.cpp	/^static int connection_get_indexes(lua_State *L) {$/;"	f	file:
connection_get_server_address	luamongodb/mongo_connection.cpp	/^static int connection_get_server_address(lua_State *L) {$/;"	f	file:
connection_insert	luamongodb/mongo_connection.cpp	/^static int connection_insert(lua_State *L) {$/;"	f	file:
connection_insert_batch	luamongodb/mongo_connection.cpp	/^static int connection_insert_batch(lua_State *L) {$/;"	f	file:
connection_is_failed	luamongodb/mongo_connection.cpp	/^static int connection_is_failed(lua_State *L) {$/;"	f	file:
connection_mapreduce	luamongodb/mongo_connection.cpp	/^static int connection_mapreduce(lua_State *L) {$/;"	f	file:
connection_new	luamongodb/mongo_connection.cpp	/^static int connection_new(lua_State *L) {$/;"	f	file:
connection_query	luamongodb/mongo_connection.cpp	/^static int connection_query(lua_State *L) {$/;"	f	file:
connection_reindex	luamongodb/mongo_connection.cpp	/^static int connection_reindex(lua_State *L) {$/;"	f	file:
connection_remove	luamongodb/mongo_connection.cpp	/^static int connection_remove(lua_State *L) {$/;"	f	file:
connection_reset_index_cache	luamongodb/mongo_connection.cpp	/^static int connection_reset_index_cache(lua_State *L) {$/;"	f	file:
connection_tostring	luamongodb/mongo_connection.cpp	/^static int connection_tostring(lua_State *L) {$/;"	f	file:
connection_update	luamongodb/mongo_connection.cpp	/^static int connection_update(lua_State *L) {$/;"	f	file:
create_reference	cjson.cpp	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:
create_socket	netlib.cpp	/^static int create_socket(lua_State* L)$/;"	f	file:
curlen	netlib.hpp	/^		unsigned int curlen;$/;"	m	class:TClientSocket
cursor_create	luamongodb/mongo_cursor.cpp	/^int cursor_create(lua_State *L, DBClientConnection *connection, const char *ns,$/;"	f
cursor_gc	luamongodb/mongo_cursor.cpp	/^static int cursor_gc(lua_State *L) {$/;"	f	file:
cursor_get_id	luamongodb/mongo_cursor.cpp	/^static int cursor_get_id(lua_State *L) {$/;"	f	file:
cursor_has_more	luamongodb/mongo_cursor.cpp	/^static int cursor_has_more(lua_State *L) {$/;"	f	file:
cursor_has_result_flag	luamongodb/mongo_cursor.cpp	/^static int cursor_has_result_flag(lua_State *L) {$/;"	f	file:
cursor_is_dead	luamongodb/mongo_cursor.cpp	/^static int cursor_is_dead(lua_State *L) {$/;"	f	file:
cursor_is_tailable	luamongodb/mongo_cursor.cpp	/^static int cursor_is_tailable(lua_State *L) {$/;"	f	file:
cursor_itcount	luamongodb/mongo_cursor.cpp	/^static int cursor_itcount(lua_State *L) {$/;"	f	file:
cursor_next	luamongodb/mongo_cursor.cpp	/^static int cursor_next(lua_State *L) {$/;"	f	file:
cursor_results	luamongodb/mongo_cursor.cpp	/^static int cursor_results(lua_State *L) {$/;"	f	file:
cursor_tostring	luamongodb/mongo_cursor.cpp	/^static int cursor_tostring(lua_State *L) {$/;"	f	file:
data	netlib.hpp	/^	std::string data;$/;"	m	struct:PtoNode
date_tostring	luamongodb/mongo_bsontypes.cpp	/^static int date_tostring(lua_State *L) {$/;"	f	file:
delete_inode	hash.hpp	65;"	d
delete_scene	lscene.cpp	/^static int delete_scene(lua_State *L) \/\/ 为脚本层场景对象删除一个场景管理对象$/;"	f	file:
delete_snode	hash.hpp	71;"	d
divide_hash	hash.cpp	/^unsigned int divide_hash(unsigned int key, size_t size)$/;"	f
dns_callback	netlib.cpp	/^void dns_callback(int result, char type, int count, int ttl, void *addresses, void *arg)$/;"	f
do_directory	posix/tree.lua	/^local function do_directory(directory, level, prefix)$/;"	f
doselection	posix/lposix.c	/^static int doselection(lua_State *L, int i, const char *const S[], Selector F, const void *data)$/;"	f	file:
double_div	hash.cpp	/^unsigned int double_div(unsigned int key, size_t size, unsigned int i)$/;"	f
double_mult	hash.cpp	/^unsigned int double_mult(unsigned int key, size_t size, unsigned int i)$/;"	f
elapsed	posix/lposix.c	/^ clock_t elapsed;$/;"	m	struct:mytimes	file:
eq	hash.cpp	/^inline bool eq(hlink * node1, int key, size_t klen, unsigned char type)$/;"	f
eq_node	hash.cpp	/^inline bool eq_node(hlink * node1, hlink * node2)$/;"	f
error_ref	netlib.hpp	/^		int error_ref;$/;"	m	class:TClientSocket
ev	callout.hpp	/^	struct event ev;$/;"	m	struct:_evdata	typeref:struct:_evdata::event
ev_manager	callout.cpp	/^}ev_manager;$/;"	v	typeref:struct:ev_manager_t
ev_manager_t	callout.cpp	/^struct ev_manager_t{$/;"	s	file:
evdata	callout.hpp	/^}evdata;$/;"	t	typeref:struct:_evdata
evdata_header	callout.cpp	/^	evdata* evdata_header;$/;"	m	struct:ev_manager_t	file:
f	posix/test.lua	/^function f(d) myassert("chdir",ox.chdir(d)) g() end$/;"	f
f	posix/test.lua	/^function f(s) print("putenv",s,ox.putenv(s)) end$/;"	f
f	posix/test.lua	/^function f(v) print(v,ox.getenv(v)) end$/;"	f
f	posix/test.lua	/^function f(x) print(ox.getpasswd(x,"name"),ox.getpasswd(x,"gecos")) end$/;"	f
f	posix/test.lua	/^function f(x) print(ox.uname(x)) end$/;"	f
f	posix/test.lua	/^function f(x)$/;"	f
ff_bucket_count	lmemory.cpp	/^int ff_bucket_count( buckets_t* ud ) {$/;"	f
ff_buckets_t_init	lmemory.cpp	/^buckets_t* ff_buckets_t_init( buckets_t* ud )$/;"	f
ff_create_memory	lmemory.cpp	/^void ff_create_memory( buckets_t* ud, free_list_t* fl )$/;"	f
ff_free	lmemory.cpp	/^void ff_free( buckets_t* ud, void* ptr , size_t osize)$/;"	f
ff_malloc	lmemory.cpp	/^void* ff_malloc( buckets_t* ud, size_t nsize )$/;"	f
ff_realloc	lmemory.cpp	/^void* ff_realloc( void* bt, void* ptr, size_t osize, size_t nsize )$/;"	f
filetype	posix/lposix.c	/^static const char *filetype(mode_t m)$/;"	f	file:
find_double_prime	hash.cpp	/^unsigned int find_double_prime(unsigned int n)$/;"	f
find_inode	hash.hpp	66;"	d
find_snode	hash.hpp	72;"	d
firstByteMark	cjson.cpp	/^static const char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
first_	lmemory.hpp	/^	free_list_t *first_;$/;"	m	struct:buckets
fore	posix/tree.lua	/^local function fore(directory)$/;"	f
free_evdata	callout.cpp	/^	int free_evdata;$/;"	m	struct:ev_manager_t	file:
free_evdata	callout.cpp	/^static void free_evdata(evdata* ptr)$/;"	f	file:
free_fn	cjson.hpp	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
free_hash_table	hash.cpp	/^void free_hash_table(hash_table * h)$/;"	f
free_http	netlib.cpp	/^void free_http(struct http_data * hd)$/;"	f
free_list	lmemory.hpp	/^typedef struct free_list$/;"	s
free_list_t	lmemory.hpp	/^} free_list_t;$/;"	t	typeref:struct:free_list
free_node	hash.cpp	/^static inline void free_node(hash_table * h, hlink * node)$/;"	f	file:
free_size	hash.hpp	/^	size_t free_size;$/;"	m	struct:__anon1
freelist	hash.hpp	/^	hlink * freelist;\/\/空闲节点列表。$/;"	m	struct:__anon1
fsize_	lmemory.hpp	/^	size_t *fsize_;$/;"	m	struct:buckets
function g() local d	posix/test.lua	/^function g() local d=ox.getcwd() print("now at",d) return d end$/;"	f
g	posix/test.lua	/^function g(v) print("now",v,ox.getenv(v)) end$/;"	f
gateWayData	main.cpp	/^const char* gateWayData = NULL;$/;"	v
gateWayDataLen	main.cpp	/^size_t gateWayDataLen = 0;$/;"	v
gc	main.cpp	/^void gc( void* arg)$/;"	f
generic_tostring	luamongodb/mongo_bsontypes.cpp	/^static int generic_tostring(lua_State *L) {$/;"	f	file:
get_ex_neighbor	lscene.cpp	/^static int get_ex_neighbor(lua_State *L)$/;"	f	file:
get_free_ev	callout.cpp	/^int get_free_ev()$/;"	f
get_neighbor	lscene.cpp	/^static int get_neighbor(lua_State *L)$/;"	f	file:
get_total_ev	callout.cpp	/^int get_total_ev()$/;"	f
grid_column_count	scene.hpp	/^		int grid_column_count; \/\/ 每列有多少个网格$/;"	m	class:CScene
grid_height	scene.hpp	/^		int grid_height; \/\/ 网格高$/;"	m	class:CScene
grid_row_count	scene.hpp	/^		int grid_row_count; \/\/ 每行有多少个网格$/;"	m	class:CScene
grid_width	scene.hpp	/^		int grid_width; \/\/ 网格宽$/;"	m	class:CScene
gridfile_chunk	luamongodb/mongo_gridfile.cpp	/^static int gridfile_chunk(lua_State *L) {$/;"	f	file:
gridfile_chunk_size	luamongodb/mongo_gridfile.cpp	/^static int gridfile_chunk_size(lua_State *L) {$/;"	f	file:
gridfile_content_length	luamongodb/mongo_gridfile.cpp	/^static int gridfile_content_length(lua_State *L) {$/;"	f	file:
gridfile_create	luamongodb/mongo_gridfile.cpp	/^int gridfile_create(lua_State *L, GridFile gf) {$/;"	f
gridfile_data	luamongodb/mongo_gridfile.cpp	/^static int gridfile_data(lua_State *L) {$/;"	f	file:
gridfile_exists	luamongodb/mongo_gridfile.cpp	/^static int gridfile_exists(lua_State *L) {$/;"	f	file:
gridfile_field	luamongodb/mongo_gridfile.cpp	/^static int gridfile_field(lua_State *L) {$/;"	f	file:
gridfile_filename	luamongodb/mongo_gridfile.cpp	/^static int gridfile_filename(lua_State *L) {$/;"	f	file:
gridfile_gc	luamongodb/mongo_gridfile.cpp	/^static int gridfile_gc(lua_State *L) {$/;"	f	file:
gridfile_md5	luamongodb/mongo_gridfile.cpp	/^static int gridfile_md5(lua_State *L) {$/;"	f	file:
gridfile_metadata	luamongodb/mongo_gridfile.cpp	/^static int gridfile_metadata(lua_State *L) {$/;"	f	file:
gridfile_num_chunks	luamongodb/mongo_gridfile.cpp	/^static int gridfile_num_chunks(lua_State *L) {$/;"	f	file:
gridfile_tostring	luamongodb/mongo_gridfile.cpp	/^static int gridfile_tostring(lua_State *L) {$/;"	f	file:
gridfile_upload_date	luamongodb/mongo_gridfile.cpp	/^static int gridfile_upload_date(lua_State *L) {$/;"	f	file:
gridfile_write	luamongodb/mongo_gridfile.cpp	/^static int gridfile_write(lua_State *L) {$/;"	f	file:
gridfs_find_file	luamongodb/mongo_gridfs.cpp	/^static int gridfs_find_file(lua_State *L) {$/;"	f	file:
gridfs_gc	luamongodb/mongo_gridfs.cpp	/^static int gridfs_gc(lua_State *L) {$/;"	f	file:
gridfs_list	luamongodb/mongo_gridfs.cpp	/^static int gridfs_list(lua_State *L) {$/;"	f	file:
gridfs_new	luamongodb/mongo_gridfs.cpp	/^static int gridfs_new(lua_State *L) {$/;"	f	file:
gridfs_remove_file	luamongodb/mongo_gridfs.cpp	/^static int gridfs_remove_file(lua_State *L) {$/;"	f	file:
gridfs_store_data	luamongodb/mongo_gridfs.cpp	/^static int gridfs_store_data(lua_State *L) {$/;"	f	file:
gridfs_store_file	luamongodb/mongo_gridfs.cpp	/^static int gridfs_store_file(lua_State *L) {$/;"	f	file:
gridfs_tostring	luamongodb/mongo_gridfs.cpp	/^static int gridfs_tostring(lua_State *L) {$/;"	f	file:
gridfschunk_data	luamongodb/mongo_gridfschunk.cpp	/^static int gridfschunk_data(lua_State *L) {$/;"	f	file:
gridfschunk_gc	luamongodb/mongo_gridfschunk.cpp	/^static int gridfschunk_gc(lua_State *L) {$/;"	f	file:
gridfschunk_len	luamongodb/mongo_gridfschunk.cpp	/^static int gridfschunk_len(lua_State *L) {$/;"	f	file:
gridfschunk_tostring	luamongodb/mongo_gridfschunk.cpp	/^static int gridfschunk_tostring(lua_State *L) {$/;"	f	file:
handler	callout.cpp	/^unsigned int handler = 0;$/;"	v
handler	callout.hpp	/^	unsigned int handler;$/;"	m	struct:_evdata
hash_len	hash.hpp	60;"	d
hash_table	hash.hpp	/^}hash_table;$/;"	t	typeref:struct:__anon1
hashstr	hash.cpp	/^inline int hashstr(const char * s, int max)$/;"	f
hlink	hash.hpp	/^typedef struct hlink_ hlink;$/;"	t	typeref:struct:hlink_
hlink_	hash.hpp	/^struct hlink_$/;"	s
http_cb	netlib.cpp	/^void http_cb(struct evhttp_request * req, void *arg)$/;"	f
http_data	netlib.cpp	/^struct http_data $/;"	s	file:
http_get	netlib.cpp	/^static int http_get(lua_State * L)$/;"	f	file:
http_post	netlib.cpp	/^static int http_post(lua_State * L)$/;"	f	file:
http_request	netlib.cpp	/^static int http_request(lua_State * L, enum evhttp_cmd_type type)$/;"	f	file:
init_callout	callout.cpp	/^void init_callout()$/;"	f
init_dns	netlib.cpp	/^int init_dns()$/;"	f
init_hash_table	hash.cpp	/^hash_table * init_hash_table(int size)$/;"	f
init_http_svr	netlib.cpp	/^static int init_http_svr(lua_State *L)$/;"	f	file:
init_scene	lscene.cpp	/^int init_scene(lua_State *L)$/;"	f
insert_inode	hash.hpp	63;"	d
insert_snode	hash.hpp	69;"	d
integer_value	luamongodb/mongo_bsontypes.cpp	/^static int integer_value(lua_State *L) {$/;"	f	file:
is_prime	hash.cpp	/^static bool is_prime(unsigned int n)$/;"	f	file:
is_socketfd	netlib.cpp	/^bool is_socketfd(int socket_fd)$/;"	f
json2lua	api.cpp	/^void json2lua(lua_State* L, const cJSON* json)$/;"	f
key	hash.hpp	/^	int key;$/;"	m	struct:hlink_
klen	hash.hpp	/^	size_t klen;$/;"	m	struct:hlink_
left_index	scene.hpp	/^	int left_index;$/;"	m	struct:GridRect
len	hash.hpp	/^	size_t len; \/\/元素个数.$/;"	m	struct:__anon1
len	netlib.hpp	/^	unsigned int len;$/;"	m	struct:Head_t
lengine	api.cpp	/^static const luaL_reg lengine[] = {$/;"	v	file:
lhashstr	hash.cpp	/^inline int lhashstr(const char * str, int l)$/;"	f
listen_ev	netlib.hpp	/^		struct event* listen_ev;$/;"	m	class:TServerSocket	typeref:struct:TServerSocket::event
listen_socket	netlib.cpp	/^static int listen_socket(lua_State* L)$/;"	f	file:
longlong_tostring	luamongodb/mongo_bsontypes.cpp	/^static int longlong_tostring(lua_State *L) {$/;"	f	file:
lua_append_bson	luamongodb/utils.cpp	/^static void lua_append_bson(lua_State *L, const char *key, int stackpos, BSONObjBuilder *builder) {$/;"	f	file:
lua_push_value	luamongodb/utils.cpp	/^void lua_push_value(lua_State *L, const BSONElement &elem) {$/;"	f
lua_to_bson	luamongodb/utils.cpp	/^void lua_to_bson(lua_State *L, int stackpos, BSONObj &obj) {$/;"	f
luaopen_lengine	api.cpp	/^void luaopen_lengine(lua_State* L)$/;"	f
luaopen_lposix	posix/lposix.c	/^LUALIB_API int luaopen_lposix (lua_State *L)$/;"	f
luaopen_mongo	luamongodb/main.cpp	/^LM_EXPORT int luaopen_mongo(lua_State *L) {$/;"	f
luaopen_msgpack	msgpackLua.cpp	/^void luaopen_msgpack(lua_State* L)$/;"	f
luaopen_netlib	netlib.cpp	/^void luaopen_netlib(lua_State* L)$/;"	f
mLuaPacker	msgpackLua.cpp	/^msgpackLua_pack *mLuaPacker;$/;"	v
mLuaUnpacker	msgpackLua.cpp	/^msgpackLua_unpack *mLuaUnpacker;$/;"	v
main	main.cpp	/^int main(int argc, char * *argv)$/;"	f
malloc_fn	cjson.hpp	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
malloc_node	hash.cpp	/^static inline hlink * malloc_node(hash_table * h)$/;"	f	file:
max_grid_index	scene.hpp	/^		int max_grid_index; \/\/ 转换成一维index的最大值$/;"	m	class:CScene
max_len	netlib.hpp	/^		unsigned int max_len;$/;"	m	class:TClientSocket
md5_sum	api.cpp	/^unsigned int md5_sum(const char* input, int length, char* buffer, int buff_size)$/;"	f
mod	hash.cpp	10;"	d	file:
mode	posix/lposix.c	/^	char mode[10];$/;"	m	struct:mystat	file:
modeLookup	posix/modemuncher.c	/^struct modeLookup$/;"	s	file:
modeLookup	posix/modemuncher.c	/^typedef struct modeLookup modeLookup;$/;"	t	typeref:struct:modeLookup	file:
mode_munch	posix/modemuncher.c	/^static int mode_munch(mode_t *mode, const char* p)$/;"	f	file:
modechopper	posix/modemuncher.c	/^static void modechopper(mode_t mode, char *p)$/;"	f	file:
modesel	posix/modemuncher.c	/^static modeLookup modesel[] =$/;"	v	file:
mongo_bsontypes_register	luamongodb/mongo_bsontypes.cpp	/^int mongo_bsontypes_register(lua_State *L) {$/;"	f
mongo_connection_register	luamongodb/mongo_connection.cpp	/^int mongo_connection_register(lua_State *L) {$/;"	f
mongo_cursor_register	luamongodb/mongo_cursor.cpp	/^int mongo_cursor_register(lua_State *L) {$/;"	f
mongo_gridfile_register	luamongodb/mongo_gridfile.cpp	/^int mongo_gridfile_register(lua_State *L) {$/;"	f
mongo_gridfs_register	luamongodb/mongo_gridfs.cpp	/^int mongo_gridfs_register(lua_State *L) {$/;"	f
mongo_gridfschunk_register	luamongodb/mongo_gridfschunk.cpp	/^int mongo_gridfschunk_register(lua_State *L) {$/;"	f
mongo_query_register	luamongodb/mongo_query.cpp	/^int mongo_query_register(lua_State *L) {$/;"	f
move	lscene.cpp	/^static int move(lua_State *L)$/;"	f	file:
msgpackLua_pack	msgpackLua.cpp	/^msgpackLua_pack::msgpackLua_pack()$/;"	f	class:msgpackLua_pack
msgpackLua_pack	msgpackLua.hpp	/^class msgpackLua_pack$/;"	c
msgpackLua_unpack	msgpackLua.cpp	/^msgpackLua_unpack::msgpackLua_unpack()$/;"	f	class:msgpackLua_unpack
msgpackLua_unpack	msgpackLua.hpp	/^class msgpackLua_unpack$/;"	c
mult_hash	hash.cpp	/^unsigned int mult_hash(unsigned int key, size_t size)$/;"	f
multi_cb	api.cpp	/^static void multi_cb(void * arg)$/;"	f	file:
myassert	posix/test.lua	/^function myassert(w,c,s)$/;"	f
mygetgid	posix/lposix.c	/^static gid_t mygetgid(lua_State *L, int i)$/;"	f	file:
mygetuid	posix/lposix.c	/^static uid_t mygetuid(lua_State *L, int i)$/;"	f	file:
myprint	posix/test.lua	/^function myprint(s,...)$/;"	f
mystat	posix/lposix.c	/^struct mystat$/;"	s	file:
mytimes	posix/lposix.c	/^struct mytimes$/;"	s	file:
nblocks_	lmemory.hpp	/^	int nblocks_;$/;"	m	struct:buckets
netlib	netlib.cpp	/^static const luaL_reg netlib[] = {$/;"	v	file:
new_evdata	callout.cpp	/^static evdata* new_evdata()$/;"	f	file:
new_hash	hash.cpp	/^unsigned int new_hash(unsigned int key, size_t size, unsigned int i)$/;"	f
new_scene	lscene.cpp	/^static int new_scene(lua_State *L) \/\/ 为脚本层场景对象创建一个场景管理对象$/;"	f	file:
next	callout.hpp	/^	struct _evdata* next;$/;"	m	struct:_evdata	typeref:struct:_evdata::_evdata
next	cjson.hpp	/^	struct cJSON *next,*prev;	\/\/ next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
next	hash.hpp	/^	hlink * next;$/;"	m	struct:hlink_
next_	lmemory.hpp	/^	struct free_list* next_;$/;"	m	struct:free_list	typeref:struct:free_list::free_list
next_prime	hash.cpp	/^static unsigned int next_prime(unsigned int n)$/;"	f	file:
node_size	hash.hpp	/^	size_t node_size;\/\/所有分配出来的节点数目。$/;"	m	struct:__anon1
nodes	hash.hpp	/^	hlink * nodes[0];\/\/zero array.必须在结构体末尾$/;"	m	struct:__anon1
null_tostring	luamongodb/mongo_bsontypes.cpp	/^static int null_tostring(lua_State *L) {$/;"	f	file:
null_value	luamongodb/mongo_bsontypes.cpp	/^static int null_value(lua_State *L) {$/;"	f	file:
number_value	luamongodb/mongo_bsontypes.cpp	/^static int number_value(lua_State *L) {$/;"	f	file:
on_error	netlib.cpp	/^int TClientSocket::on_error(short flag)$/;"	f	class:TClientSocket
once_cb	api.cpp	/^static void once_cb(void * arg)$/;"	f	file:
pSceneTbl	scene.cpp	/^hash_table *pSceneTbl = NULL;$/;"	v
p_grid_set	scene.hpp	/^		void **p_grid_set;$/;"	m	class:CScene
pack	msgpackLua.cpp	/^void msgpackLua_pack::pack(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packBoolean	msgpackLua.cpp	/^void msgpackLua_pack::packBoolean(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packLua	msgpackLua.cpp	/^int msgpackLua_pack::packLua(lua_State *L)$/;"	f	class:msgpackLua_pack
packLua	msgpackLua.cpp	/^int packLua(lua_State* L)$/;"	f
packNil	msgpackLua.cpp	/^void msgpackLua_pack::packNil(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packNumber	msgpackLua.cpp	/^void msgpackLua_pack::packNumber(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packString	msgpackLua.cpp	/^void msgpackLua_pack::packString(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packTable	msgpackLua.cpp	/^void msgpackLua_pack::packTable(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packTableAsArray	msgpackLua.cpp	/^void msgpackLua_pack::packTableAsArray(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packTableAsTable	msgpackLua.cpp	/^void msgpackLua_pack::packTableAsTable(lua_State *L, int index)$/;"	f	class:msgpackLua_pack
packer	msgpackLua.hpp	/^		msgpack_packer* packer;$/;"	m	class:msgpackLua_pack
parse_array	cjson.cpp	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:
parse_number	cjson.cpp	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:
parse_object	cjson.cpp	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:
parse_string	cjson.cpp	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:
parse_value	cjson.cpp	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:
player_set	scene.hpp	/^		std::set<const char *> player_set; \/\/ 位于该网格的玩家set$/;"	m	class:CGrid
prev	cjson.hpp	/^	struct cJSON *next,*prev;	\/\/ next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem$/;"	m	struct:cJSON	typeref:struct:cJSON::
print_array	cjson.cpp	/^static char *print_array(cJSON *item,int depth,int fmt)$/;"	f	file:
print_number	cjson.cpp	/^static char *print_number(cJSON *item)$/;"	f	file:
print_object	cjson.cpp	/^static char *print_object(cJSON *item,int depth,int fmt)$/;"	f	file:
print_string	cjson.cpp	/^static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}$/;"	f	file:
print_string_ptr	cjson.cpp	/^static char *print_string_ptr(const char *str)$/;"	f	file:
print_value	cjson.cpp	/^static char *print_value(cJSON *item,int depth,int fmt)$/;"	f	file:
printf	posix/tree.lua	/^local function printf(...)$/;"	f
pro	netlib.hpp	/^	unsigned short pro;$/;"	m	struct:Head_t
proid	netlib.hpp	/^	unsigned short proid;$/;"	m	struct:PtoNode
push_bsontype_table	luamongodb/mongo_bsontypes.cpp	/^void push_bsontype_table(lua_State* L, mongo::BSONType bsontype) {$/;"	f
pusherror	posix/lposix.c	/^static int pusherror(lua_State *L, const char *info)$/;"	f	file:
pushresult	posix/lposix.c	/^static int pushresult(lua_State *L, int i, const char *info)$/;"	f	file:
pushtime	posix/lposix.c	605;"	d	file:
pushvalue	luacall.cpp	/^		virtual void pushvalue(lua_State* L) const {lua_pushboolean(L, _boolv);}$/;"	f	class:TArgBool
pushvalue	luacall.cpp	/^		virtual void pushvalue(lua_State* L) const {lua_pushlstring(L, _strv.c_str(), _strv.length());}$/;"	f	class:TArgStr
pushvalue	luacall.cpp	/^		virtual void pushvalue(lua_State* L) const {lua_pushnil(L);}$/;"	f	class:TArgNil
pushvalue	luacall.cpp	/^		virtual void pushvalue(lua_State* L) const {lua_pushnumber(L, _number);}$/;"	f	class:TArgNumber
query_explain	luamongodb/mongo_query.cpp	/^static int query_explain(lua_State *L) {$/;"	f	file:
query_gc	luamongodb/mongo_query.cpp	/^static int query_gc(lua_State *L) {$/;"	f	file:
query_hint	luamongodb/mongo_query.cpp	/^static int query_hint(lua_State *L) {$/;"	f	file:
query_is_explain	luamongodb/mongo_query.cpp	/^static int query_is_explain(lua_State *L) {$/;"	f	file:
query_max_key	luamongodb/mongo_query.cpp	/^static int query_max_key(lua_State *L) {$/;"	f	file:
query_min_key	luamongodb/mongo_query.cpp	/^static int query_min_key(lua_State *L) {$/;"	f	file:
query_new	luamongodb/mongo_query.cpp	/^static int query_new(lua_State *L) {$/;"	f	file:
query_snapshot	luamongodb/mongo_query.cpp	/^static int query_snapshot(lua_State *L) {$/;"	f	file:
query_sort	luamongodb/mongo_query.cpp	/^static int query_sort(lua_State *L) {$/;"	f	file:
query_tostring	luamongodb/mongo_query.cpp	/^static int query_tostring(lua_State *L) {$/;"	f	file:
query_where	luamongodb/mongo_query.cpp	/^static int query_where(lua_State *L) {$/;"	f	file:
raisemod	hash.cpp	/^static unsigned int raisemod(unsigned int a, unsigned int m, unsigned int n)$/;"	f	file:
read_ref	netlib.hpp	/^		int read_ref;$/;"	m	class:TClientSocket
read_ref	netlib.hpp	/^		int read_ref;$/;"	m	class:TServerSocket
readcb	netlib.cpp	/^int TClientSocket::readcb(std::vector<PtoNode>& PtoList)$/;"	f	class:TClientSocket
regex_tostring	luamongodb/mongo_bsontypes.cpp	/^static int regex_tostring(lua_State *L) {$/;"	f	file:
remove_object	lscene.cpp	/^static int remove_object(lua_State *L)$/;"	f	file:
req	netlib.cpp	/^	struct evhttp_request * req;$/;"	m	struct:http_data	typeref:struct:http_data::evhttp_request	file:
resolve	netlib.cpp	/^static int resolve(lua_State * L)$/;"	f	file:
result_iterator	luamongodb/mongo_cursor.cpp	/^static int result_iterator(lua_State *L) {$/;"	f	file:
right_index	scene.hpp	/^	int right_index;$/;"	m	struct:GridRect
rm_call	callout.cpp	/^bool rm_call(unsigned int handler, void ** arg)$/;"	f
rwx	posix/modemuncher.c	/^	char rwx;$/;"	m	struct:modeLookup	file:
rwxrwxrwx	posix/modemuncher.c	/^static int rwxrwxrwx(mode_t *mode, const char *p)$/;"	f	file:
s	posix/lposix.c	/^	struct stat s;$/;"	m	struct:mystat	typeref:struct:mystat::stat	file:
scene_id	scene.hpp	/^		int scene_id;$/;"	m	class:CScene
scenelib	lscene.cpp	/^static const struct luaL_Reg scenelib[] = {$/;"	v	typeref:struct:luaL_Reg	file:
screen_height	scene.hpp	/^		int screen_height; \/\/ 场景高$/;"	m	class:CScene
screen_width	scene.hpp	/^		int screen_width; \/\/ 场景宽$/;"	m	class:CScene
signal_exit	main.cpp	/^void signal_exit(int sig, short type, void *arg)$/;"	f
signal_pipe	main.cpp	/^void signal_pipe(int sig, short type, void *arg)$/;"	f
skip	cjson.cpp	/^static const char *skip(const char *in) {while (in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:
slot_size	hash.hpp	/^	size_t slot_size; \/\/nodes数组的大小;$/;"	m	struct:__anon1
socket_accept_hook	netlib.cpp	/^static void socket_accept_hook(int socket_fd, short event, void* arg)$/;"	f	file:
socket_error_hook	netlib.cpp	/^static void socket_error_hook(struct bufferevent *bufev, short flag, void *arg)$/;"	f	file:
socket_fd	netlib.hpp	/^		int socket_fd;$/;"	m	class:TSocket
socket_read_hook	netlib.cpp	/^static void socket_read_hook(struct bufferevent *bufev, void *arg)$/;"	f	file:
socket_setnonblocking	netlib.cpp	/^void socket_setnonblocking(int socket_fd)$/;"	f
socket_write_hook	netlib.cpp	/^static void socket_write_hook(struct bufferevent *bufev, void *arg)$/;"	f	file:
storeindex	posix/lposix.c	/^static void storeindex(lua_State *L, int i, const char *value)$/;"	f	file:
storenumber	posix/lposix.c	/^static void storenumber(lua_State *L, const char *name, lua_Number value)$/;"	f	file:
storestring	posix/lposix.c	/^static void storestring(lua_State *L, const char *name, const char *value)$/;"	f	file:
storetime	posix/lposix.c	626;"	d	file:
string	cjson.hpp	/^	char *string;				\/\/ The item's name string, if this item is the child of, or is in the list of subitems of an object.$/;"	m	struct:cJSON
string_value	luamongodb/mongo_bsontypes.cpp	/^static int string_value(lua_State *L) {$/;"	f	file:
stringpair_value	luamongodb/mongo_bsontypes.cpp	/^static int stringpair_value(lua_State *L) {$/;"	f	file:
suffix_object	cjson.cpp	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:
t	posix/lposix.c	/^ struct tms t;$/;"	m	struct:mytimes	typeref:struct:mytimes::tms	file:
testing	posix/test.lua	/^function testing(s)$/;"	f
throwGW	netlib.hpp	/^		int throwGW;$/;"	m	class:TClientSocket
top_index	scene.hpp	/^	int top_index;$/;"	m	struct:GridRect
total_evdata	callout.cpp	/^	int total_evdata;$/;"	m	struct:ev_manager_t	file:
traceback	lstack.cpp	/^static int traceback (lua_State *L)$/;"	f	file:
tv	callout.hpp	/^	struct timeval tv;$/;"	m	struct:_evdata	typeref:struct:_evdata::timeval
type	cjson.hpp	/^	int type;					\/\/ The type of the item, as above.$/;"	m	struct:cJSON
type	hash.hpp	/^	unsigned char type;$/;"	m	struct:hlink_
type	netlib.hpp	/^		int type;$/;"	m	class:TClientSocket
type	posix/lposix.c	/^	const char *type;$/;"	m	struct:mystat	file:
unpack	msgpackLua.cpp	/^void msgpackLua_unpack::unpack(lua_State *L, msgpack_object &msg)$/;"	f	class:msgpackLua_unpack
unpackArray	msgpackLua.cpp	/^void msgpackLua_unpack::unpackArray(lua_State *L, msgpack_object_array &array)$/;"	f	class:msgpackLua_unpack
unpackLua	msgpackLua.cpp	/^int msgpackLua_unpack::unpackLua(lua_State *L)$/;"	f	class:msgpackLua_unpack
unpackLua	msgpackLua.cpp	/^int unpackLua(lua_State *L)$/;"	f
unpackTable	msgpackLua.cpp	/^void msgpackLua_unpack::unpackTable(lua_State *L, msgpack_object_map &table)$/;"	f	class:msgpackLua_unpack
unpacked	msgpackLua.hpp	/^		msgpack_unpacked unpacked;		$/;"	m	class:msgpackLua_unpack
update_inode	hash.hpp	64;"	d
update_snode	hash.hpp	70;"	d
userdata_to_connection	luamongodb/mongo_connection.cpp	/^inline DBClientConnection* userdata_to_connection(lua_State* L, int index) {$/;"	f	namespace:__anon2
userdata_to_cursor	luamongodb/mongo_cursor.cpp	/^inline DBClientCursor* userdata_to_cursor(lua_State* L, int index) {$/;"	f	namespace:__anon5
userdata_to_gridfile	luamongodb/mongo_gridfile.cpp	/^    inline GridFile* userdata_to_gridfile(lua_State* L, int index) {$/;"	f	namespace:__anon6
userdata_to_gridfs	luamongodb/mongo_gridfs.cpp	/^    inline GridFS* userdata_to_gridfs(lua_State* L, int index) {$/;"	f	namespace:__anon7
userdata_to_gridfschunk	luamongodb/mongo_gridfschunk.cpp	/^    inline CHUNK* userdata_to_gridfschunk(lua_State* L, int index) {$/;"	f	namespace:__anon4
userdata_to_query	luamongodb/mongo_query.cpp	/^inline Query* userdata_to_query(lua_State* L, int index) {$/;"	f	namespace:__anon3
val	hash.hpp	/^	void * val; \/\/value$/;"	m	struct:hlink_
valuedouble	cjson.hpp	/^	double valuedouble;			\/\/ The item's number, if type==cJSON_Number$/;"	m	struct:cJSON
valueint	cjson.hpp	/^	int valueint;				\/\/ The item's number, if type==cJSON_Number$/;"	m	struct:cJSON
valuestring	cjson.hpp	/^	char *valuestring;			\/\/ The item's string, if type==cJSON_String$/;"	m	struct:cJSON
whashstr	hash.cpp	/^inline int whashstr(const char * s, int max)$/;"	f
write	netlib.cpp	/^int TClientSocket::write(const char* dataptr, size_t length)$/;"	f	class:TClientSocket
write_policy	netlib.cpp	/^static int write_policy(lua_State* L)$/;"	f	file:
write_ref	netlib.hpp	/^		int write_ref;$/;"	m	class:TClientSocket
write_socket	netlib.cpp	/^static int write_socket(lua_State* L)$/;"	f	file:
writecb	netlib.cpp	/^int TClientSocket::writecb()$/;"	f	class:TClientSocket
x	scene.hpp	/^	int x;$/;"	m	struct:Point
y	scene.hpp	/^	int y;$/;"	m	struct:Point
zip	netlib.hpp	/^	unsigned char zip;$/;"	m	struct:Head_t
zip	netlib.hpp	/^	unsigned char zip;$/;"	m	struct:PtoNode
~CGrid	scene.cpp	/^CGrid::~CGrid()$/;"	f	class:CGrid
~CScene	scene.cpp	/^CScene::~CScene()$/;"	f	class:CScene
~TArg	luacall.hpp	/^		virtual ~TArg(){}$/;"	f	class:TArg
~TArgPool	luacall.cpp	/^TArgPool::~TArgPool()$/;"	f	class:TArgPool
~TClientSocket	netlib.cpp	/^TClientSocket::~TClientSocket()$/;"	f	class:TClientSocket
~TServerSocket	netlib.cpp	/^TServerSocket::~TServerSocket()$/;"	f	class:TServerSocket
~TSocket	netlib.hpp	/^		virtual ~TSocket(){$/;"	f	class:TSocket
~msgpackLua_pack	msgpackLua.cpp	/^msgpackLua_pack::~msgpackLua_pack()$/;"	f	class:msgpackLua_pack
~msgpackLua_unpack	msgpackLua.cpp	/^msgpackLua_unpack::~msgpackLua_unpack()$/;"	f	class:msgpackLua_unpack
